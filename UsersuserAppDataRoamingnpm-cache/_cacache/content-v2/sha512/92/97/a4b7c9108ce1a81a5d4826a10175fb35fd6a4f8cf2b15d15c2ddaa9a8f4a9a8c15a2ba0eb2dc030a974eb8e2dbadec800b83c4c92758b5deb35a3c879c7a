{"_id":"noms","_rev":"4-0b41fe08178cfdd75cbc2b49c72213c8","name":"noms","description":"easily make yummy noms for other streams","dist-tags":{"latest":"0.0.0"},"versions":{"0.0.0":{"name":"noms","version":"0.0.0","description":"easily make yummy noms for other streams","main":"index.js","dependencies":{"inherits":"^2.0.1","readable-stream":"~1.0.31"},"repository":{"type":"git","url":"https://github.com/calvinmetcalf/noms"},"devDependencies":{"tape":"^2.14.0"},"scripts":{"test":"node test.js"},"author":{"name":"Calvin Metcalf"},"license":"ISC","bugs":{"url":"https://github.com/calvinmetcalf/noms/issues"},"homepage":"https://github.com/calvinmetcalf/noms","_id":"noms@0.0.0","dist":{"shasum":"da8ebd9f3af9d6760919b27d9cdc8092a7332859","tarball":"https://registry.npmjs.org/noms/-/noms-0.0.0.tgz","integrity":"sha512-lNDU9VJaOPxUmXcLb+HQFeUgQQPtMI24Gt6hgfuMHRJgMRHMF/qZ4HJD3GDru4sSw9IQl2jPjAYnQrdIeLbwow==","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEQCIGIPI/kR3xBIspGl+PkYhuYheV77FqvRxM4GI7xXTJkwAiBUBJcCUvMIsqcUAC6qyn8mcCYWTzKddYwSEMVQwOaBgQ=="}]},"_from":".","_npmVersion":"1.4.3","_npmUser":{"name":"cwmma","email":"calvin.metcalf@gmail.com"},"maintainers":[{"name":"cwmma","email":"calvin.metcalf@gmail.com"}]}},"readme":"noms\n====\n\ncreate super easy readable-streams filled with yummy data to nom on, inspired by [from2](https://github.com/hughsk/from2) (and a test based on one from there).\n\n```bash\nnpm install noms\n```\n\n```js\nvar noms = require('noms');\n```\n\nCreate a quick readable stream\n\n```js\nnom([options], read, [before]);\n```\n\noptions is optional and passed to readable stream just like in from2 or through2\n\nread is the main read function, it is similar to the original node streams but size is optional and a callback is passed.  It will NOT be called again until the callback is called.\n\nbefore is called right before the first call to read in order to do setup, it is passed a callback and read will not be called until the callback is called.\n\nlike through2 and from2 noms also features\n\n```js\nnom.obj([options], read, [before]);\n```\n\nwhich is shorthand for creating an object stream and like from2 noms has\n\n```js\nnoms.ctor(read, [before]);\n```\n\nwhich returns a constructor function for use if you're creating a large number of copies of the stream.\n\nexample (based on one from from2):\n\n```js\nfunction fromString(string) {\n  return noms(function(size, next) {\n    // if there's no more content\n    // left in the string, close the stream.\n    if (string.length <= 0) {\n      return this.push(null);\n    }\n\n    // Pull in a new chunk of text,\n    // removing it from the string.\n    var chunk = string.slice(0, size);\n    string = string.slice(size);\n\n    // Emit \"chunk\" from the stream.\n    next(null, chunk);\n  })\n}\n```\n\nyou can use `this.push(foo)` and `next(null, foo)` interchangeably, just remember to call next at the end.\n\n```js\nfunction fromString(string) {\n  return noms(function(size, next) {\n    // if there's no more content\n    // left in the string, close the stream.\n    if (string.length <= 0) {\n      return next(null, null);\n    }\n\n    // Pull in a new chunk of text,\n    // removing it from the string.\n    var chunk = string.slice(0, size);\n    string = string.slice(size);\n\n    // Emit \"chunk\" from the stream.\n    this.push(chunk);\n    // finish up\n    next();\n  })\n}\n```\n\nIf you don't care about size you can omit it\n\n```js\nfunction fromString(sentence) {\n  var strings = sentence.trim().split(/\\s+/);\n  var i = -1;\n  var len = strings.length;\n  return noms(function(next) {\n    // if there's no more content\n    // left in the string, close the stream.\n    if (++i < len) {\n      return this.push(strings[i]);\n    } else {\n     return this.push(null);\n    }\n    next();\n}\n```\n\nYou don't have to worry about the response from this.push, as noms will call the function again after you call next until the cache is full.\n\n```js\nvar fs = require('fs');\nvar path = require('path');\nfunction getFiles(dir) {\n  var stack = [path.resolve(dir)];\n  return noms(function(next) {\n    if (!stack.length) {\n      //we are done\n      return next(null, null);\n    }\n    var self = this;\n    var current = stack.pop();\n    fs.readdir(current, function (err, paths) {\n      if (err) {\n        return next(err);\n      }\n      if (!paths.length) {\n        // this directory is empty\n        return next();\n      }\n     var todo = paths.length;\n     paths.forEach(function (file) {\n        var fullPath = path.join(current, file);\n        fs.stat(fullPath, function (err, stats) {\n          todo--;\n          if (err) {\n            return next(err);\n          }\n          if (stats.isFile()) {\n            //found a file\n            // emit it as data\n            self.push(fullPath);\n          } else if (stats.isDirectory()) {\n            // found another directory\n            // put it into the stack\n            // is depth first, switch this to\n            // a shift to make it breadth first\n            stack.push(fullPath);\n          }\n          if (!todo) {\n            // we've done all the files\n            // would be a lot simpler if I used promises\n            // would that help or hurt the example?\n            next();\n          }\n        });\n      });\n    });\n\n}\n```","maintainers":[{"name":"cwmma","email":"calvin.metcalf@gmail.com"}],"time":{"modified":"2022-06-22T04:53:21.344Z","created":"2014-09-04T12:03:31.592Z","0.0.0":"2014-09-04T12:03:31.592Z"},"homepage":"https://github.com/calvinmetcalf/noms","repository":{"type":"git","url":"https://github.com/calvinmetcalf/noms"},"author":{"name":"Calvin Metcalf"},"bugs":{"url":"https://github.com/calvinmetcalf/noms/issues"},"license":"ISC","readmeFilename":"readme.md"}