{"_id":"umzug","_rev":"92-98f10968b7c5b6db67b5c78312894299","name":"umzug","description":"Framework-agnostic migration tool for Node","dist-tags":{"latest":"3.7.0","beta":"3.5.0-0","beta-cli":"3.0.0-beta-cli.17"},"versions":{"1.0.0":{"name":"umzug","version":"1.0.0","description":"Framework agnostic migration tool for Node.JS","main":"index.js","dependencies":{"bluebird":"^2.3.10","lodash":"^2.4.1","moment":"^2.8.3","redefine":"^0.2.0","resolve":"^1.0.0"},"devDependencies":{"expect.js":"^0.3.1","gulp":"^3.8.10","gulp-mocha":"^2.0.0","mocha":"^2.0.1","sinon":"^1.11.1","yargs":"^1.3.2"},"scripts":{"test":"gulp"},"repository":{"type":"git","url":"https://github.com/sequelize/umzug.git"},"author":"","license":"MIT","bugs":{"url":"https://github.com/sequelize/umzug/issues"},"homepage":"https://github.com/sequelize/umzug","gitHead":"1172cd92497b878aa945b84eef846eef0efb44fe","_id":"umzug@1.0.0","_shasum":"035e1f3343fd876d7803ff8ea0d35c2c2a212c07","_from":".","_npmVersion":"1.4.28","_npmUser":{"name":"sdepold","email":"sascha@depold.com"},"maintainers":[{"name":"sdepold","email":"sascha@depold.com"}],"dist":{"shasum":"035e1f3343fd876d7803ff8ea0d35c2c2a212c07","tarball":"https://registry.npmjs.org/umzug/-/umzug-1.0.0.tgz","integrity":"sha512-+aSJgcE5deL4vXxNSStMeUq1v/9qP63p5PZ91oJqdeDVP+GBGNcg4QuMHlMCWsMfTVvsTkTVLZssf1rsQK7sGQ==","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEQCIGCxUDhkIsCKnadPJuwSLRfggHs4JljSe+HyetYrXqY5AiB/xJbZump6eBYztx77fr5sNI2CSCqu5XiJ7Id86mJW2w=="}]},"directories":{}},"1.1.0":{"name":"umzug","version":"1.1.0","description":"Framework agnostic migration tool for Node.JS","main":"index.js","dependencies":{"bluebird":"^2.3.10","lodash":"^2.4.1","moment":"^2.8.3","redefine":"^0.2.0","resolve":"^1.0.0"},"devDependencies":{"expect.js":"^0.3.1","gulp":"^3.8.10","gulp-mocha":"^2.0.0","mocha":"^2.0.1","sequelize":"git://github.com/sequelize/sequelize.git#ce6b7878b625f3d139791c59d493f68a1c3e0319","sinon":"^1.11.1","sqlite3":"^3.0.2","yargs":"^1.3.2"},"scripts":{"test":"gulp"},"repository":{"type":"git","url":"https://github.com/sequelize/umzug.git"},"author":"","license":"MIT","bugs":{"url":"https://github.com/sequelize/umzug/issues"},"homepage":"https://github.com/sequelize/umzug","gitHead":"47340ed25ec039fbbb56df9254fa7a13eb3c9a58","_id":"umzug@1.1.0","_shasum":"bf990b3beb29d77c3b2729a5874887763880ce48","_from":".","_npmVersion":"1.4.28","_npmUser":{"name":"sdepold","email":"sascha@depold.com"},"maintainers":[{"name":"sdepold","email":"sascha@depold.com"}],"dist":{"shasum":"bf990b3beb29d77c3b2729a5874887763880ce48","tarball":"https://registry.npmjs.org/umzug/-/umzug-1.1.0.tgz","integrity":"sha512-VPDtHQj5dzzLG5AIChraE7bR6E865VJcbMSPAWiGrS1/M9wTMBLrRxTXtn7V/jJdh9dzRricos80kYmbbIMWdA==","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEYCIQDQV4w9b2Ges/BPCs5UfEAk4Cc7MnwvXstS023rXXsZDgIhAKJlnVKjhjKU8OEqqOjQ2P9SpuFEbABdBG5ip8HUw02x"}]},"directories":{}},"1.2.0":{"name":"umzug","version":"1.2.0","description":"Framework agnostic migration tool for Node.JS","main":"index.js","dependencies":{"bluebird":"^2.3.10","lodash":"^2.4.1","moment":"^2.8.3","redefine":"^0.2.0","resolve":"^1.0.0"},"devDependencies":{"coffee-script":"^1.8.0","expect.js":"^0.3.1","gulp":"^3.8.10","gulp-mocha":"^2.0.0","mocha":"^2.0.1","sequelize":"^2.0.0-rc3","sinon":"^1.11.1","sqlite3":"^3.0.2","yargs":"^1.3.2"},"scripts":{"test":"gulp"},"repository":{"type":"git","url":"https://github.com/sequelize/umzug.git"},"author":"","license":"MIT","bugs":{"url":"https://github.com/sequelize/umzug/issues"},"homepage":"https://github.com/sequelize/umzug","gitHead":"38393cb061f4c8482e3b6b03536bfb7b397c8739","_id":"umzug@1.2.0","_shasum":"6bd44e371d0e71ed57bf87ddc4bb353d773878e0","_from":".","_npmVersion":"1.4.28","_npmUser":{"name":"sdepold","email":"sascha@depold.com"},"maintainers":[{"name":"sdepold","email":"sascha@depold.com"}],"dist":{"shasum":"6bd44e371d0e71ed57bf87ddc4bb353d773878e0","tarball":"https://registry.npmjs.org/umzug/-/umzug-1.2.0.tgz","integrity":"sha512-6+Dee0MR4ZocIMczImz6uGkQbo9az677AI7SbF8G+aoCr4VPm9q3dBdaaar3bCxIYDQXJFAJUKy+kjHLW3woaw==","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEQCIGwMdM8QBQgkXCbX6gxmWA5aA1Sz+RYV884iSGmeYaP7AiBoNWEayc5RLKGCLPZobNuPNlSzLYMMyjxbHNGWwavD1A=="}]},"directories":{}},"1.2.1":{"name":"umzug","version":"1.2.1","description":"Framework agnostic migration tool for Node.JS","main":"index.js","dependencies":{"bluebird":"^2.3.10","lodash":"^2.4.1","moment":"^2.8.3","redefine":"^0.2.0","resolve":"^1.0.0"},"devDependencies":{"coffee-script":"^1.8.0","expect.js":"^0.3.1","gulp":"^3.8.10","gulp-mocha":"^2.0.0","mocha":"^2.0.1","sequelize":"^2.0.0-rc3","sinon":"^1.11.1","sqlite3":"^3.0.2","yargs":"^1.3.2"},"scripts":{"test":"gulp"},"repository":{"type":"git","url":"https://github.com/sequelize/umzug.git"},"author":"","license":"MIT","bugs":{"url":"https://github.com/sequelize/umzug/issues"},"homepage":"https://github.com/sequelize/umzug","gitHead":"bca9e97483e97c2ff5c86bb44cc585aa208a15f0","_id":"umzug@1.2.1","_shasum":"3760f58f3bb235c1521702b53b55633f3692f476","_from":".","_npmVersion":"1.4.28","_npmUser":{"name":"sdepold","email":"sascha@depold.com"},"maintainers":[{"name":"sdepold","email":"sascha@depold.com"}],"dist":{"shasum":"3760f58f3bb235c1521702b53b55633f3692f476","tarball":"https://registry.npmjs.org/umzug/-/umzug-1.2.1.tgz","integrity":"sha512-a7bFXrNAU2J601UnHVym7W7gnLbDFLsmJTvir8zMaSV83YjcXVTpoVRRmwev6/aBV4gHeg1o8oSurmXj8Ge5Jw==","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIQCakz0SNzErW3uEgkwvHMIpNlTXv7hMVBPlHxydVK9CgwIgdH8Qfd7Sa0NDMHF6EoZF7frFbqduLfYa6DMKSJ4tUKk="}]},"directories":{}},"1.2.2":{"name":"umzug","version":"1.2.2","description":"Framework agnostic migration tool for Node.JS","main":"index.js","dependencies":{"bluebird":"^2.3.10","lodash":"^2.4.1","moment":"^2.8.3","redefine":"^0.2.0","resolve":"^1.0.0"},"devDependencies":{"coffee-script":"^1.8.0","expect.js":"^0.3.1","gulp":"^3.8.10","gulp-mocha":"^2.0.0","mocha":"^2.0.1","sequelize":"^2.0.0-rc3","sinon":"^1.11.1","sqlite3":"^3.0.2","yargs":"^1.3.2"},"scripts":{"test":"gulp"},"repository":{"type":"git","url":"https://github.com/sequelize/umzug.git"},"author":"","license":"MIT","bugs":{"url":"https://github.com/sequelize/umzug/issues"},"homepage":"https://github.com/sequelize/umzug","gitHead":"06326718eced28d7a3255d29459fd5c16b718c17","_id":"umzug@1.2.2","_shasum":"9cae4c2f38a6834cebc5c637ef12c85cb35767f0","_from":".","_npmVersion":"1.4.28","_npmUser":{"name":"sdepold","email":"sascha@depold.com"},"maintainers":[{"name":"sdepold","email":"sascha@depold.com"}],"dist":{"shasum":"9cae4c2f38a6834cebc5c637ef12c85cb35767f0","tarball":"https://registry.npmjs.org/umzug/-/umzug-1.2.2.tgz","integrity":"sha512-13Av6MHgbrXxkNp8A8LbsF4WIHfNJAuUpI72iirCWAuf3cjQg4rYDtLt+2VjH9OkpnCT88b//8fbIZ68J5KqeQ==","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEYCIQC7XEK0Z+hA7VPgiqexYV4MGZuShWz7dMlZk3ROThYpogIhAIHwOnnQcscr7yVPM62VYjlQqgkAWypWsu3aSoEoNlCu"}]},"directories":{}},"1.2.3":{"name":"umzug","version":"1.2.3","description":"Framework agnostic migration tool for Node.JS","main":"index.js","dependencies":{"bluebird":"^2.3.10","lodash":"^2.4.1","moment":"^2.8.3","redefine":"^0.2.0","resolve":"^1.0.0"},"devDependencies":{"coffee-script":"^1.8.0","expect.js":"^0.3.1","gulp":"^3.8.10","gulp-mocha":"^2.0.0","mocha":"^2.0.1","sequelize":"^2.0.0-rc3","sinon":"^1.11.1","sqlite3":"^3.0.2","yargs":"^1.3.2"},"scripts":{"test":"gulp"},"repository":{"type":"git","url":"https://github.com/sequelize/umzug.git"},"author":"","license":"MIT","bugs":{"url":"https://github.com/sequelize/umzug/issues"},"homepage":"https://github.com/sequelize/umzug","gitHead":"971da6fc1987856e7ad40cbbff8599ce0c3f74ba","_id":"umzug@1.2.3","_shasum":"d962f971771bc948709007f986c9715c944d6d49","_from":".","_npmVersion":"1.4.28","_npmUser":{"name":"sdepold","email":"sascha@depold.com"},"maintainers":[{"name":"sdepold","email":"sascha@depold.com"}],"dist":{"shasum":"d962f971771bc948709007f986c9715c944d6d49","tarball":"https://registry.npmjs.org/umzug/-/umzug-1.2.3.tgz","integrity":"sha512-FjJgzo+5z1t9P7ZM0dkLjZf63N9C1WGHsAFsHsc+juGY7x3IJDeH+bpzBqSuZPvW4xUa6K/PDKEJAJSC5rwKSg==","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIQDfOOZ9Fmm6rzH2PcC0+poTO6ZPlMOce71BCx69LrZO3wIgQ9suweNKHnsiLU8YPyLlQdSPvRaRImH4uga2fAzZJAY="}]},"directories":{}},"1.2.4":{"name":"umzug","version":"1.2.4","description":"Framework agnostic migration tool for Node.JS","main":"index.js","dependencies":{"bluebird":"^2.3.10","lodash":"^2.4.1","moment":"^2.8.3","redefine":"^0.2.0","resolve":"^1.0.0"},"devDependencies":{"coffee-script":"^1.8.0","expect.js":"^0.3.1","gulp":"^3.8.10","gulp-mocha":"^2.0.0","mocha":"^2.0.1","sequelize":"^2.0.0-rc3","sinon":"^1.11.1","sqlite3":"^3.0.2","yargs":"^1.3.2"},"scripts":{"test":"gulp"},"repository":{"type":"git","url":"https://github.com/sequelize/umzug.git"},"author":"","license":"MIT","bugs":{"url":"https://github.com/sequelize/umzug/issues"},"homepage":"https://github.com/sequelize/umzug","gitHead":"f213534071976641a306c2efbbd0b82a310f6a24","_id":"umzug@1.2.4","_shasum":"9c8e71eaf8b500e68672750c2cf8dcd87c65d1d7","_from":".","_npmVersion":"1.4.28","_npmUser":{"name":"sdepold","email":"sascha@depold.com"},"maintainers":[{"name":"sdepold","email":"sascha@depold.com"}],"dist":{"shasum":"9c8e71eaf8b500e68672750c2cf8dcd87c65d1d7","tarball":"https://registry.npmjs.org/umzug/-/umzug-1.2.4.tgz","integrity":"sha512-SmOIwdxDZ7B7mXK5NmvyQQlpHRA5CE0K5lmce7dmHBPJqjHdSVyinUYICKhohtkVjNCALgkHrcn6us4lLRJ2IQ==","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEYCIQDaPTIqA77JPFSissY+ecaY8yxxYkLbLWMoTCdJrOfM6QIhAKkeUuTeyu1RP0BSpDwBFskhubiL2Ui5Yp9rF/yPsvng"}]},"directories":{}},"1.3.0":{"name":"umzug","version":"1.3.0","description":"Framework agnostic migration tool for Node.JS","main":"index.js","dependencies":{"bluebird":"^2.3.10","lodash":"^2.4.1","moment":"^2.8.3","redefine":"^0.2.0","resolve":"^1.0.0"},"devDependencies":{"coffee-script":"^1.8.0","expect.js":"^0.3.1","gulp":"^3.8.10","gulp-mocha":"^2.0.0","mocha":"^2.0.1","sequelize":"^2.0.0-rc3","sinon":"^1.11.1","sqlite3":"^3.0.2","yargs":"^1.3.2"},"scripts":{"test":"gulp"},"repository":{"type":"git","url":"https://github.com/sequelize/umzug.git"},"author":"","license":"MIT","bugs":{"url":"https://github.com/sequelize/umzug/issues"},"homepage":"https://github.com/sequelize/umzug","gitHead":"0e735f7aef7d4eef9609856c230add0a78295193","_id":"umzug@1.3.0","_shasum":"493576e6f1e6d9daafa28c01eeb9067266aaa0a5","_from":".","_npmVersion":"1.4.28","_npmUser":{"name":"sdepold","email":"sascha@depold.com"},"maintainers":[{"name":"sdepold","email":"sascha@depold.com"}],"dist":{"shasum":"493576e6f1e6d9daafa28c01eeb9067266aaa0a5","tarball":"https://registry.npmjs.org/umzug/-/umzug-1.3.0.tgz","integrity":"sha512-jkJ9R3/CfJ3IHqMoU9nYRLiHwcAToDkgU7VOKy3CSC/caRG6ZPbrsSv9rqNnIIwrnPVXR/ZSDpAkOyqCxyi/AA==","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIDl71y6euOkPaAv6apIEZNXKU9fPbh2hov79C9q2BacPAiEAghPBewE3Qd+LQghvc41zUxnaiKXggumtfb+auiKhq5A="}]},"directories":{}},"1.3.1":{"name":"umzug","version":"1.3.1","description":"Framework agnostic migration tool for Node.JS","main":"index.js","dependencies":{"bluebird":"^2.3.10","lodash":"^3.0.1","moment":"^2.8.3","redefine":"^0.2.0","resolve":"^1.0.0"},"devDependencies":{"coffee-script":"^1.8.0","expect.js":"^0.3.1","gulp":"^3.8.10","gulp-mocha":"^2.0.0","mocha":"^2.0.1","sequelize":"^2.0.0-rc3","sinon":"^1.11.1","sqlite3":"^3.0.2","yargs":"^1.3.2"},"scripts":{"test":"gulp"},"repository":{"type":"git","url":"https://github.com/sequelize/umzug.git"},"author":"","license":"MIT","bugs":{"url":"https://github.com/sequelize/umzug/issues"},"homepage":"https://github.com/sequelize/umzug","gitHead":"ccd5a3c0ea742bc6791f9ce183cf10475d860e7f","_id":"umzug@1.3.1","_shasum":"ebca82759099b834224d9fd08d70d9afb61603d5","_from":".","_npmVersion":"1.4.28","_npmUser":{"name":"sdepold","email":"sascha@depold.com"},"maintainers":[{"name":"sdepold","email":"sascha@depold.com"}],"dist":{"shasum":"ebca82759099b834224d9fd08d70d9afb61603d5","tarball":"https://registry.npmjs.org/umzug/-/umzug-1.3.1.tgz","integrity":"sha512-ElhmjFnpdB5vujH7c9zMcpoohi3SD3jDU3Lds/jslZ2P+xQwCL7qBTteNM5I3rdHbj1X0CtD7pKFQndGJJy2nw==","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEYCIQD1Y2Q25v8/5c5NyoaVhQxWc80/qO9W6WzJF0crVguMvAIhAMv8OL/FTjUqw2XIo1qmS0a41nSrHR2sl/PtdKWtUYWt"}]},"directories":{}},"1.4.0":{"name":"umzug","version":"1.4.0","description":"Framework agnostic migration tool for Node.JS","main":"index.js","dependencies":{"bluebird":"^2.3.10","lodash":"^3.0.1","moment":"^2.8.3","redefine":"^0.2.0","resolve":"^1.0.0"},"devDependencies":{"coffee-script":"^1.8.0","expect.js":"^0.3.1","gulp":"^3.8.10","gulp-mocha":"^2.0.0","mocha":"^2.0.1","sequelize":"^2.0.0-rc3","sinon":"^1.11.1","sqlite3":"^3.0.2","yargs":"^1.3.2"},"scripts":{"test":"gulp"},"repository":{"type":"git","url":"https://github.com/sequelize/umzug.git"},"author":"","license":"MIT","bugs":{"url":"https://github.com/sequelize/umzug/issues"},"homepage":"https://github.com/sequelize/umzug","gitHead":"593bf104cbd546ce7ec1f120b56a90fb2fcc19e9","_id":"umzug@1.4.0","_shasum":"99003d45cbe6cdde6278e9553471656e62f99644","_from":".","_npmVersion":"1.4.28","_npmUser":{"name":"sdepold","email":"sascha@depold.com"},"maintainers":[{"name":"sdepold","email":"sascha@depold.com"}],"dist":{"shasum":"99003d45cbe6cdde6278e9553471656e62f99644","tarball":"https://registry.npmjs.org/umzug/-/umzug-1.4.0.tgz","integrity":"sha512-xu9YoDee+x85cIl/B1IyOoNAZyBUqtofm+ydhwBJZ1Vevjuxm/ZjsiSkw0TZ7kV8T4ZfUAYgQ/12jI/l+Jqj0Q==","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEQCIEy/zCYxPcgmfPIdmF3Wa0PioKhucIHTdg2QEs5MeN4zAiB58ZNdlK6qT619DFF22hIekSr/Iqw4veY67TEh7LhdPw=="}]},"directories":{}},"1.5.0":{"name":"umzug","version":"1.5.0","description":"Framework agnostic migration tool for Node.JS","main":"index.js","dependencies":{"bluebird":"^2.3.10","lodash":"^3.0.1","moment":"^2.8.3","redefine":"^0.2.0","resolve":"^1.0.0"},"devDependencies":{"coffee-script":"^1.8.0","expect.js":"^0.3.1","gulp":"^3.8.10","gulp-mocha":"^2.0.0","mocha":"^2.0.1","sequelize":"^2.0.0-rc3","sinon":"^1.11.1","sqlite3":"^3.0.2","yargs":"^1.3.2"},"scripts":{"test":"gulp"},"repository":{"type":"git","url":"https://github.com/sequelize/umzug.git"},"author":"","license":"MIT","bugs":{"url":"https://github.com/sequelize/umzug/issues"},"homepage":"https://github.com/sequelize/umzug","gitHead":"b7f986d36e53b178b1fd4133f3e25461e5919fe5","_id":"umzug@1.5.0","_shasum":"0dac90f4febe7f269cbc17a06c51e18bd66a68bd","_from":".","_npmVersion":"1.4.28","_npmUser":{"name":"sdepold","email":"sascha@depold.com"},"maintainers":[{"name":"sdepold","email":"sascha@depold.com"}],"dist":{"shasum":"0dac90f4febe7f269cbc17a06c51e18bd66a68bd","tarball":"https://registry.npmjs.org/umzug/-/umzug-1.5.0.tgz","integrity":"sha512-v9CZ6xzv0TOyECQGRu1m2Y26+K7oiFRpKdNny3ZgL9JKPtT/22IIv+K/5eQm7DUkTilcVNuOeeQ7Bx6mTkGu2g==","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIQCf9ivvJ0N27IQfepBbPFWQJ2Hz6qHTwmLL29Ayyubk9wIgQpHTZuqx+RIEUnSKw1FHRRvPdh3UoK+TNlJUFtMs4pw="}]},"directories":{}},"1.6.0":{"name":"umzug","version":"1.6.0","description":"Framework agnostic migration tool for Node.JS","main":"index.js","dependencies":{"bluebird":"^2.3.10","lodash":"^3.0.1","moment":"^2.8.3","redefine":"^0.2.0","resolve":"^1.0.0"},"devDependencies":{"coffee-script":"^1.8.0","expect.js":"^0.3.1","gulp":"^3.8.10","gulp-mocha":"^2.0.0","mocha":"^2.0.1","sequelize":"^2.0.0-rc3","sinon":"^1.11.1","sqlite3":"^3.0.2","yargs":"^1.3.2"},"scripts":{"test":"gulp"},"repository":{"type":"git","url":"https://github.com/sequelize/umzug.git"},"author":"","license":"MIT","bugs":{"url":"https://github.com/sequelize/umzug/issues"},"homepage":"https://github.com/sequelize/umzug","gitHead":"5c2a3e141c27cb46f28ba1cd31bf1acdbe6cd6af","_id":"umzug@1.6.0","_shasum":"464296e63c9caf981aabbdcafb6ebc1b2c0e6559","_from":".","_npmVersion":"1.4.28","_npmUser":{"name":"sdepold","email":"sascha@depold.com"},"maintainers":[{"name":"sdepold","email":"sascha@depold.com"}],"dist":{"shasum":"464296e63c9caf981aabbdcafb6ebc1b2c0e6559","tarball":"https://registry.npmjs.org/umzug/-/umzug-1.6.0.tgz","integrity":"sha512-CDT7BfsZYl54DZ5ANV9bcCkC8afokjbtBISHCpt3INjPKti+LVrI5MFHqBt28sUFOUqsGe52U10+K5gYe28w9w==","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEQCICGIo/SOufS2ThQ9b2rSUJP98Os9IcmFuaeNUnzg0SBzAiBEPAAZ/Q0ufONxrpiv3iRU3kfF2MDdZtpbc1pum7yjAw=="}]},"directories":{}},"1.7.0":{"name":"umzug","version":"1.7.0","description":"Framework agnostic migration tool for Node.JS","main":"index.js","dependencies":{"bluebird":"^3.0.1","lodash":"^3.0.1","moment":"^2.8.3","redefine":"^0.2.0","resolve":"^1.0.0"},"devDependencies":{"coffee-script":"^1.8.0","expect.js":"^0.3.1","gulp":"^3.8.10","gulp-jshint":"^2.0.0","gulp-jshint-instafail":"^1.0.0","gulp-mocha":"^2.0.0","jshint-stylish":"^2.0.0","mocha":"^2.0.1","sequelize":"^3.13.0","sinon":"^1.11.1","sqlite3":"^3.0.2","yargs":"^3.29.0"},"scripts":{"test":"gulp"},"repository":{"type":"git","url":"git+https://github.com/sequelize/umzug.git"},"author":"","license":"MIT","bugs":{"url":"https://github.com/sequelize/umzug/issues"},"homepage":"https://github.com/sequelize/umzug","gitHead":"5777d991332b51aa1298e9ae34008be60d503c65","_id":"umzug@1.7.0","_shasum":"c5ab612e2236cb85d1de298c7414bca6be467bfd","_from":".","_npmVersion":"2.13.2","_nodeVersion":"2.5.0","_npmUser":{"name":"sdepold","email":"sascha@depold.com"},"maintainers":[{"name":"sdepold","email":"sascha@depold.com"}],"dist":{"shasum":"c5ab612e2236cb85d1de298c7414bca6be467bfd","tarball":"https://registry.npmjs.org/umzug/-/umzug-1.7.0.tgz","integrity":"sha512-/Gu6Kpa9JhWIcdfD+v0eW/elU9RLvlLbRd+7Jo2+Wen5rMs63rXTpdzzFIPiLZtE18MITJeg0vf4RyjHl/Pt3A==","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEYCIQDvqkUvXa5dC7trfYgYLHueKa/7YNdSs0brwMwpcCmLNQIhALHByP+lZ+AIFF6c//RCduG8+MOKtZ5AbI5y/CHPGO3/"}]},"directories":{}},"1.7.1":{"name":"umzug","version":"1.7.1","description":"Framework agnostic migration tool for Node.JS","main":"index.js","dependencies":{"bluebird":"^3.0.1","lodash":"^3.0.1","moment":"^2.8.3","redefine":"^0.2.0","resolve":"^1.0.0"},"devDependencies":{"coffee-script":"^1.8.0","expect.js":"^0.3.1","gulp":"^3.8.10","gulp-jshint":"^2.0.0","gulp-jshint-instafail":"^1.0.0","gulp-mocha":"^2.0.0","jshint-stylish":"^2.0.0","mocha":"^2.0.1","sequelize":"^3.13.0","sinon":"^1.11.1","sqlite3":"^3.0.2","yargs":"^3.29.0"},"scripts":{"test":"gulp"},"repository":{"type":"git","url":"git+https://github.com/sequelize/umzug.git"},"author":"","license":"MIT","bugs":{"url":"https://github.com/sequelize/umzug/issues"},"homepage":"https://github.com/sequelize/umzug","gitHead":"5da46c6c11a1966d052633ee735c53b4eb2c51bc","_id":"umzug@1.7.1","_shasum":"3f28a34276ef747093a383e093a1ef398d431309","_from":".","_npmVersion":"2.14.12","_nodeVersion":"2.5.0","_npmUser":{"name":"sdepold","email":"sascha@depold.com"},"maintainers":[{"name":"sdepold","email":"sascha@depold.com"}],"dist":{"shasum":"3f28a34276ef747093a383e093a1ef398d431309","tarball":"https://registry.npmjs.org/umzug/-/umzug-1.7.1.tgz","integrity":"sha512-QIMz8QWyTKx1sqOdmX5Qobrky4FzA5V6Rm4Cn8BYEXNLFMpfjKsbohR0np5LSdLDlEdsAe1BdhZMY1Od48aEQw==","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEYCIQDtUQWr1CNkBRxxig4/8ZF2s337Do6VG7nG9H96hNcc9AIhAIE49p5VJjsvCHYAHQyaqK7avp2+AtK2hgyjfSc1TINb"}]},"directories":{}},"1.7.2":{"name":"umzug","version":"1.7.2","description":"Framework agnostic migration tool for Node.JS","main":"index.js","dependencies":{"bluebird":"^3.0.1","lodash":"^3.0.1","moment":"^2.8.3","redefine":"^0.2.0","resolve":"^1.0.0"},"devDependencies":{"coffee-script":"^1.8.0","expect.js":"^0.3.1","gulp":"^3.8.10","gulp-jshint":"^2.0.0","gulp-jshint-instafail":"^1.0.0","gulp-mocha":"^2.0.0","jshint-stylish":"^2.0.0","mocha":"^2.0.1","sequelize":"^3.13.0","sinon":"^1.11.1","sqlite3":"^3.0.2","yargs":"^3.29.0"},"scripts":{"test":"gulp"},"repository":{"type":"git","url":"git+https://github.com/sequelize/umzug.git"},"author":"","license":"MIT","bugs":{"url":"https://github.com/sequelize/umzug/issues"},"homepage":"https://github.com/sequelize/umzug","gitHead":"c2907623843162e06e880269bf645a5633383bd0","_id":"umzug@1.7.2","_shasum":"5a57cbbecccb39cf8b18cf28277953cced6dad69","_from":".","_npmVersion":"2.14.7","_nodeVersion":"4.2.2","_npmUser":{"name":"sdepold","email":"sascha@depold.com"},"maintainers":[{"name":"sdepold","email":"sascha@depold.com"}],"dist":{"shasum":"5a57cbbecccb39cf8b18cf28277953cced6dad69","tarball":"https://registry.npmjs.org/umzug/-/umzug-1.7.2.tgz","integrity":"sha512-nSTET6pWl3gRwvX039zQOx+e77trgLg+Vl8YCy/8HlydC7JnldEuGwWRlfO3qyDSu5SIsHG1ZSbeldVLOG3wfA==","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEYCIQDJqKihk6r19/M+/lLc0mXjMz8OmEXAX7M6r0Q2nm5ZGQIhAPzySCWho2Une99LunP84QFsc7Vczdvd3DhHQeS52Go3"}]},"directories":{}},"1.8.0":{"name":"umzug","version":"1.8.0","description":"Framework agnostic migration tool for Node.JS","main":"index.js","dependencies":{"bluebird":"^3.0.1","lodash":"^3.0.1","moment":"^2.8.3","redefine":"^0.2.0","resolve":"^1.0.0"},"devDependencies":{"coffee-script":"^1.8.0","expect.js":"^0.3.1","gulp":"^3.8.10","gulp-jshint":"^2.0.0","gulp-jshint-instafail":"^1.0.0","gulp-mocha":"^2.0.0","jshint-stylish":"^2.0.0","mocha":"^2.0.1","sequelize":"^3.13.0","sinon":"^1.11.1","sqlite3":"^3.0.2","yargs":"^3.29.0"},"scripts":{"test":"gulp"},"repository":{"type":"git","url":"git+https://github.com/sequelize/umzug.git"},"author":"","license":"MIT","bugs":{"url":"https://github.com/sequelize/umzug/issues"},"homepage":"https://github.com/sequelize/umzug","gitHead":"1a2ad4fadce88b5952c6e20f915e86037ce64c7b","_id":"umzug@1.8.0","_shasum":"ef777966a040ef54e6e86c8d0cfa50f029828fa2","_from":".","_npmVersion":"2.14.12","_nodeVersion":"4.2.4","_npmUser":{"name":"sdepold","email":"sascha@depold.com"},"dist":{"shasum":"ef777966a040ef54e6e86c8d0cfa50f029828fa2","tarball":"https://registry.npmjs.org/umzug/-/umzug-1.8.0.tgz","integrity":"sha512-yWQF6Hlvg1vqHSw9gDn2cnNrhwlr4FQWdFCfAm2V38F5yUoTP1cmSUbl7QG5QTlE4W0gcphmGEuuVWin8xqA7g==","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIByKAECOfV0kLKOjwdlaEomXh2deWwvQ2no86PFZBoJNAiEAgaQf/yZUnC0t7EcGRfUfbu7pSpWWWO8ffIJBJx5z/XY="}]},"maintainers":[{"name":"sdepold","email":"sascha@depold.com"}],"directories":{}},"1.8.1":{"name":"umzug","version":"1.8.1","description":"Framework agnostic migration tool for Node.JS","main":"index.js","dependencies":{"bluebird":"^3.0.1","lodash":"^4.3.0","moment":"^2.8.3","redefine":"^0.2.0","resolve":"^1.0.0"},"devDependencies":{"coffee-script":"^1.8.0","expect.js":"^0.3.1","gulp":"^3.8.10","gulp-jshint":"^2.0.0","gulp-jshint-instafail":"^1.0.0","gulp-mocha":"^2.0.0","jshint-stylish":"^2.0.0","mocha":"^2.0.1","sequelize":"^3.13.0","sinon":"^1.11.1","sqlite3":"^3.0.2","yargs":"^3.29.0"},"scripts":{"test":"gulp"},"repository":{"type":"git","url":"git+https://github.com/sequelize/umzug.git"},"author":"","license":"MIT","bugs":{"url":"https://github.com/sequelize/umzug/issues"},"homepage":"https://github.com/sequelize/umzug","gitHead":"da190a53e438adb9dbc3842d0eca9c83448ad978","_id":"umzug@1.8.1","_shasum":"383448f542a8396105809272f04d77f547b6ebb6","_from":".","_npmVersion":"2.13.2","_nodeVersion":"4.2.4","_npmUser":{"name":"sdepold","email":"sascha@depold.com"},"dist":{"shasum":"383448f542a8396105809272f04d77f547b6ebb6","tarball":"https://registry.npmjs.org/umzug/-/umzug-1.8.1.tgz","integrity":"sha512-LKZ+8x7RwopCwVAyxTekqF2PRtKyHrUFkJWKRXFpRWT/oVBd69IMBjxByFPAyVbWX/ijoBFMmPtc/YZYXdifDg==","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEYCIQCEviwWKs3CAaVfg8PBmBoxNZEC1Vi9lir2XpX1x4+3GAIhALVTJFP/8pBKgCVahovp4p7dy9dA+FwAakFRZN7HUIBv"}]},"maintainers":[{"name":"sdepold","email":"sascha@depold.com"}],"_npmOperationalInternal":{"host":"packages-5-east.internal.npmjs.com","tmp":"tmp/umzug-1.8.1.tgz_1455051858894_0.6937441646587104"},"directories":{}},"1.9.0":{"name":"umzug","version":"1.9.0","description":"Framework agnostic migration tool for Node.JS","main":"index.js","dependencies":{"bluebird":"^3.0.1","lodash":"^4.3.0","moment":"^2.8.3","redefine":"^0.2.0","resolve":"^1.0.0"},"devDependencies":{"coffee-script":"^1.8.0","expect.js":"^0.3.1","gulp":"^3.8.10","gulp-jshint":"^2.0.0","gulp-jshint-instafail":"^1.0.0","gulp-mocha":"^2.0.0","jshint-stylish":"^2.0.0","mocha":"^2.0.1","sequelize":"^3.13.0","sinon":"^1.11.1","sqlite3":"^3.0.2","yargs":"^3.29.0"},"scripts":{"test":"gulp"},"repository":{"type":"git","url":"git+https://github.com/sequelize/umzug.git"},"author":"","license":"MIT","bugs":{"url":"https://github.com/sequelize/umzug/issues"},"homepage":"https://github.com/sequelize/umzug","gitHead":"3f191e4a15f2bb602bb6f0547933b4b3358503ab","_id":"umzug@1.9.0","_shasum":"7c035ad5d6fde7939391643e90dd140d015916ae","_from":".","_npmVersion":"2.13.2","_nodeVersion":"4.2.4","_npmUser":{"name":"sdepold","email":"sascha@depold.com"},"dist":{"shasum":"7c035ad5d6fde7939391643e90dd140d015916ae","tarball":"https://registry.npmjs.org/umzug/-/umzug-1.9.0.tgz","integrity":"sha512-RfkjjZLn9L7oBlATv4BFoQ0NVDZCeOTkzw6C4KaUoy6zRbiJhCX2jDXoBBFbXg1Fz6yCpvRaAPS8j1TRbiGoHQ==","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEYCIQCK7WGLtje1ArqqXCkNAxOt89krmutdZNFzOdNbn76/5wIhALj9tyY/iWZ8gtz1il2IYAKdYv3T4NeJC6HCreLAGHyp"}]},"maintainers":[{"name":"sdepold","email":"sascha@depold.com"}],"_npmOperationalInternal":{"host":"packages-5-east.internal.npmjs.com","tmp":"tmp/umzug-1.9.0.tgz_1455051963605_0.9925247218925506"},"directories":{}},"1.9.1":{"name":"umzug","version":"1.9.1","description":"Framework agnostic migration tool for Node.JS","main":"index.js","dependencies":{"bluebird":"^3.0.1","lodash":"^4.3.0","moment":"^2.8.3","redefine":"^0.2.0","resolve":"^1.0.0"},"devDependencies":{"coffee-script":"^1.8.0","expect.js":"^0.3.1","gulp":"^3.8.10","gulp-jshint":"^2.0.0","gulp-jshint-instafail":"^1.0.0","gulp-mocha":"^2.0.0","jshint-stylish":"^2.0.0","mocha":"^2.0.1","sequelize":"^3.13.0","sinon":"^1.11.1","sqlite3":"^3.0.2","yargs":"^4.1.0"},"scripts":{"test":"gulp"},"repository":{"type":"git","url":"git+https://github.com/sequelize/umzug.git"},"author":"","license":"MIT","bugs":{"url":"https://github.com/sequelize/umzug/issues"},"homepage":"https://github.com/sequelize/umzug","gitHead":"4bd7f6c8cfdd36f2e7d45b9207a9cd41dffbcef3","_id":"umzug@1.9.1","_shasum":"349b4a16716676b8cc24c4a8972058fb5c550eb8","_from":".","_npmVersion":"2.14.12","_nodeVersion":"4.3.1","_npmUser":{"name":"sdepold","email":"sascha@depold.com"},"dist":{"shasum":"349b4a16716676b8cc24c4a8972058fb5c550eb8","tarball":"https://registry.npmjs.org/umzug/-/umzug-1.9.1.tgz","integrity":"sha512-9L2HI7EKY+g5BGCr3PteFoR5RmJ3TwSCVFWa/JO24rik41MLoh5x5BCtkhYRhH0kwaJuiybYEZS9CSVq6KCvtA==","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIQC7CmAJquUCdzqh2J0XdxRxb7Qsj+JytiX25u0kP0TqVQIgCojgF1i8S2rbYmgVJq8mELJVJJS9gDTu0xtV0uQZUis="}]},"maintainers":[{"name":"sdepold","email":"sascha@depold.com"}],"_npmOperationalInternal":{"host":"packages-13-west.internal.npmjs.com","tmp":"tmp/umzug-1.9.1.tgz_1457935098205_0.40883967955596745"},"directories":{}},"1.10.0":{"name":"umzug","version":"1.10.0","description":"Framework agnostic migration tool for Node.JS","main":"index.js","dependencies":{"bluebird":"^3.0.1","lodash":"^4.3.0","moment":"^2.8.3","redefine":"^0.2.0","resolve":"^1.0.0"},"devDependencies":{"coffee-script":"^1.8.0","expect.js":"^0.3.1","gulp":"^3.8.10","gulp-jshint":"^2.0.0","gulp-jshint-instafail":"^1.0.0","gulp-mocha":"^2.0.0","jshint":"^2.9.1","jshint-stylish":"^2.0.0","mocha":"^2.0.1","sequelize":"^3.13.0","sinon":"^1.11.1","sqlite3":"^3.0.2","yargs":"^4.1.0"},"scripts":{"test":"gulp"},"repository":{"type":"git","url":"git+https://github.com/sequelize/umzug.git"},"author":"","license":"MIT","bugs":{"url":"https://github.com/sequelize/umzug/issues"},"homepage":"https://github.com/sequelize/umzug","gitHead":"660864fdf83bb6d78b56ee49248ab2b8c222229a","_id":"umzug@1.10.0","_shasum":"96333c7c53e31a4f7d02829d377765e3dd32038c","_from":".","_npmVersion":"2.14.12","_nodeVersion":"4.3.1","_npmUser":{"name":"sdepold","email":"sascha@depold.com"},"dist":{"shasum":"96333c7c53e31a4f7d02829d377765e3dd32038c","tarball":"https://registry.npmjs.org/umzug/-/umzug-1.10.0.tgz","integrity":"sha512-HPF9gLaFcbqB+PWAXXDN1mdVIF14xj2IHl8UbGZ79FbehJ94mulnXKgomaPWMAn5RGfI0mOAVqnaqjKoMRS6qg==","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIFFMLbiMny6Pt8qweMvzFjDyqr1NZkA2tRryPLiTbrsgAiEA/1jXj0y5cVL/Y/7Z3PuxpVcDa06Jv2YC7pc+tXNP2kE="}]},"maintainers":[{"name":"sdepold","email":"sascha@depold.com"}],"_npmOperationalInternal":{"host":"packages-16-east.internal.npmjs.com","tmp":"tmp/umzug-1.10.0.tgz_1460915888862_0.05820033047348261"},"directories":{}},"1.11.0":{"name":"umzug","version":"1.11.0","description":"Framework agnostic migration tool for Node.JS","main":"index.js","dependencies":{"bluebird":"^3.0.1","lodash":"^4.3.0","moment":"^2.8.3","redefine":"^0.2.0","resolve":"^1.0.0"},"devDependencies":{"coffee-script":"^1.8.0","expect.js":"^0.3.1","gulp":"^3.8.10","gulp-jshint":"^2.0.0","gulp-jshint-instafail":"^1.0.0","gulp-mocha":"^2.0.0","jshint":"^2.9.1","jshint-stylish":"^2.0.0","mocha":"^2.0.1","sequelize":"^3.13.0","sinon":"^1.11.1","sqlite3":"^3.0.2","yargs":"^4.1.0"},"scripts":{"test":"gulp"},"repository":{"type":"git","url":"git+https://github.com/sequelize/umzug.git"},"author":"","license":"MIT","bugs":{"url":"https://github.com/sequelize/umzug/issues"},"homepage":"https://github.com/sequelize/umzug","gitHead":"f2233379f2174c5baca96f294e78ac7590d1623c","_id":"umzug@1.11.0","_shasum":"6531ad4b5b650957d1791f98189f435235d07cce","_from":".","_npmVersion":"2.14.12","_nodeVersion":"4.3.2","_npmUser":{"name":"jukkah","email":"hyytiala.jukka@gmail.com"},"dist":{"shasum":"6531ad4b5b650957d1791f98189f435235d07cce","tarball":"https://registry.npmjs.org/umzug/-/umzug-1.11.0.tgz","integrity":"sha512-ZKkDhq+rV8J6CUndRqIUNduwGI0PprtfAKhjcMwBwmA4rJX5GI+wQ/Yr/Mwz2MCDKVwHwS9ey12lNi8G+2Y0+Q==","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEQCIA6hA3qiqPPUKeNGLlBGiEXj8B+F3RCrmKG5cWdKrMK7AiAE/0MCTmZq2nECpw7fsEh5SknUFoR/nPsIcMyTqjH0qQ=="}]},"maintainers":[{"name":"jukkah","email":"hyytiala.jukka@gmail.com"},{"name":"sdepold","email":"sascha@depold.com"}],"_npmOperationalInternal":{"host":"packages-12-west.internal.npmjs.com","tmp":"tmp/umzug-1.11.0.tgz_1461962189385_0.5355435060337186"},"directories":{}},"1.12.0":{"name":"umzug","version":"1.12.0","description":"Framework agnostic migration tool for Node.JS","main":"index.js","dependencies":{"bluebird":"^3.4.1","lodash":"^4.17.0","moment":"^2.16.0","redefine":"^0.2.0","resolve":"^1.0.0"},"devDependencies":{"coffee-script":"^1.8.0","expect.js":"^0.3.1","gulp":"^3.8.10","gulp-jshint":"^2.0.3","gulp-jshint-instafail":"^1.0.0","gulp-mocha":"^4.3.0","jshint":"^2.9.1","jshint-stylish":"^2.0.0","mocha":"^3.0.1","sequelize":"^3.30.4","sinon":"^2.1.0","sqlite3":"^3.1.5","yargs":"^7.1.0"},"scripts":{"test":"gulp"},"repository":{"type":"git","url":"git+https://github.com/sequelize/umzug.git"},"author":"","license":"MIT","bugs":{"url":"https://github.com/sequelize/umzug/issues"},"homepage":"https://github.com/sequelize/umzug","gitHead":"ad465b1838568fed45ff6a3aa0c136f6a22c79f0","_id":"umzug@1.12.0","_shasum":"a79c91f2862eee3130c6c347f2b90ad68a66e8b8","_from":".","_npmVersion":"3.10.10","_nodeVersion":"6.10.0","_npmUser":{"name":"jukkah","email":"hyytiala.jukka@gmail.com"},"dist":{"shasum":"a79c91f2862eee3130c6c347f2b90ad68a66e8b8","tarball":"https://registry.npmjs.org/umzug/-/umzug-1.12.0.tgz","integrity":"sha512-wYsxft6b3T0t1/7MeYbx4pQmBmg2wl2ftaNMGnaTZ6czFXlcrKXR8yB3HPVpjXBhsEU3ZtE1fyBuvjF9A0zuLA==","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEYCIQCb8vuUZJ3acVoiVHzJZSWM6EhUJE+fBGkiXuAa34/OtQIhAIdLV0ADxBAqga35VUA1BgIbibKcD/mnGTUjxohccp9u"}]},"maintainers":[{"name":"jukkah","email":"hyytiala.jukka@gmail.com"},{"name":"sdepold","email":"sascha@depold.com"}],"_npmOperationalInternal":{"host":"packages-12-west.internal.npmjs.com","tmp":"tmp/umzug-1.12.0.tgz_1492786059085_0.38760489877313375"},"directories":{}},"2.0.0":{"name":"umzug","version":"2.0.0","description":"Framework agnostic migration tool for Node.JS","keywords":["migrate","migration","migrations","sequelize"],"main":"lib/index.js","dependencies":{"babel-runtime":"^6.23.0","bluebird":"^3.4.1","lodash":"^4.17.0","resolve":"^1.0.0"},"devDependencies":{"babel-cli":"^6.24.1","babel-plugin-dynamic-import-node":"^1.0.1","babel-plugin-syntax-dynamic-import":"^6.18.0","babel-plugin-transform-object-rest-spread":"^6.23.0","babel-plugin-transform-runtime":"^6.23.0","babel-preset-env":"^1.4.0","babel-register":"^6.24.1","chai":"^3.5.0","coffee-script":"^1.8.0","gulp":"^3.8.10","gulp-jshint":"^2.0.3","gulp-jshint-instafail":"^1.0.0","gulp-mocha":"^4.3.0","jshint":"^2.9.1","jshint-stylish":"^2.0.0","mocha":"^3.3.0","sequelize":"^3.30.4","sinon":"^2.1.0","sqlite3":"^3.1.5","yargs":"^8.0.1"},"scripts":{"build":"babel src -d lib","test":"mocha --compilers js:babel-register test"},"repository":{"type":"git","url":"git+https://github.com/sequelize/umzug.git"},"author":{"name":"Sascha Depold","email":"sascha@depold.com"},"contributors":[{"name":"Jukka Hyytiälä","email":"hyytiala.jukka@gmail.com"}],"license":"MIT","bugs":{"url":"https://github.com/sequelize/umzug/issues"},"homepage":"https://github.com/sequelize/umzug","engines":{"node":">=4.0.0"},"gitHead":"54443c208d1aff0c5197c4f8c6e7d6d8f0244f60","_id":"umzug@2.0.0","_shasum":"fdf1c65afec17e666725b26b7c5b88afa0cc237d","_from":".","_npmVersion":"3.10.10","_nodeVersion":"6.10.0","_npmUser":{"name":"jukkah","email":"hyytiala.jukka@gmail.com"},"dist":{"shasum":"fdf1c65afec17e666725b26b7c5b88afa0cc237d","tarball":"https://registry.npmjs.org/umzug/-/umzug-2.0.0.tgz","integrity":"sha512-Imd2OYlTZRAA5sfIP47vmcSSSMbNiMCYo1W1CCoFXe+CgWaYJzjopyGNLjdH4s7E2XkejWL4eitJVQmHVkTNPQ==","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEYCIQDB1nOH4uhR/R84CVyIQ9qe3UlbL/RcWR4DOOwgFJ8jkQIhANrnmC/LGf1gBlVKoRbMctLOScwxrvxf4sQd3dvv56AD"}]},"maintainers":[{"name":"jukkah","email":"hyytiala.jukka@gmail.com"},{"name":"sdepold","email":"sascha@depold.com"}],"_npmOperationalInternal":{"host":"packages-18-east.internal.npmjs.com","tmp":"tmp/umzug-2.0.0.tgz_1494428725934_0.7293202022556216"},"deprecated":"broken package, fixed in v2.0.1","directories":{}},"2.0.1":{"name":"umzug","version":"2.0.1","description":"Framework agnostic migration tool for Node.JS","keywords":["migrate","migration","migrations","sequelize"],"main":"lib/index.js","dependencies":{"babel-runtime":"^6.23.0","bluebird":"^3.4.1","lodash":"^4.17.0","resolve":"^1.0.0"},"devDependencies":{"babel-cli":"^6.24.1","babel-plugin-dynamic-import-node":"^1.0.1","babel-plugin-syntax-dynamic-import":"^6.18.0","babel-plugin-transform-object-rest-spread":"^6.23.0","babel-plugin-transform-runtime":"^6.23.0","babel-preset-env":"^1.4.0","babel-register":"^6.24.1","chai":"^3.5.0","coffee-script":"^1.8.0","gulp":"^3.8.10","gulp-jshint":"^2.0.3","gulp-jshint-instafail":"^1.0.0","gulp-mocha":"^4.3.0","jshint":"^2.9.1","jshint-stylish":"^2.0.0","mocha":"^3.3.0","sequelize":"^3.30.4","sinon":"^2.1.0","sqlite3":"^3.1.5","yargs":"^8.0.1"},"scripts":{"build":"babel src -d lib","test":"mocha --compilers js:babel-register test"},"repository":{"type":"git","url":"git+https://github.com/sequelize/umzug.git"},"author":{"name":"Sascha Depold","email":"sascha@depold.com"},"contributors":[{"name":"Jukka Hyytiälä","email":"hyytiala.jukka@gmail.com"}],"license":"MIT","bugs":{"url":"https://github.com/sequelize/umzug/issues"},"homepage":"https://github.com/sequelize/umzug","engines":{"node":">=4.0.0"},"gitHead":"2dcb56dddcd912c016a0186f0b213b4a875be90e","_id":"umzug@2.0.1","_shasum":"dbdc47f45923885622966814c03693c169da46e7","_from":".","_npmVersion":"3.10.10","_nodeVersion":"6.10.0","_npmUser":{"name":"jukkah","email":"hyytiala.jukka@gmail.com"},"dist":{"shasum":"dbdc47f45923885622966814c03693c169da46e7","tarball":"https://registry.npmjs.org/umzug/-/umzug-2.0.1.tgz","integrity":"sha512-EyHrUtYJJGgpoIwT50dE3XMAxbAcImgNt8ec0f3n80K2m+SUQPUx+lPneTt1614qfOkdTAHJoSD/42Hmt8pGGQ==","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEQCIA91YD+/luQFwSqny0UVJJqwp5v0KeSS6rmonn1azyvTAiATx51yqygtY4AU/r0nptvLaC2bdM3u3BTSildDf/ohpQ=="}]},"maintainers":[{"name":"jukkah","email":"hyytiala.jukka@gmail.com"},{"name":"sdepold","email":"sascha@depold.com"}],"_npmOperationalInternal":{"host":"packages-12-west.internal.npmjs.com","tmp":"tmp/umzug-2.0.1.tgz_1494430548990_0.7563476520590484"},"directories":{}},"2.1.0":{"name":"umzug","version":"2.1.0","description":"Framework agnostic migration tool for Node.JS","keywords":["migrate","migration","migrations","sequelize"],"main":"lib/index.js","dependencies":{"babel-runtime":"^6.23.0","bluebird":"^3.4.1","lodash":"^4.17.0","resolve":"^1.0.0"},"devDependencies":{"babel-cli":"^6.24.1","babel-plugin-dynamic-import-node":"^1.1.0","babel-plugin-syntax-dynamic-import":"^6.18.0","babel-plugin-transform-object-rest-spread":"^6.23.0","babel-plugin-transform-runtime":"^6.23.0","babel-preset-env":"^1.4.0","babel-register":"^6.24.1","chai":"^3.5.0","coffee-script":"^1.8.0","eslint-config-standard":"^10.2.1","eslint-plugin-import":"^2.7.0","eslint-plugin-mocha":"^4.11.0","eslint-plugin-node":"^5.2.0","eslint-plugin-promise":"^3.5.0","eslint-plugin-standard":"^3.0.1","gulp":"^3.8.10","gulp-babel":"^7.0.0","gulp-eslint":"^4.0.0","gulp-mocha":"^4.3.0","mocha":"^3.5.3","sequelize":"^3.30.4","sinon":"^2.1.0","sinon-chai":"^2.14.0","sqlite3":"^3.1.13","typescript":"^2.5.2","yargs":"^8.0.1"},"scripts":{"build":"gulp build","test":"gulp test"},"repository":{"type":"git","url":"git+https://github.com/sequelize/umzug.git"},"author":{"name":"Sascha Depold","email":"sascha@depold.com"},"contributors":[{"name":"Jukka Hyytiälä","email":"hyytiala.jukka@gmail.com"}],"license":"MIT","bugs":{"url":"https://github.com/sequelize/umzug/issues"},"homepage":"https://github.com/sequelize/umzug","engines":{"node":">=4.0.0"},"gitHead":"e1f88e2b95a387f550325272137f07e22a1a690b","_id":"umzug@2.1.0","_npmVersion":"5.4.1","_nodeVersion":"8.4.0","_npmUser":{"name":"pascal.pflaum","email":"mail@pascalpflaum.de"},"dist":{"integrity":"sha512-BgT+ekpItEWaG+3JjLLj6yVTxw2wIH8Cr6JyKYIzukWAx9nzGhC6BGHb/IRMjpobMM1qtIrReATwLUjKpU2iOQ==","shasum":"c49dd71c7c26d082a9c9d3592dc6dc92cf867761","tarball":"https://registry.npmjs.org/umzug/-/umzug-2.1.0.tgz","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEYCIQC/nPXTIEUeIestE0Exs0vw3co0skcJKzkAf4BlY7rH9QIhAPq+3JUnmJToLVjey1nkWBeYgQfmScUoTu1rbMi64n0Q"}]},"maintainers":[{"email":"mail@pascalpflaum.de","name":"pascal.pflaum"},{"email":"hyytiala.jukka@gmail.com","name":"jukkah"},{"email":"sascha@depold.com","name":"sdepold"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/umzug-2.1.0.tgz_1508955653994_0.29538550274446607"},"directories":{}},"2.2.0":{"name":"umzug","version":"2.2.0","description":"Framework agnostic migration tool for Node.JS","keywords":["migrate","migration","migrations","sequelize"],"main":"lib/index.js","dependencies":{"babel-runtime":"^6.23.0","bluebird":"^3.5.3"},"devDependencies":{"babel-cli":"^6.24.1","babel-plugin-dynamic-import-node":"^2.2.0","babel-plugin-syntax-dynamic-import":"^6.18.0","babel-plugin-transform-object-rest-spread":"^6.23.0","babel-plugin-transform-runtime":"^6.23.0","babel-preset-env":"^1.7.0","babel-register":"^6.24.1","chai":"^4.2.0","coffee-script":"^1.8.0","eslint":"^5.9.0","eslint-config-standard":"^12.0.0","eslint-plugin-import":"^2.14.0","eslint-plugin-mocha":"^5.2.0","eslint-plugin-node":"^8.0.0","eslint-plugin-promise":"^4.0.1","eslint-plugin-standard":"^4.0.0","lodash":"^4.17.11","mocha":"^5.2.0","sequelize":"^4.41.2","sinon":"^7.1.1","sinon-chai":"^3.2.0","sqlite3":"^4.0.4","typescript":"^3.1.6","uuid":"^3.3.2"},"scripts":{"build":"babel src --out-dir lib","lint":"eslint src test","test":"mocha -r babel-register --check-leaks test/index.js"},"repository":{"type":"git","url":"git+https://github.com/sequelize/umzug.git"},"author":{"name":"Sascha Depold","email":"sascha@depold.com"},"contributors":[{"name":"Jukka Hyytiälä","email":"hyytiala.jukka@gmail.com"},{"name":"Pascal Pflaum","email":"mail@pascalpflaum.de"}],"license":"MIT","bugs":{"url":"https://github.com/sequelize/umzug/issues"},"homepage":"https://github.com/sequelize/umzug","engines":{"node":">=6.0.0"},"gitHead":"4f016ea19ce13f36243dfaa81918946ab52d4395","_id":"umzug@2.2.0","_npmVersion":"5.6.0","_nodeVersion":"8.9.4","_npmUser":{"name":"pascal.pflaum","email":"mail@pascalpflaum.de"},"dist":{"integrity":"sha512-xZLW76ax70pND9bx3wqwb8zqkFGzZIK8dIHD9WdNy/CrNfjWcwQgQkGCuUqcuwEBvUm+g07z+qWvY+pxDmMEEw==","shasum":"6160bdc1817e4a63a625946775063c638623e62e","tarball":"https://registry.npmjs.org/umzug/-/umzug-2.2.0.tgz","fileCount":19,"unpackedSize":56995,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJb89QeCRA9TVsSAnZWagAAOhYP/jVxqD4tTF49ftmmYp7Z\nk7QTWf3lDz3rdsS6DvG2ITrsckeTSYqFGc7bSpm6SrFL/EF1WFXInu193o9g\nDy2eGFUCSFZP169yj0U+bu3Xbe0t1OL+ZgYOqf9D1BKa55BVOBiDubJhJHfp\nqpYjoBD6mgTRBXbI+2Uv4Bg9CpDUVYn464LYs+9YkmD31jiGoU4ZPZXOfz+f\n1trMx2STKHlkIiiN6Db5xmIMUiCvWKixikxIRFnPCBj8eEkEVBZOv9M9UsFt\nBjDh4ciWtG2DV51BMapOVFEb371Czgjvv7CdHjxfdxbWrqVEo9pV0AEEKZ0d\nIdlyZnB4KMmegMqQFVrp2QHQGX+o2MO6CCjQpptlDJBzMKQuBzMqrn4zOi0i\ncNd/zX6sJXvJahvW2fEkhJGdAStZ99FeWdr7X8yJRJijWHn6VSAENvnX3+OJ\nxCsHo/NTLCTG4f7AX20XkGb7oBUPbZnmvkRwuoVMyktRmFNzzfI2Gcquc4EC\nfXpvRdVinpdmSS2gkbFloFc5k75eIXdOmGU74Xci4hv7iX0ear2hop6G/NFH\nl5nQDT7LdbzBU021LHl7sduwRscv7GntENEhkcGZ1ft8uxW/DcIW69OtdunQ\nguHVwwUuoUoN4ezkUPvdFRwCGZwdU2MS9ilFXOtAJHLBQOhDMxXguaUnWvZ9\ngYwu\r\n=VRcN\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIQCh2LiDHA3X5uqm4p6pn0sInbbwm1JAf9KobQvSm+bK7wIgPzxW6MF9+YWqtafl4Ms7+WKbWVHEzO+nAbhG37pmh04="}]},"maintainers":[{"email":"hyytiala.jukka@gmail.com","name":"jukkah"},{"email":"mail@pascalpflaum.de","name":"pascal.pflaum"},{"email":"sascha@depold.com","name":"sdepold"}],"directories":{},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/umzug_2.2.0_1542706205558_0.3432125830893864"},"_hasShrinkwrap":false},"2.3.0":{"name":"umzug","version":"2.3.0","description":"Framework agnostic migration tool for Node.JS","keywords":["migrate","migration","migrations","sequelize"],"main":"lib/index.js","dependencies":{"bluebird":"^3.7.2"},"devDependencies":{"@babel/cli":"^7.8.4","@babel/core":"^7.9.0","@babel/plugin-proposal-object-rest-spread":"^7.9.0","@babel/plugin-transform-runtime":"^7.9.0","@babel/preset-env":"^7.9.0","@babel/register":"^7.9.0","babel-plugin-dynamic-import-node":"^2.3.0","babel-plugin-syntax-dynamic-import":"^6.18.0","chai":"^4.2.0","coffee-script":"^1.8.0","eslint":"^5.9.0","eslint-config-standard":"^12.0.0","eslint-plugin-import":"^2.20.1","eslint-plugin-mocha":"^6.3.0","eslint-plugin-node":"^8.0.0","eslint-plugin-promise":"^4.2.1","eslint-plugin-standard":"^4.0.1","lodash":"^4.17.15","mocha":"^6.2.2","sequelize":"^5.21.5","sinon":"^7.5.0","sinon-chai":"^3.5.0","sqlite3":"^4.1.1","typescript":"^3.8.3","uuid":"^7.0.2"},"scripts":{"lint":"eslint src test","prepare":"babel src --out-dir lib","test":"mocha -r @babel/register --check-leaks test/index.js"},"repository":{"type":"git","url":"git+https://github.com/sequelize/umzug.git"},"author":{"name":"Sascha Depold","email":"sascha@depold.com"},"contributors":[{"name":"Jukka Hyytiälä","email":"hyytiala.jukka@gmail.com"},{"name":"Pascal Pflaum","email":"mail@pascalpflaum.de"}],"license":"MIT","bugs":{"url":"https://github.com/sequelize/umzug/issues"},"homepage":"https://github.com/sequelize/umzug","engines":{"node":">=6.0.0"},"gitHead":"edb80d209f7121a5a73aa29a27feb23da1fc5534","_id":"umzug@2.3.0","_nodeVersion":"6.17.1","_npmVersion":"6.14.3","dist":{"integrity":"sha512-Z274K+e8goZK8QJxmbRPhl89HPO1K+ORFtm6rySPhFKfKc5GHhqdzD0SGhSWHkzoXasqJuItdhorSvY7/Cgflw==","shasum":"0ef42b62df54e216b05dcaf627830a6a8b84a184","tarball":"https://registry.npmjs.org/umzug/-/umzug-2.3.0.tgz","fileCount":18,"unpackedSize":58096,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJed2JoCRA9TVsSAnZWagAAWQUP/Rv+Y3otkSxy+MOiGWj7\nOQK1ZCElMF3biD8kW1GdWRT/9scDP+BNN0oR1Y1m69ITPCfoeb+oLyKz+vpd\ne//FgsE4N+qdDwtBTGMRfkV5nONJMyb/o98y07hYri3/1qyy8VxqcJp3dy8V\nG4u17WJ3dmBHtiOx/ON1hX6RFN7IdR8yVLITNpOkTYGNYjQu9ZX+6VaTLKVs\n0+ctku3strRLRGLMAgX/69CMp4bRhOIaxIiamfNilFF1xkUtbej2BwwaYb1E\nbPbfcHJzeiuzJc71mpuiTxzBvjx0iGxhPLKuyc00P4+1WrYGIyMhJFSF+UTo\n6rjCrdvgwujvluoWLi7qqg1bvuV3q6m73KBUDO7G+GbeZQSUTuKwctJuLX5w\nQBw2tVh/Hy/kB2rJr3yXx4rjSJUgO5aDyeVV8M2zTd109M/txfAN3J35Lwyx\nvXrxJJ21Jn1EpcIxTm3gjkTZ3EmkHdFRhxVmy64jMsvsxRTuBnDkSRJatcUT\nYXM5yIqk4aWSs+/UbCwN8wY3Mj12KnD+/mJ8ajoL/qB61pwg0hc6mellpQMw\n1k7ed72FSEQiP6lZLPebc3ktX0hhCgQ/qzZFEwsZrsI/pMd5TJsH06tRqwHj\nI9+iYuNxAspfeDDzhT/RqcxZ2Y9N/E+fM+boUhzldlTEoeS2wy4x/Rt4Cylf\n/5BM\r\n=QyWU\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCICCH2jPNhWGJI1HJCTaq5AMbVlYKtJWmeiWvp+ym+t6BAiEA4wow5qmmQDyMj1da31NKkXR4QKku0if74urg6Z5lg2A="}]},"maintainers":[{"email":"hyytiala.jukka@gmail.com","name":"jukkah"},{"email":"mail@pascalpflaum.de","name":"pascal.pflaum"},{"email":"sascha@depold.com","name":"sdepold"}],"_npmUser":{"name":"sushantdhiman","email":"sushantdhiman@outlook.com"},"directories":{},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/umzug_2.3.0_1584882280104_0.00826318172180951"},"_hasShrinkwrap":false},"3.0.0-beta.0":{"name":"umzug","version":"3.0.0-beta.0","description":"Framework-agnostic migration tool for Node","keywords":["migrate","migration","migrations","sequelize"],"main":"src/index.js","dependencies":{"bluebird":"^3.7.2"},"devDependencies":{"chai":"^4.2.0","eslint":"^5.9.0","eslint-config-standard":"^12.0.0","eslint-plugin-import":"^2.20.1","eslint-plugin-mocha":"^6.3.0","eslint-plugin-node":"^8.0.0","eslint-plugin-promise":"^4.2.1","eslint-plugin-standard":"^4.0.1","lodash":"^4.17.15","mocha":"^6.2.2","np":"https://github.com/pixelastic/np/tarball/c3ab2e3b053c7da0ce40a572ca1616273ac080f8","sequelize":"^5.21.5","sinon":"^7.5.0","sinon-chai":"^3.5.0","sqlite3":"^4.1.1","uuid":"^7.0.2"},"scripts":{"lint":"eslint src test","mocha":"mocha --check-leaks test/index.js","test":"npm run lint && npm run mocha","release":"np --no-2fa"},"repository":{"type":"git","url":"git+https://github.com/sequelize/umzug.git"},"author":{"name":"Sascha Depold","email":"sascha@depold.com"},"contributors":[{"name":"Jukka Hyytiälä","email":"hyytiala.jukka@gmail.com"},{"name":"Pascal Pflaum","email":"mail@pascalpflaum.de"},{"name":"Pedro Augusto de Paula Barbosa","email":"papb1996@gmail.com"}],"license":"MIT","bugs":{"url":"https://github.com/sequelize/umzug/issues"},"homepage":"https://github.com/sequelize/umzug","engines":{"node":">=10.0.0"},"readme":"# Umzug [![Build Status](https://travis-ci.org/sequelize/umzug.svg?branch=master)](https://travis-ci.org/sequelize/umzug) [![npm version](https://badgen.net/npm/v/umzug)](https://www.npmjs.com/package/umzug)\n\n[!! We are looking for maintainers !!](https://github.com/sequelize/umzug/issues/204)\n\nUmzug is a framework-agnostic migration tool for Node. It provides a clean API for running and rolling back tasks.\n\n* Programmatic API for migrations\n* Database agnostic\n* Supports logging of migration process\n* Supports multiple storages for migration data\n\n## Documentation\n\n### Minimal Example\n\nThe following example uses a Sqlite database through sequelize and persists the migration data in the database itself through the sequelize storage.\n\n* **`index.js`**:\n\n```javascript\nconst Sequelize = require('sequelize');\nconst path = require('path');\nconst Umzug = require('umzug');\n\n// creates a basic sqlite database\nconst sequelize = new Sequelize({\n  dialect: 'sqlite',\n  storage: './db.sqlite'\n});\n\nconst umzug = new Umzug({\n  migrations: {\n    // indicates the folder containing the migration .js files\n    path: path.join(__dirname, './migrations'),\n    // inject sequelize's QueryInterface in the migrations\n    params: [\n      sequelize.getQueryInterface()\n    ]\n  },\n  // indicates that the migration data should be store in the database\n  // itself through sequelize. The default configuration creates a table\n  // named `SequelizeMeta`.\n  storage: 'sequelize',\n  storageOptions: { sequelize }\n});\n\n(async () => {\n  // checks migrations and run them if they are not already applied\n  await umzug.up();\n  console.log('All migrations performed successfully');\n})();\n```\n\n* **`migrations/00_initial.js`**:\n\n```javascript\nconst Sequelize = require('sequelize');\n\n// All migrations must provide a `up` and `down` async functions\nmodule.exports = {\n  // `query` was passed in the `index.js` file\n  async up(query) {\n    await query.createTable('users', {\n      id: {\n        type: Sequelize.INTEGER,\n        allowNull: false,\n        primaryKey: true\n      },\n      name: {\n        type: Sequelize.STRING,\n        allowNull: false\n      },\n      createdAt: {\n        type: Sequelize.DATE,\n        allowNull: false\n      },\n      updatedAt: {\n        type: Sequelize.DATE,\n        allowNull: false\n      }\n    });\n  },\n  async down(query) {\n    await query.dropTable('users');\n  }\n};\n```\n\n### Usage\n\n#### Installation\n\nUmzug is available on npm:\n\n```bash\nnpm install umzug\n```\n\n#### Umzug instance\n\nIt is possible to configure an Umzug instance by passing an object to the constructor. The possible options are:\n\n```js\nconst Umzug = require('umzug');\n\nconst umzug = new Umzug({\n  // The storage.\n  // Possible values: 'none', 'json', 'mongodb', 'sequelize', an argument for `require()`, including absolute paths\n  storage: 'json',\n\n  // The options for the storage.\n  // Check the available storages for further details.\n  storageOptions: {},\n\n  // The logging function.\n  // A function that gets executed everytime migrations start and have ended.\n  logging: false,\n\n  // The name of the positive method in migrations.\n  upName: 'up',\n\n  // The name of the negative method in migrations.\n  downName: 'down',\n\n  // (advanced) you can pass an array of migrations built with `migrationsList()` instead of the options below\n  migrations: {\n    // The params that gets passed to the migrations.\n    // Might be an array or a synchronous function which returns an array.\n    params: [],\n\n    // The path to the migrations directory.\n    path: 'migrations',\n\n    // The pattern that determines whether or not a file is a migration.\n    pattern: /^\\d+[\\w-]+\\.js$/,\n\n    // A function that receives and returns the to be executed function.\n    // This can be used to modify the function.\n    wrap(migrationFunction) { return migrationFunction; },\n\n    // A function that maps a file path to a migration object in the form\n    // { up: Function, down: Function }. The default for this is to require(...)\n    // the file as javascript, but you can use this to transpile TypeScript,\n    // read raw sql etc.\n    customResolver(sqlPath) {\n      return {\n        async up() {\n          await sequelize.query(fs.readFileSync(sqlPath, 'utf8'));\n        };\n      }\n    }\n\n    // A function that receives the file path of the migration and returns the name of the \n    // migration. This can be used to remove file extensions for example.\n    nameFormatter(filePath) {\n      return path.parse(filePath).name;\n    }\n  }\n})\n```\n\n#### Executing migrations\n\nThe `execute` method is a general purpose function that runs for every specified migrations the respective function.\n\n```js\nconst migrations = await umzug.execute({\n  migrations: ['some-id', 'some-other-id'],\n  method: 'up'\n});\n// returns an array of all executed/reverted migrations.\n```\n\n#### Getting all pending migrations\n\nYou can get a list of pending/not yet executed migrations like this:\n\n```js\nconst migrations = await umzug.pending();\n// returns an array of all pending migrations.\n```\n\n#### Getting all executed migrations\n\nYou can get a list of already executed migrations like this:\n\n```js\nconst migrations = await umzug.executed();\n// returns an array of all already executed migrations\n```\n\n#### Executing pending migrations\n\nThe `up` method can be used to execute all pending migrations.\n\n```js\nconst migrations = await umzug.up();\n// returns an array of all executed migrations\n```\n\nIt is also possible to pass the name of a migration in order to just run the migrations from the current state to the passed migration name (inclusive).\n\n```js\nawait umzug.up({ to: '20141101203500-task' });\n```\n\nYou also have the ability to choose to run migrations *from* a specific migration, excluding it:\n\n```js\nawait umzug.up({ from: '20141101203500-task' });\n```\n\nIn the above example umzug will execute all the pending migrations found **after** the specified migration. This is particularly useful if you are using migrations on your native desktop application and you don't need to run past migrations on new installs while they need to run on updated installations.\n\nYou can combine `from` and `to` options to select a specific subset:\n\n```js\nawait umzug.up({ from: '20141101203500-task', to: '20151201103412-items' });\n```\n\nRunning specific migrations while ignoring the right order, can be done like this:\n\n```js\nawait umzug.up({ migrations: ['20141101203500-task', '20141101203501-task-2'] });\n```\n\nThere are also shorthand version of that:\n\n```js\nawait umzug.up('20141101203500-task'); // Runs just the passed migration\nawait umzug.up(['20141101203500-task', '20141101203501-task-2']);\n```\n\n#### Reverting executed migration\n\nThe `down` method can be used to revert the last executed migration.\n\n```js\nconst migration = await umzug.down();\n// returns the reverted migration.\n```\n\nIt is possible to pass the name of a migration until which (inclusive) the migrations should be reverted. This allows the reverting of multiple migrations at once.\n\n```js\nconst migrations = await umzug.down({ to: '20141031080000-task' });\n// returns an array of all reverted migrations.\n```\n\nTo revert all migrations, you can pass 0 as the `to` parameter:\n\n```js\nawait umzug.down({ to: 0 });\n```\n\nReverting specific migrations while ignoring the right order, can be done like this:\n\n```js\nawait umzug.down({ migrations: ['20141101203500-task', '20141101203501-task-2'] });\n```\n\nThere are also shorthand versions of that:\n\n```js\nawait umzug.down('20141101203500-task'); // Runs just the passed migration\nawait umzug.down(['20141101203500-task', '20141101203501-task-2']);\n```\n\n### Migrations\n\nThere are two ways to specify migrations: via files or directly via an array of migrations.\n\n#### Migration files\n\nA migration file ideally exposes an `up` and a `down` async functions. They will perform the task of upgrading or downgrading the database.\n\n```js\n\nmodule.exports = {\n  up: async () => {\n    ...\n  },\n  down: async () => {\n    ...\n  },\n};\n```\n\nMigration files should be located in the same directory, according to the info you gave to the `Umzug` constructor.\n\n#### Direct migrations list\n\nYou can also specify directly a list of migrations to the `Umzug` constructor. We recommend the usage of the `Umzug.migrationsList()` function\nas bellow:\n\n```js\nconst umzug = new Umzug({\n  migrations: Umzug.migrationsList(\n    [\n      {\n        // the name of the migration is mandatory\n        name: '00-first-migration',\n        async up(queryInterface) { /* ... */ },\n        async down(queryInterface) { /* ... */ }\n      },\n      {\n        name: '01-foo-bar-migration',\n        async up(queryInterface) { /* ... */ },\n        async down(queryInterface) { /* ... */ }\n      }\n    ],\n    // an optional list of parameters that will be sent to the `up` and `down` functions\n    [\n      sequelize.getQueryInterface()\n    ]\n  )\n});\n```\n\n### Storages\n\nStorages define where the migration data is stored.\n\n#### JSON Storage\n\nUsing the `json` storage will create a JSON file which will contain an array with all the executed migrations. You can specify the path to the file. The default for that is `umzug.json` in the working directory of the process.\n\nOptions:\n\n```js\n{\n  // The path to the json storage.\n  // Defaults to process.cwd() + '/umzug.json';\n  path: process.cwd() + '/db/sequelize-meta.json'\n}\n```\n\n#### Sequelize Storage\n\nUsing the `sequelize` storage will create a table in your SQL database called `SequelizeMeta` containing an entry for each executed migration. You will have to pass a configured instance of Sequelize or an existing Sequelize model. Optionally you can specify the model name, table name, or column name. All major Sequelize versions are supported.\n\nOptions:\n\n```js\n{\n  // The configured instance of Sequelize.\n  // Optional if `model` is passed.\n  sequelize: instance,\n\n  // The to be used Sequelize model.\n  // Must have column name matching `columnName` option\n  // Optional if `sequelize` is passed.\n  model: model,\n\n  // The name of the to be used model.\n  // Defaults to 'SequelizeMeta'\n  modelName: 'Schema',\n\n  // The name of table to create if `model` option is not supplied\n  // Defaults to `modelName`\n  tableName: 'Schema',\n\n  // The name of table column holding migration name.\n  // Defaults to 'name'.\n  columnName: 'migration',\n\n  // The type of the column holding migration name.\n  // Defaults to `Sequelize.STRING`\n  columnType: new Sequelize.STRING(100)\n}\n```\n\n#### MongoDB Storage\n\nUsing the `mongodb` storage will create a collection in your MongoDB database called `migrations` containing an entry for each executed migration. You will have either to pass a MongoDB Driver Collection as `collection` property. Alternatively you can pass a established MongoDB Driver connection and a collection name.\n\nOptions:\n\n```js\n{\n  // a connection to target database established with MongoDB Driver\n  connection: MongoDBDriverConnection,\n\n  // name of migration collection in MongoDB\n  collectionName: 'migrations',\n\n  // reference to a MongoDB Driver collection\n  collection: MongoDBDriverCollection\n}\n```\n\n#### Custom\n\nIn order to use custom storage, you have two options:\n\n##### Method 1: Pass instance to constructor\n\nYou can pass your storage instance to Umzug constructor.\n\n```js\nclass CustomStorage {\n  constructor(...) {...}\n  logMigration(...) {...}\n  unlogMigration(...) {...}\n  executed(...) {...}\n}\nlet umzug = new Umzug({ storage: new CustomStorage(...) })\n```\n\n##### Method 2: Require external module from npmjs.com\n\nCreate and publish a module which has to fulfill the following API. You can just pass the name of the module to the configuration and *umzug* will require it accordingly. The API that needs to be exposed looks like this:\n\n```js\nmodule.exports = class MyStorage {\n  constructor({ option1: 'defaultValue1' } = {}) {\n    this.option1 = option1;\n  },\n\n  async logMigration(migrationName) {\n    // This function logs a migration as executed.\n    // It will get called once a migration was\n    // executed successfully.\n  },\n\n  async unlogMigration(migrationName) {\n    // This function removes a previously logged migration.\n    // It will get called once a migration has been reverted.\n  },\n\n  async executed() {\n    // This function lists the names of the logged\n    // migrations. It will be used to calculate\n    // pending migrations. The result has to be an\n    // array with the names of the migration files.\n  }\n}\n```\n\n### Events\n\nUmzug is an EventEmitter. Each of the following events will be called with `name, migration` as arguments. Events are a convenient place to implement application-specific logic that must run around each migration:\n\n* *migrating* - A migration is about to be executed.\n* *migrated* - A migration has successfully been executed.\n* *reverting* - A migration is about to be reverted.\n* *reverted* - A migration has successfully been reverted.\n\n## Examples\n\n* [sequelize-migration-hello](https://github.com/abelnation/sequelize-migration-hello)\n\n## License\n\nSee the [LICENSE file](./LICENSE)\n","readmeFilename":"README.md","gitHead":"45d44d73300458de3656deac4a9a8f56fadab698","_id":"umzug@3.0.0-beta.0","_nodeVersion":"12.14.1","_npmVersion":"6.13.6","dist":{"integrity":"sha512-4gTtrczVleXVxJqddc8usIHFrZi5KVqDL6wRnorTcX2X9kAZQ8yUo+qmFCxV2UUXvcHIrdnOappGU78Saiflhw==","shasum":"655caa7fe1bf460d3a6fdf5f5981542eb0ce0d3a","tarball":"https://registry.npmjs.org/umzug/-/umzug-3.0.0-beta.0.tgz","fileCount":15,"unpackedSize":54152,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJegN2OCRA9TVsSAnZWagAA8w0P/jJ4xfhOzOnE0M/wljDe\nSwxHpGP6jZniHvIT6UyoCqwROnxcy4YEBTbEeL5pmuyiuEpCs6VYl0zhG9Ft\n7Y1IrQZugocQwed5BG4QVwX16gdvpp+EICYPJ80kQSb8wlMmrs9m4Sx3nZuO\nDhcHTJTdV242PSxlGfaWWA/514DqryEH8Nne1uGK9tagussNrk6osYvnO+K+\nTwiEtm3P5zJVMsugn2s70uYk6RVQeEdkQ1XKya8MzJboipA7EXrMFAZP5sfc\nY33FTiGxSdA7S65FHiTJa/SzATLs/j7GhjBtE84unBq8gLm6RuK8FSLP2yX+\nhU+f4JXXyi4Kpc3HPs7R23v24UFzId8mo7WZSANos9++nrSExzXwsnskMi/i\nnVBrP7QjapnWJFj/EBMszXRCmxOcWswLhCLzH/hXnPhAZL3rHqVSE+2Eybxi\nOVv0mkwe/4+YZxyoyZodn8GTArVzJ5HPloHs45j9/qeudNd+EqC1m8RzpCwU\njuTho5WPTlRWFfb/Akr/8ryhGp9iLQgR4sVcOnnkFiaOsfEx8cw8DpJen9E4\nh5+2Gfzs3tVtT0QP/1n2PO9GuuVYWqFjsHhUVrsFR2vDz0Lcetm4hjnI9mBa\nui1yUN5eLw3h6L2hJnbCwwqm0519WF7zrxyCjNEJMTAPfuFYAqajj7CPXZ7D\n6T8U\r\n=QocH\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEQCICi8QZAw7scT36CWzJm6KD903Fvguekcz5v6m/j1T9bhAiA2vsmz7qc759ymI6t6C6JVu3XVSGoFZyPRHeezfdIqAA=="}]},"maintainers":[{"email":"hyytiala.jukka@gmail.com","name":"jukkah"},{"email":"mail@pascalpflaum.de","name":"pascal.pflaum"},{"email":"sascha@depold.com","name":"sdepold"}],"_npmUser":{"name":"papb","email":"papb1996@gmail.com"},"directories":{},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/umzug_3.0.0-beta.0_1585503630337_0.18748657994812667"},"_hasShrinkwrap":false},"3.0.0-beta.1":{"name":"umzug","version":"3.0.0-beta.1","description":"Framework-agnostic migration tool for Node","keywords":["migrate","migration","migrations","sequelize"],"main":"src/index.js","dependencies":{"bluebird":"^3.7.2"},"devDependencies":{"chai":"^4.2.0","eslint":"^5.9.0","eslint-config-standard":"^12.0.0","eslint-plugin-import":"^2.20.1","eslint-plugin-mocha":"^6.3.0","eslint-plugin-node":"^8.0.0","eslint-plugin-promise":"^4.2.1","eslint-plugin-standard":"^4.0.1","lodash":"^4.17.15","mocha":"^6.2.2","np":"https://github.com/pixelastic/np/tarball/c3ab2e3b053c7da0ce40a572ca1616273ac080f8","sequelize":"^5.21.5","sinon":"^7.5.0","sinon-chai":"^3.5.0","sqlite3":"^4.1.1","uuid":"^7.0.2"},"scripts":{"lint":"eslint src test","mocha":"mocha --check-leaks test/index.js --timeout 10000","test":"npm run lint && npm run mocha","release":"np --no-2fa"},"repository":{"type":"git","url":"git+https://github.com/sequelize/umzug.git"},"author":{"name":"Sascha Depold","email":"sascha@depold.com"},"contributors":[{"name":"Jukka Hyytiälä","email":"hyytiala.jukka@gmail.com"},{"name":"Pascal Pflaum","email":"mail@pascalpflaum.de"},{"name":"Pedro Augusto de Paula Barbosa","email":"papb1996@gmail.com"}],"license":"MIT","bugs":{"url":"https://github.com/sequelize/umzug/issues"},"homepage":"https://github.com/sequelize/umzug","engines":{"node":">=10.0.0"},"readme":"# Umzug [![Build Status](https://travis-ci.org/sequelize/umzug.svg?branch=master)](https://travis-ci.org/sequelize/umzug) [![npm version](https://badgen.net/npm/v/umzug)](https://www.npmjs.com/package/umzug)\n\n[!! We are looking for maintainers !!](https://github.com/sequelize/umzug/issues/204)\n\nUmzug is a framework-agnostic migration tool for Node. It provides a clean API for running and rolling back tasks.\n\n* Programmatic API for migrations\n* Database agnostic\n* Supports logging of migration process\n* Supports multiple storages for migration data\n\n## Documentation\n\n### Minimal Example\n\nThe following example uses a Sqlite database through sequelize and persists the migration data in the database itself through the sequelize storage.\n\n* **`index.js`**:\n\n```javascript\nconst Sequelize = require('sequelize');\nconst path = require('path');\nconst Umzug = require('umzug');\n\n// creates a basic sqlite database\nconst sequelize = new Sequelize({\n  dialect: 'sqlite',\n  storage: './db.sqlite'\n});\n\nconst umzug = new Umzug({\n  migrations: {\n    // indicates the folder containing the migration .js files\n    path: path.join(__dirname, './migrations'),\n    // inject sequelize's QueryInterface in the migrations\n    params: [\n      sequelize.getQueryInterface()\n    ]\n  },\n  // indicates that the migration data should be store in the database\n  // itself through sequelize. The default configuration creates a table\n  // named `SequelizeMeta`.\n  storage: 'sequelize',\n  storageOptions: { sequelize }\n});\n\n(async () => {\n  // checks migrations and run them if they are not already applied\n  await umzug.up();\n  console.log('All migrations performed successfully');\n})();\n```\n\n* **`migrations/00_initial.js`**:\n\n```javascript\nconst Sequelize = require('sequelize');\n\n// All migrations must provide a `up` and `down` async functions\nmodule.exports = {\n  // `query` was passed in the `index.js` file\n  async up(query) {\n    await query.createTable('users', {\n      id: {\n        type: Sequelize.INTEGER,\n        allowNull: false,\n        primaryKey: true\n      },\n      name: {\n        type: Sequelize.STRING,\n        allowNull: false\n      },\n      createdAt: {\n        type: Sequelize.DATE,\n        allowNull: false\n      },\n      updatedAt: {\n        type: Sequelize.DATE,\n        allowNull: false\n      }\n    });\n  },\n  async down(query) {\n    await query.dropTable('users');\n  }\n};\n```\n\n### Usage\n\n#### Installation\n\nUmzug is available on npm:\n\n```bash\nnpm install umzug\n```\n\n#### Umzug instance\n\nIt is possible to configure an Umzug instance by passing an object to the constructor. The possible options are:\n\n```js\nconst Umzug = require('umzug');\n\nconst umzug = new Umzug({\n  // The storage.\n  // Possible values: 'none', 'json', 'mongodb', 'sequelize', an argument for `require()`, including absolute paths\n  storage: 'json',\n\n  // The options for the storage.\n  // Check the available storages for further details.\n  storageOptions: {},\n\n  // The logging function.\n  // A function that gets executed everytime migrations start and have ended.\n  logging: false,\n\n  // (advanced) you can pass an array of migrations built with `migrationsList()` instead of the options below\n  migrations: {\n    // The params that gets passed to the migrations.\n    // Might be an array or a synchronous function which returns an array.\n    params: [],\n\n    // The path to the migrations directory.\n    path: 'migrations',\n\n    // The pattern that determines whether or not a file is a migration.\n    pattern: /^\\d+[\\w-]+\\.js$/,\n\n    // A function that receives and returns the to be executed function.\n    // This can be used to modify the function.\n    wrap(migrationFunction) { return migrationFunction; },\n\n    // A function that maps a file path to a migration object in the form\n    // { up: Function, down: Function }. The default for this is to require(...)\n    // the file as javascript, but you can use this to transpile TypeScript,\n    // read raw sql etc.\n    customResolver(sqlPath) {\n      return {\n        async up() {\n          await sequelize.query(fs.readFileSync(sqlPath, 'utf8'));\n        };\n      }\n    }\n\n    // A function that receives the file path of the migration and returns the name of the \n    // migration. This can be used to remove file extensions for example.\n    nameFormatter(filePath) {\n      return path.parse(filePath).name;\n    }\n  }\n})\n```\n\n#### Executing migrations\n\nThe `execute` method is a general purpose function that runs for every specified migrations the respective function.\n\n```js\nconst migrations = await umzug.execute({\n  migrations: ['some-id', 'some-other-id'],\n  method: 'up'\n});\n// returns an array of all executed/reverted migrations.\n```\n\n#### Getting all pending migrations\n\nYou can get a list of pending/not yet executed migrations like this:\n\n```js\nconst migrations = await umzug.pending();\n// returns an array of all pending migrations.\n```\n\n#### Getting all executed migrations\n\nYou can get a list of already executed migrations like this:\n\n```js\nconst migrations = await umzug.executed();\n// returns an array of all already executed migrations\n```\n\n#### Executing pending migrations\n\nThe `up` method can be used to execute all pending migrations.\n\n```js\nconst migrations = await umzug.up();\n// returns an array of all executed migrations\n```\n\nIt is also possible to pass the name of a migration in order to just run the migrations from the current state to the passed migration name (inclusive).\n\n```js\nawait umzug.up({ to: '20141101203500-task' });\n```\n\nYou also have the ability to choose to run migrations *from* a specific migration, excluding it:\n\n```js\nawait umzug.up({ from: '20141101203500-task' });\n```\n\nIn the above example umzug will execute all the pending migrations found **after** the specified migration. This is particularly useful if you are using migrations on your native desktop application and you don't need to run past migrations on new installs while they need to run on updated installations.\n\nYou can combine `from` and `to` options to select a specific subset:\n\n```js\nawait umzug.up({ from: '20141101203500-task', to: '20151201103412-items' });\n```\n\nRunning specific migrations while ignoring the right order, can be done like this:\n\n```js\nawait umzug.up({ migrations: ['20141101203500-task', '20141101203501-task-2'] });\n```\n\nThere are also shorthand version of that:\n\n```js\nawait umzug.up('20141101203500-task'); // Runs just the passed migration\nawait umzug.up(['20141101203500-task', '20141101203501-task-2']);\n```\n\n#### Reverting executed migration\n\nThe `down` method can be used to revert the last executed migration.\n\n```js\nconst migration = await umzug.down();\n// returns the reverted migration.\n```\n\nIt is possible to pass the name of a migration until which (inclusive) the migrations should be reverted. This allows the reverting of multiple migrations at once.\n\n```js\nconst migrations = await umzug.down({ to: '20141031080000-task' });\n// returns an array of all reverted migrations.\n```\n\nTo revert all migrations, you can pass 0 as the `to` parameter:\n\n```js\nawait umzug.down({ to: 0 });\n```\n\nReverting specific migrations while ignoring the right order, can be done like this:\n\n```js\nawait umzug.down({ migrations: ['20141101203500-task', '20141101203501-task-2'] });\n```\n\nThere are also shorthand versions of that:\n\n```js\nawait umzug.down('20141101203500-task'); // Runs just the passed migration\nawait umzug.down(['20141101203500-task', '20141101203501-task-2']);\n```\n\n### Migrations\n\nThere are two ways to specify migrations: via files or directly via an array of migrations.\n\n#### Migration files\n\nA migration file ideally exposes an `up` and a `down` async functions. They will perform the task of upgrading or downgrading the database.\n\n```js\n\nmodule.exports = {\n  up: async () => {\n    ...\n  },\n  down: async () => {\n    ...\n  },\n};\n```\n\nMigration files should be located in the same directory, according to the info you gave to the `Umzug` constructor.\n\n#### Direct migrations list\n\nYou can also specify directly a list of migrations to the `Umzug` constructor. We recommend the usage of the `Umzug.migrationsList()` function\nas bellow:\n\n```js\nconst umzug = new Umzug({\n  migrations: Umzug.migrationsList(\n    [\n      {\n        // the name of the migration is mandatory\n        name: '00-first-migration',\n        async up(queryInterface) { /* ... */ },\n        async down(queryInterface) { /* ... */ }\n      },\n      {\n        name: '01-foo-bar-migration',\n        async up(queryInterface) { /* ... */ },\n        async down(queryInterface) { /* ... */ }\n      }\n    ],\n    // an optional list of parameters that will be sent to the `up` and `down` functions\n    [\n      sequelize.getQueryInterface()\n    ]\n  )\n});\n```\n\n### Storages\n\nStorages define where the migration data is stored.\n\n#### JSON Storage\n\nUsing the `json` storage will create a JSON file which will contain an array with all the executed migrations. You can specify the path to the file. The default for that is `umzug.json` in the working directory of the process.\n\nOptions:\n\n```js\n{\n  // The path to the json storage.\n  // Defaults to process.cwd() + '/umzug.json';\n  path: process.cwd() + '/db/sequelize-meta.json'\n}\n```\n\n#### Sequelize Storage\n\nUsing the `sequelize` storage will create a table in your SQL database called `SequelizeMeta` containing an entry for each executed migration. You will have to pass a configured instance of Sequelize or an existing Sequelize model. Optionally you can specify the model name, table name, or column name. All major Sequelize versions are supported.\n\nOptions:\n\n```js\n{\n  // The configured instance of Sequelize.\n  // Optional if `model` is passed.\n  sequelize: instance,\n\n  // The to be used Sequelize model.\n  // Must have column name matching `columnName` option\n  // Optional if `sequelize` is passed.\n  model: model,\n\n  // The name of the to be used model.\n  // Defaults to 'SequelizeMeta'\n  modelName: 'Schema',\n\n  // The name of table to create if `model` option is not supplied\n  // Defaults to `modelName`\n  tableName: 'Schema',\n\n  // The name of table column holding migration name.\n  // Defaults to 'name'.\n  columnName: 'migration',\n\n  // The type of the column holding migration name.\n  // Defaults to `Sequelize.STRING`\n  columnType: new Sequelize.STRING(100)\n}\n```\n\n#### MongoDB Storage\n\nUsing the `mongodb` storage will create a collection in your MongoDB database called `migrations` containing an entry for each executed migration. You will have either to pass a MongoDB Driver Collection as `collection` property. Alternatively you can pass a established MongoDB Driver connection and a collection name.\n\nOptions:\n\n```js\n{\n  // a connection to target database established with MongoDB Driver\n  connection: MongoDBDriverConnection,\n\n  // name of migration collection in MongoDB\n  collectionName: 'migrations',\n\n  // reference to a MongoDB Driver collection\n  collection: MongoDBDriverCollection\n}\n```\n\n#### Custom\n\nIn order to use custom storage, you have two options:\n\n##### Method 1: Pass instance to constructor\n\nYou can pass your storage instance to Umzug constructor.\n\n```js\nclass CustomStorage {\n  constructor(...) {...}\n  logMigration(...) {...}\n  unlogMigration(...) {...}\n  executed(...) {...}\n}\nlet umzug = new Umzug({ storage: new CustomStorage(...) })\n```\n\n##### Method 2: Require external module from npmjs.com\n\nCreate and publish a module which has to fulfill the following API. You can just pass the name of the module to the configuration and *umzug* will require it accordingly. The API that needs to be exposed looks like this:\n\n```js\nmodule.exports = class MyStorage {\n  constructor({ option1: 'defaultValue1' } = {}) {\n    this.option1 = option1;\n  },\n\n  async logMigration(migrationName) {\n    // This function logs a migration as executed.\n    // It will get called once a migration was\n    // executed successfully.\n  },\n\n  async unlogMigration(migrationName) {\n    // This function removes a previously logged migration.\n    // It will get called once a migration has been reverted.\n  },\n\n  async executed() {\n    // This function lists the names of the logged\n    // migrations. It will be used to calculate\n    // pending migrations. The result has to be an\n    // array with the names of the migration files.\n  }\n}\n```\n\n### Events\n\nUmzug is an EventEmitter. Each of the following events will be called with `name, migration` as arguments. Events are a convenient place to implement application-specific logic that must run around each migration:\n\n* *migrating* - A migration is about to be executed.\n* *migrated* - A migration has successfully been executed.\n* *reverting* - A migration is about to be reverted.\n* *reverted* - A migration has successfully been reverted.\n\n## Examples\n\n* [sequelize-migration-hello](https://github.com/abelnation/sequelize-migration-hello)\n\n## License\n\nSee the [LICENSE file](./LICENSE)\n","readmeFilename":"README.md","gitHead":"2b668efd0c6d51ef50efaf87cbe3c34dd83aeddc","_id":"umzug@3.0.0-beta.1","_nodeVersion":"12.14.1","_npmVersion":"6.13.6","dist":{"integrity":"sha512-YM6GjZks20EoJwllOO0321h/HPRJAjcW0txRyC5VzBIvMKUP6Zcc5+tZdvmOQPrTwcolHN/Gom3v1XC2UvOaRg==","shasum":"b2e7880d33e0d0bd98a1d0daeb04509f60d7e997","tarball":"https://registry.npmjs.org/umzug/-/umzug-3.0.0-beta.1.tgz","fileCount":12,"unpackedSize":52737,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJegQ7GCRA9TVsSAnZWagAAd18P/1JBQR1NUVUzJ8sY2Mi0\n6gOWtt2QHPhhT4bhTcXhFFHD2h1j4BheA7iODzgUHl9CL0IA95As4aMsAoGb\nVx60aGp/KIzaQ8xzgHjOAq58RvInpemoTQG1PPhJHr7IixrwmLXf6CIR4R0m\nIN9MDA8pAije0WF0ZoxeykfBtdbOQG+CO9eLcJOd0bwkbny7Df/eWHQ2p912\n7IAB/9bkZog0Ez5uXqBVefmErki9zytURcqZNQNrf+ykscALWM1QikgbmX3L\neS3Oom9wDIaTiJd88Am2aYR8mopVzGbePm/+/RnVDhqpEEaBFkiL9YGVWbJC\nh9jC6DuUMYOU7hp1xCF02aV1ZbwWWbcZWp5yRm0tezVT6Xs+waVaYpZa6N00\nGjXpKc5TJJS5hXJAoLGYp/YtGFepdEHPeuuYDlakbe8vOd2+psQWX7hDWQ5w\npE13L9s3ufuGur4Y0QQ1iJj9+b9vg16YVwluoNAM9mTqpCJilBchGx0lgtIt\nOM6XhEBCrtKGlZ/UQAiz8oPGRpRKswEUhJ9OV+tHHr9Hr8m5Mchmu5PqPooy\nEoXisbHWgaSf4dJPFygWdGx+9Niod+8Y7ZWPmXRlKlU2g2fIVFaHuuLnRqXD\nRI7yJ+VH7GIsCEe3vZNG3DmXA/OXxUxpsuOY4Kv5c57mcH3u/XACAee3AAOg\nCIqQ\r\n=hsJV\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIAjXPInyPw9k/ZA1zMYP+F/SjjwFInmoCClFdBpB5auYAiEA2W0ksfoFiQXt7WOxV8cg0jS09gpPS4/kicvwDpi+IhY="}]},"maintainers":[{"email":"hyytiala.jukka@gmail.com","name":"jukkah"},{"email":"mail@pascalpflaum.de","name":"pascal.pflaum"},{"email":"sascha@depold.com","name":"sdepold"}],"_npmUser":{"name":"papb","email":"papb1996@gmail.com"},"directories":{},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/umzug_3.0.0-beta.1_1585516229454_0.18967540707543318"},"_hasShrinkwrap":false},"3.0.0-beta.2":{"name":"umzug","version":"3.0.0-beta.2","description":"Framework-agnostic migration tool for Node","keywords":["migrate","migration","migrations","sequelize"],"main":"lib/index.js","dependencies":{"fs-jetpack":"^2.2.3","p-each-series":"^2.1.0","p-map":"^4.0.0","tory":"~0.4.3"},"devDependencies":{"@ava/typescript":"^1.1.1","ava":"^3.5.0","chai":"^4.2.0","del-cli":"^3.0.0","eslint-config-xo-typescript":"~0.27.0","lodash":"^4.17.15","mocha":"^6.2.2","np":"https://github.com/pixelastic/np/tarball/c3ab2e3b053c7da0ce40a572ca1616273ac080f8","sequelize":"^5.21.5","sinon":"^7.5.0","sinon-chai":"^3.5.0","source-map-support":"^0.5.16","sqlite3":"^4.1.1","type-fest":"^0.13.0","typescript":"~3.8.3","uuid":"^7.0.2","xo":"^0.28.3"},"scripts":{"build":"del-cli lib && tsc","mocha":"node legacy-tests/clear-tmp.js && mocha --check-leaks legacy-tests/index.js","prepack":"npm run build","release":"np --no-2fa","test":"npm run build && xo && ava test/test.ts && npm run mocha"},"repository":{"type":"git","url":"git+https://github.com/sequelize/umzug.git"},"author":{"name":"Sascha Depold","email":"sascha@depold.com"},"contributors":[{"name":"Jukka Hyytiälä","email":"hyytiala.jukka@gmail.com"},{"name":"Pascal Pflaum","email":"mail@pascalpflaum.de"},{"name":"Pedro Augusto de Paula Barbosa","email":"papb1996@gmail.com"}],"license":"MIT","bugs":{"url":"https://github.com/sequelize/umzug/issues"},"homepage":"https://github.com/sequelize/umzug","engines":{"node":">=10.0.0"},"ava":{"verbose":true,"require":["source-map-support/register"],"typescript":{"rewritePaths":{"src/":"lib/src/","test/":"lib/test/"}},"timeout":"2m"},"xo":{"extends":"xo-typescript","extensions":["ts"],"ignore":"legacy-tests","rules":{"unicorn/string-content":"off","unicorn/filename-case":"off","@typescript-eslint/prefer-readonly-parameter-types":"off","@typescript-eslint/no-unsafe-member-access":"off","@typescript-eslint/no-unsafe-call":"off","@typescript-eslint/unified-signatures":"off","linebreak-style":"off","object-curly-spacing":["error","always"]}},"readme":"# Umzug [![Build Status](https://travis-ci.org/sequelize/umzug.svg?branch=master)](https://travis-ci.org/sequelize/umzug) [![npm version](https://badgen.net/npm/v/umzug)](https://www.npmjs.com/package/umzug)\n\n[!! We are looking for maintainers !!](https://github.com/sequelize/umzug/issues/204)\n\nUmzug is a framework-agnostic migration tool for Node. It provides a clean API for running and rolling back tasks.\n\n* Programmatic API for migrations\n* Database agnostic\n* Supports logging of migration process\n* Supports multiple storages for migration data\n\n## Documentation\n\n### Minimal Example\n\nThe following example uses a Sqlite database through sequelize and persists the migration data in the database itself through the sequelize storage.\n\n* **`index.js`**:\n\n```javascript\nconst Sequelize = require('sequelize');\nconst path = require('path');\nconst Umzug = require('umzug');\n\n// creates a basic sqlite database\nconst sequelize = new Sequelize({\n  dialect: 'sqlite',\n  storage: './db.sqlite'\n});\n\nconst umzug = new Umzug({\n  migrations: {\n    // indicates the folder containing the migration .js files\n    path: path.join(__dirname, './migrations'),\n    // inject sequelize's QueryInterface in the migrations\n    params: [\n      sequelize.getQueryInterface()\n    ]\n  },\n  // indicates that the migration data should be store in the database\n  // itself through sequelize. The default configuration creates a table\n  // named `SequelizeMeta`.\n  storage: 'sequelize',\n  storageOptions: { sequelize }\n});\n\n(async () => {\n  // checks migrations and run them if they are not already applied\n  await umzug.up();\n  console.log('All migrations performed successfully');\n})();\n```\n\n* **`migrations/00_initial.js`**:\n\n```javascript\nconst Sequelize = require('sequelize');\n\n// All migrations must provide a `up` and `down` async functions\nmodule.exports = {\n  // `query` was passed in the `index.js` file\n  async up(query) {\n    await query.createTable('users', {\n      id: {\n        type: Sequelize.INTEGER,\n        allowNull: false,\n        primaryKey: true\n      },\n      name: {\n        type: Sequelize.STRING,\n        allowNull: false\n      },\n      createdAt: {\n        type: Sequelize.DATE,\n        allowNull: false\n      },\n      updatedAt: {\n        type: Sequelize.DATE,\n        allowNull: false\n      }\n    });\n  },\n  async down(query) {\n    await query.dropTable('users');\n  }\n};\n```\n\n### Usage\n\n#### Installation\n\nUmzug is available on npm:\n\n```bash\nnpm install umzug\n```\n\n#### Umzug instance\n\nIt is possible to configure an Umzug instance by passing an object to the constructor. The possible options are:\n\n```js\nconst Umzug = require('umzug');\n\nconst umzug = new Umzug({\n  // The storage.\n  // Possible values: 'none', 'json', 'mongodb', 'sequelize', an argument for `require()`, including absolute paths\n  storage: 'json',\n\n  // The options for the storage.\n  // Check the available storages for further details.\n  storageOptions: {},\n\n  // The logging function.\n  // A function that gets executed everytime migrations start and have ended.\n  logging: false,\n\n  // (advanced) you can pass an array of migrations built with `migrationsList()` instead of the options below\n  migrations: {\n    // The params that gets passed to the migrations.\n    // Might be an array or a synchronous function which returns an array.\n    params: [],\n\n    // The path to the migrations directory.\n    path: 'migrations',\n\n    // The pattern that determines whether or not a file is a migration.\n    pattern: /^\\d+[\\w-]+\\.js$/,\n\n    // A function that receives and returns the to be executed function.\n    // This can be used to modify the function.\n    wrap(migrationFunction) { return migrationFunction; },\n\n    // A function that maps a file path to a migration object in the form\n    // { up: Function, down: Function }. The default for this is to require(...)\n    // the file as javascript, but you can use this to transpile TypeScript,\n    // read raw sql etc.\n    customResolver(sqlPath) {\n      return {\n        async up() {\n          await sequelize.query(fs.readFileSync(sqlPath, 'utf8'));\n        };\n      }\n    }\n\n    // A function that receives the file path of the migration and returns the name of the \n    // migration. This can be used to remove file extensions for example.\n    nameFormatter(filePath) {\n      return path.parse(filePath).name;\n    }\n  }\n})\n```\n\n#### Executing migrations\n\nThe `execute` method is a general purpose function that runs for every specified migrations the respective function.\n\n```js\nconst migrations = await umzug.execute({\n  migrations: ['some-id', 'some-other-id'],\n  method: 'up'\n});\n// returns an array of all executed/reverted migrations.\n```\n\n#### Getting all pending migrations\n\nYou can get a list of pending/not yet executed migrations like this:\n\n```js\nconst migrations = await umzug.pending();\n// returns an array of all pending migrations.\n```\n\n#### Getting all executed migrations\n\nYou can get a list of already executed migrations like this:\n\n```js\nconst migrations = await umzug.executed();\n// returns an array of all already executed migrations\n```\n\n#### Executing pending migrations\n\nThe `up` method can be used to execute all pending migrations.\n\n```js\nconst migrations = await umzug.up();\n// returns an array of all executed migrations\n```\n\nIt is also possible to pass the name of a migration in order to just run the migrations from the current state to the passed migration name (inclusive).\n\n```js\nawait umzug.up({ to: '20141101203500-task' });\n```\n\nYou also have the ability to choose to run migrations *from* a specific migration, excluding it:\n\n```js\nawait umzug.up({ from: '20141101203500-task' });\n```\n\nIn the above example umzug will execute all the pending migrations found **after** the specified migration. This is particularly useful if you are using migrations on your native desktop application and you don't need to run past migrations on new installs while they need to run on updated installations.\n\nYou can combine `from` and `to` options to select a specific subset:\n\n```js\nawait umzug.up({ from: '20141101203500-task', to: '20151201103412-items' });\n```\n\nRunning specific migrations while ignoring the right order, can be done like this:\n\n```js\nawait umzug.up({ migrations: ['20141101203500-task', '20141101203501-task-2'] });\n```\n\nThere are also shorthand version of that:\n\n```js\nawait umzug.up('20141101203500-task'); // Runs just the passed migration\nawait umzug.up(['20141101203500-task', '20141101203501-task-2']);\n```\n\n#### Reverting executed migration\n\nThe `down` method can be used to revert the last executed migration.\n\n```js\nconst migration = await umzug.down();\n// returns the reverted migration.\n```\n\nIt is possible to pass the name of a migration until which (inclusive) the migrations should be reverted. This allows the reverting of multiple migrations at once.\n\n```js\nconst migrations = await umzug.down({ to: '20141031080000-task' });\n// returns an array of all reverted migrations.\n```\n\nTo revert all migrations, you can pass 0 as the `to` parameter:\n\n```js\nawait umzug.down({ to: 0 });\n```\n\nReverting specific migrations while ignoring the right order, can be done like this:\n\n```js\nawait umzug.down({ migrations: ['20141101203500-task', '20141101203501-task-2'] });\n```\n\nThere are also shorthand versions of that:\n\n```js\nawait umzug.down('20141101203500-task'); // Runs just the passed migration\nawait umzug.down(['20141101203500-task', '20141101203501-task-2']);\n```\n\n### Migrations\n\nThere are two ways to specify migrations: via files or directly via an array of migrations.\n\n#### Migration files\n\nA migration file ideally exposes an `up` and a `down` async functions. They will perform the task of upgrading or downgrading the database.\n\n```js\n\nmodule.exports = {\n  up: async () => {\n    ...\n  },\n  down: async () => {\n    ...\n  },\n};\n```\n\nMigration files should be located in the same directory, according to the info you gave to the `Umzug` constructor.\n\n#### Direct migrations list\n\nYou can also specify directly a list of migrations to the `Umzug` constructor. We recommend the usage of the `Umzug.migrationsList()` function\nas bellow:\n\n```js\nconst umzug = new Umzug({\n  migrations: Umzug.migrationsList(\n    [\n      {\n        // the name of the migration is mandatory\n        name: '00-first-migration',\n        async up(queryInterface) { /* ... */ },\n        async down(queryInterface) { /* ... */ }\n      },\n      {\n        name: '01-foo-bar-migration',\n        async up(queryInterface) { /* ... */ },\n        async down(queryInterface) { /* ... */ }\n      }\n    ],\n    // an optional list of parameters that will be sent to the `up` and `down` functions\n    [\n      sequelize.getQueryInterface()\n    ]\n  )\n});\n```\n\n### Storages\n\nStorages define where the migration data is stored.\n\n#### JSON Storage\n\nUsing the `json` storage will create a JSON file which will contain an array with all the executed migrations. You can specify the path to the file. The default for that is `umzug.json` in the working directory of the process.\n\nOptions:\n\n```js\n{\n  // The path to the json storage.\n  // Defaults to process.cwd() + '/umzug.json';\n  path: process.cwd() + '/db/sequelize-meta.json'\n}\n```\n\n#### Sequelize Storage\n\nUsing the `sequelize` storage will create a table in your SQL database called `SequelizeMeta` containing an entry for each executed migration. You will have to pass a configured instance of Sequelize or an existing Sequelize model. Optionally you can specify the model name, table name, or column name. All major Sequelize versions are supported.\n\nOptions:\n\n```js\n{\n  // The configured instance of Sequelize.\n  // Optional if `model` is passed.\n  sequelize: instance,\n\n  // The to be used Sequelize model.\n  // Must have column name matching `columnName` option\n  // Optional if `sequelize` is passed.\n  model: model,\n\n  // The name of the to be used model.\n  // Defaults to 'SequelizeMeta'\n  modelName: 'Schema',\n\n  // The name of table to create if `model` option is not supplied\n  // Defaults to `modelName`\n  tableName: 'Schema',\n\n  // The name of table column holding migration name.\n  // Defaults to 'name'.\n  columnName: 'migration',\n\n  // The type of the column holding migration name.\n  // Defaults to `Sequelize.STRING`\n  columnType: new Sequelize.STRING(100)\n}\n```\n\n#### MongoDB Storage\n\nUsing the `mongodb` storage will create a collection in your MongoDB database called `migrations` containing an entry for each executed migration. You will have either to pass a MongoDB Driver Collection as `collection` property. Alternatively you can pass a established MongoDB Driver connection and a collection name.\n\nOptions:\n\n```js\n{\n  // a connection to target database established with MongoDB Driver\n  connection: MongoDBDriverConnection,\n\n  // name of migration collection in MongoDB\n  collectionName: 'migrations',\n\n  // reference to a MongoDB Driver collection\n  collection: MongoDBDriverCollection\n}\n```\n\n#### Custom\n\nIn order to use custom storage, you have two options:\n\n##### Method 1: Pass instance to constructor\n\nYou can pass your storage instance to Umzug constructor.\n\n```js\nclass CustomStorage {\n  constructor(...) {...}\n  logMigration(...) {...}\n  unlogMigration(...) {...}\n  executed(...) {...}\n}\nlet umzug = new Umzug({ storage: new CustomStorage(...) })\n```\n\n##### Method 2: Require external module from npmjs.com\n\nCreate and publish a module which has to fulfill the following API. You can just pass the name of the module to the configuration and *umzug* will require it accordingly. The API that needs to be exposed looks like this:\n\n```js\nmodule.exports = class MyStorage {\n  constructor({ option1: 'defaultValue1' } = {}) {\n    this.option1 = option1;\n  },\n\n  async logMigration(migrationName) {\n    // This function logs a migration as executed.\n    // It will get called once a migration was\n    // executed successfully.\n  },\n\n  async unlogMigration(migrationName) {\n    // This function removes a previously logged migration.\n    // It will get called once a migration has been reverted.\n  },\n\n  async executed() {\n    // This function lists the names of the logged\n    // migrations. It will be used to calculate\n    // pending migrations. The result has to be an\n    // array with the names of the migration files.\n  }\n}\n```\n\n### Events\n\nUmzug is an EventEmitter. Each of the following events will be called with `name, migration` as arguments. Events are a convenient place to implement application-specific logic that must run around each migration:\n\n* *migrating* - A migration is about to be executed.\n* *migrated* - A migration has successfully been executed.\n* *reverting* - A migration is about to be reverted.\n* *reverted* - A migration has successfully been reverted.\n\n## Examples\n\n* [sequelize-migration-hello](https://github.com/abelnation/sequelize-migration-hello)\n\n## License\n\nSee the [LICENSE file](./LICENSE)\n","readmeFilename":"README.md","gitHead":"9780ba8b288098d518a3c11538b4751765821eb2","_id":"umzug@3.0.0-beta.2","_nodeVersion":"12.14.1","_npmVersion":"6.13.6","dist":{"integrity":"sha512-0+efVJ3HYb9l1mcM0Oh4ad3N7EFQ23fHpNksar0cvHdaZLnavXAlkmsLtV4tTL/xoxpEdLrImr0ai7gqCsPglg==","shasum":"f3fd91d7977279ff7a40ca4d68b57bb41475b042","tarball":"https://registry.npmjs.org/umzug/-/umzug-3.0.0-beta.2.tgz","fileCount":40,"unpackedSize":85372,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJeilAnCRA9TVsSAnZWagAAnj8P/2QkZL2NXpimySZDEmeB\nJgxdaF1OARWqDGmX6re5kmBC75HUEcizXSBA6XVOt9vicWYgB5aZPwgTziXG\nd9M4qyD6QX7VyvIod0fasq6w9WMak9V4DzXGinU52YYmDARCJsC34EwEppQ4\nNTc02OM69Ot+kNn1zgI4BUfEkpyvE1rqlGbEhv5y0S4sl5PP7AVIm328bOX6\ncCkAsxzCfohomQdGLWLf71ZZVUulPEz89jMVsKRpnyAc+IlFcbpqzufRcDnc\nUTmTBu4nnRZA1pRJAViyhKWvRMUwTrhNPWa3HBlvdNPC75ZeHbdCsKDhBaSg\n2DU5+h6SOdaV1hpeGifQ5zd4TQAC4tIy19BSQiMq1azz/s6Ad3ivVMBJeHf7\ntXdLdpsDcG/2dEvj+uWHf8mdbda7ILNhgN499KgZWXWIW0cflElrprsMZfQd\nBxSYaP97wGAi5/1QHmeGc320bwgHEgkc/llXWq4hTznM3LK7/LYk+WILs4ME\n8UKPjWpPiq5Tcdk52PnC6YP/H6I7gEZlRb0hhTWSePkZ6NppxHi8ofSSnins\nzyxwas2pVn/DVyGFJE/s65uWj2xg9dbr3O7v7zOrwF16q/v7ILPK/JslVKSh\nH73eAmNzuWS56aXwdArX2UJWT607m9ofslT7Vt3VxTnO6dUueYYnm7Q6rblj\nyYkH\r\n=l22M\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCICjWIrp+IHP+gPhLEFO6eTjQR0XUDF5+gegRXoh+Jyu8AiEA/nqL9kL0y40WZLnWjoW5W/I3pnpdFI6gf6IkamFL/Qo="}]},"maintainers":[{"email":"hyytiala.jukka@gmail.com","name":"jukkah"},{"email":"mail@pascalpflaum.de","name":"pascal.pflaum"},{"email":"sascha@depold.com","name":"sdepold"}],"_npmUser":{"name":"papb","email":"papb1996@gmail.com"},"directories":{},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/umzug_3.0.0-beta.2_1586122790820_0.47882183440271864"},"_hasShrinkwrap":false},"3.0.0-beta.3":{"name":"umzug","version":"3.0.0-beta.3","description":"Framework-agnostic migration tool for Node","keywords":["migrate","migration","migrations","sequelize"],"main":"lib/src/index.js","dependencies":{"fs-jetpack":"^2.2.3","p-each-series":"^2.1.0","p-map":"^4.0.0","tory":"~0.4.3"},"devDependencies":{"@ava/typescript":"^1.1.1","ava":"^3.5.0","chai":"^4.2.0","del-cli":"^3.0.0","eslint-config-xo-typescript":"~0.27.0","lodash":"^4.17.15","mocha":"^6.2.2","np":"https://github.com/pixelastic/np/tarball/c3ab2e3b053c7da0ce40a572ca1616273ac080f8","sequelize":"^5.21.5","sinon":"^7.5.0","sinon-chai":"^3.5.0","source-map-support":"^0.5.16","sqlite3":"^4.1.1","type-fest":"^0.13.0","typescript":"~3.8.3","uuid":"^7.0.2","xo":"^0.28.3"},"scripts":{"build":"del-cli lib && tsc","mocha":"node legacy-tests/clear-tmp.js && mocha --check-leaks legacy-tests/index.js","prepare":"npm run build","release":"np --no-2fa","ava":"npm run build && ava test/test.ts","test":"npm run build && xo && ava test/test.ts && npm run mocha"},"repository":{"type":"git","url":"git+https://github.com/sequelize/umzug.git"},"author":{"name":"Sascha Depold","email":"sascha@depold.com"},"contributors":[{"name":"Jukka Hyytiälä","email":"hyytiala.jukka@gmail.com"},{"name":"Pascal Pflaum","email":"mail@pascalpflaum.de"},{"name":"Pedro Augusto de Paula Barbosa","email":"papb1996@gmail.com"}],"license":"MIT","bugs":{"url":"https://github.com/sequelize/umzug/issues"},"homepage":"https://github.com/sequelize/umzug","engines":{"node":">=10.0.0"},"ava":{"verbose":true,"require":["source-map-support/register"],"typescript":{"rewritePaths":{"src/":"lib/src/","test/":"lib/test/"}},"timeout":"2m"},"xo":{"extends":"xo-typescript","extensions":["ts"],"ignore":"legacy-tests","rules":{"unicorn/string-content":"off","unicorn/filename-case":"off","@typescript-eslint/prefer-readonly-parameter-types":"off","@typescript-eslint/no-unsafe-member-access":"off","@typescript-eslint/no-unsafe-call":"off","@typescript-eslint/unified-signatures":"off","linebreak-style":"off","object-curly-spacing":["error","always"]}},"readme":"# Umzug [![Build Status](https://travis-ci.org/sequelize/umzug.svg?branch=master)](https://travis-ci.org/sequelize/umzug) [![npm version](https://badgen.net/npm/v/umzug)](https://www.npmjs.com/package/umzug)\n\n[!! We are looking for maintainers !!](https://github.com/sequelize/umzug/issues/204)\n\nUmzug is a framework-agnostic migration tool for Node. It provides a clean API for running and rolling back tasks.\n\n## Highlights\n\n* Written in TypeScript - you have built-in typings and auto-completion right in your IDE\n* Programmatic API for migrations\n* Database agnostic\n* Supports logging of migration process\n* Supports multiple storages for migration data\n\n## Documentation\n\n### Minimal Example\n\nThe following example uses a Sqlite database through sequelize and persists the migration data in the database itself through the sequelize storage.\n\n* **`index.js`**:\n\n```js\nconst { Sequelize } = require('sequelize');\nconst { Umzug } = require('umzug');\n\nconst sequelize = new Sequelize({ dialect: 'sqlite', storage: './db.sqlite' });\n\nconst umzug = new Umzug({\n  migrations: {\n    path: './migrations',\n    params: [\n      sequelize.getQueryInterface()\n    ]\n  },\n  storage: 'sequelize',\n  storageOptions: { sequelize }\n});\n\n(async () => {\n  // Checks migrations and run them if they are not already applied. To keep\n  // track of the executed migrations, a table (and sequelize model) called SequelizeMeta\n  // will be automatically created (if it doesn't exist already) and parsed.\n  await umzug.up();\n})();\n```\n\n* **`migrations/00_initial.js`**:\n\n```js\nconst { Sequelize } = require('sequelize');\n\nasync function up(queryInterface) {\n\tawait queryInterface.createTable('users', {\n\t\tid: {\n\t\t\ttype: Sequelize.INTEGER,\n\t\t\tallowNull: false,\n\t\t\tprimaryKey: true\n\t\t},\n\t\tname: {\n\t\t\ttype: Sequelize.STRING,\n\t\t\tallowNull: false\n\t\t},\n\t\tcreatedAt: {\n\t\t\ttype: Sequelize.DATE,\n\t\t\tallowNull: false\n\t\t},\n\t\tupdatedAt: {\n\t\t\ttype: Sequelize.DATE,\n\t\t\tallowNull: false\n\t\t}\n\t});\n}\n\nasync function down(queryInterface) {\n\tawait queryInterface.dropTable('users');\n}\n\nmodule.exports = { up, down };\n```\n\nSee [this test](https://github.com/sequelize/umzug/blob/9780ba8b288098d518a3c11538b4751765821eb2/test/test.ts) for another example of Umzug usage.\n\n### Usage\n\n#### Installation\n\nUmzug is available on npm:\n\n```bash\nnpm install umzug\n```\n\n#### Umzug instance\n\nIt is possible to configure an Umzug instance by passing an object to the constructor.\n\n```js\nconst { Umzug } = require('umzug');\nconst umzug = new Umzug({ /* ... options ... */ });\n```\n\nCheck the documentation for the options in [src/types.ts](https://github.com/sequelize/umzug/blob/9780ba8b288098d518a3c11538b4751765821eb2/src/types.ts#L100).\n\n#### Executing migrations\n\nThe `execute` method is a general purpose function that runs for every specified migrations the respective function.\n\n```js\nconst migrations = await umzug.execute({\n  migrations: ['some-id', 'some-other-id'],\n  method: 'up'\n});\n// returns an array of all executed/reverted migrations.\n```\n\n#### Getting all pending migrations\n\nYou can get a list of pending (i.e. not yet executed) migrations with the `pending()` method:\n\n```js\nconst migrations = await umzug.pending();\n// returns an array of all pending migrations.\n```\n\n#### Getting all executed migrations\n\nYou can get a list of already executed migrations with the `executed()` method:\n\n```js\nconst migrations = await umzug.executed();\n// returns an array of all already executed migrations\n```\n\n#### Executing pending migrations\n\nThe `up` method can be used to execute all pending migrations.\n\n```js\nconst migrations = await umzug.up();\n// returns an array of all executed migrations\n```\n\nIt is also possible to pass the name of a migration in order to just run the migrations from the current state to the passed migration name (inclusive).\n\n```js\nawait umzug.up({ to: '20141101203500-task' });\n```\n\nYou also have the ability to choose to run migrations *from* a specific migration, excluding it:\n\n```js\nawait umzug.up({ from: '20141101203500-task' });\n```\n\nIn the above example umzug will execute all the pending migrations found **after** the specified migration. This is particularly useful if you are using migrations on your native desktop application and you don't need to run past migrations on new installs while they need to run on updated installations.\n\nYou can combine `from` and `to` options to select a specific subset:\n\n```js\nawait umzug.up({ from: '20141101203500-task', to: '20151201103412-items' });\n```\n\nRunning specific migrations while ignoring the right order, can be done like this:\n\n```js\nawait umzug.up({ migrations: ['20141101203500-task', '20141101203501-task-2'] });\n```\n\nThere are also shorthand version of that:\n\n```js\nawait umzug.up('20141101203500-task'); // Runs just the passed migration\nawait umzug.up(['20141101203500-task', '20141101203501-task-2']);\n```\n\n#### Reverting executed migration\n\nThe `down` method can be used to revert the last executed migration.\n\n```js\nconst migration = await umzug.down();\n// reverts the last migration and returns it.\n```\n\nIt is possible to pass the name of a migration until which (inclusive) the migrations should be reverted. This allows the reverting of multiple migrations at once.\n\n```js\nconst migrations = await umzug.down({ to: '20141031080000-task' });\n// returns an array of all reverted migrations.\n```\n\nTo revert all migrations, you can pass 0 as the `to` parameter:\n\n```js\nawait umzug.down({ to: 0 });\n```\n\nReverting specific migrations while ignoring the right order, can be done like this:\n\n```js\nawait umzug.down({ migrations: ['20141101203500-task', '20141101203501-task-2'] });\n```\n\nThere are also shorthand versions of that:\n\n```js\nawait umzug.down('20141101203500-task'); // Runs just the passed migration\nawait umzug.down(['20141101203500-task', '20141101203501-task-2']);\n```\n\n### Migrations\n\nThere are two ways to specify migrations: via files or directly via an array of migrations.\n\n#### Migration files\n\nA migration file ideally exposes an `up` and a `down` async functions. They will perform the task of upgrading or downgrading the database.\n\n```js\nmodule.exports = {\n  async up() {\n    /* ... */\n  },\n  async down() {\n    /* ... */\n  }\n};\n```\n\nMigration files should be located in the same directory, according to the info you gave to the `Umzug` constructor.\n\n#### Direct migrations list\n\nYou can also specify directly a list of migrations to the `Umzug` constructor. We recommend the usage of the `Umzug.migrationsList()` function\nas bellow:\n\n```js\nconst { Umzug, migrationsList } = require('umzug');\n\nconst umzug = new Umzug({\n  migrations: migrationsList(\n    [\n      {\n        // the name of the migration is mandatory\n        name: '00-first-migration',\n        async up(queryInterface) { /* ... */ },\n        async down(queryInterface) { /* ... */ }\n      },\n      {\n        name: '01-foo-bar-migration',\n        async up(queryInterface) { /* ... */ },\n        async down(queryInterface) { /* ... */ }\n      }\n    ],\n    // an optional list of parameters that will be sent to the `up` and `down` functions\n    [\n      sequelize.getQueryInterface()\n    ]\n  )\n});\n```\n\n### Storages\n\nStorages define where the migration data is stored.\n\n#### JSON Storage\n\nUsing the `json` storage will create a JSON file which will contain an array with all the executed migrations. You can specify the path to the file. The default for that is `umzug.json` in the working directory of the process.\n\nSee the options it can take in [src/storages/JSONStorage.ts](https://github.com/sequelize/umzug/blob/9780ba8b288098d518a3c11538b4751765821eb2/src/storages/JSONStorage.ts#L4).\n\n#### Sequelize Storage\n\nUsing the `sequelize` storage will create a table in your SQL database called `SequelizeMeta` containing an entry for each executed migration. You will have to pass a configured instance of Sequelize or an existing Sequelize model. Optionally you can specify the model name, table name, or column name. All major Sequelize versions are supported.\n\nSee the options it can take in [src/storages/SequelizeStorage.ts](https://github.com/sequelize/umzug/blob/9780ba8b288098d518a3c11538b4751765821eb2/src/storages/SequelizeStorage.ts#L5).\n\n#### MongoDB Storage\n\nUsing the `mongodb` storage will create a collection in your MongoDB database called `migrations` containing an entry for each executed migration. You will have either to pass a MongoDB Driver Collection as `collection` property. Alternatively you can pass a established MongoDB Driver connection and a collection name.\n\nSee the options it can take in [src/storages/MongoDBStorage.ts](https://github.com/sequelize/umzug/blob/9780ba8b288098d518a3c11538b4751765821eb2/src/storages/MongoDBStorage.ts#L26).\n\n#### Custom\n\nIn order to use custom storage, you have two options:\n\n##### Method 1: Pass instance to constructor\n\nYou can pass your storage instance to Umzug constructor.\n\n```js\nclass CustomStorage {\n  constructor(...) {...}\n  logMigration(...) {...}\n  unlogMigration(...) {...}\n  executed(...) {...}\n}\nlet umzug = new Umzug({ storage: new CustomStorage(...) })\n```\n\nYour instance must adhere to the [UmzugStorage](https://github.com/sequelize/umzug/blob/master/src/storages/type-helpers/umzug-storage.ts) interface.\n\n##### Method 2: Pass module name to be required\n\nCreate a module which has to fulfill the following API. You can just pass the name of the module to the configuration and *umzug* will require it accordingly. \n\nThe module must export a class that implements the [UmzugStorage](https://github.com/sequelize/umzug/blob/master/src/storages/type-helpers/umzug-storage.ts) interface.\n\nFor example, if you're using TypeScript:\n\n```js\nimport { UmzugStorage } from 'umzug/lib/src/storages/type-helpers'\n\nclass MyStorage implements UmzugStorage {\n  /* ... */\n}\n\nmodule.exports = MyStorage;\n```\n\n### Events\n\nUmzug is an [EventEmitter](https://nodejs.org/docs/latest-v10.x/api/events.html#events_class_eventemitter). Each of the following events will be called with `name` and `migration` as arguments. Events are a convenient place to implement application-specific logic that must run around each migration:\n\n* `migrating` - A migration is about to be executed.\n* `migrated` - A migration has successfully been executed.\n* `reverting` - A migration is about to be reverted.\n* `reverted` - A migration has successfully been reverted.\n\n## License\n\nSee the [LICENSE file](./LICENSE)\n","readmeFilename":"README.md","gitHead":"1a01659556bfb1c0f2e25e5ab7b6f396a906e538","_id":"umzug@3.0.0-beta.3","_nodeVersion":"12.14.1","_npmVersion":"6.13.6","dist":{"integrity":"sha512-gdFQ3Vh9UNTGL5swZr8zpmCuwlC/hUckLd5LxyZkwwJfwBkDEoH1VrhO9TpdgyO79AmNYdvwSBaQfwBaYmmobA==","shasum":"c006a430ec896b3e86057fd9babe57a6766f1540","tarball":"https://registry.npmjs.org/umzug/-/umzug-3.0.0-beta.3.tgz","fileCount":40,"unpackedSize":83701,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJei+oJCRA9TVsSAnZWagAAKqoQAJZIb1FK6Qx1Nahim+ZT\nSY2TqckcBVlhyO/p/oU/f6n7cKRFnKIWEhjdjHwsBhw/0LbAXhyUCs6EugS4\nXC+zqVSXEhHeq9DKBFzxx/k8qMLNm0MEz7nyBpX2PsRLa2WJh0RaXfHPeVNi\nJHg/r+EIu1TVR3MdHvAJ/tvLRYT03NwSiwOs4iq6xeAb2+/BIEDMeHORjtpW\n2rpCMegMfPmNLDm+Nku1WI8CLX7aXZKyLAPUt8x8NyjJSRoQPrW156UGEP3m\nbZGzkjpbsGfnN2sM8jyb5xQCEiaKApk6OrNAIUsSSSriOQFKXYrmHbAYja+7\nbWr8HEzU8AYBafdtpq1cEs4YbxvZ7DxfxDhYbW839zpKS6piRzU9heeK8QDK\nd9rg2gH3XPHqr9LeiPGoLm7Yz8qUFbCZi5QANQvsUajzLvb8zHykeZ6oo1tj\nUxSLBU7nLlgFQBB+Mn8Md0Gp3Vw6fSYNcurAu/SxPUujfrgD2rz3FBspJZYR\nIG75VMv0pon+wci6K4P8d8/PTWDOKTlaN4eTHc5Xhye1CfDmCLZTLd8M5jZV\nmrBMspkzqCz5+GfsEOkZ6BTtVjyWhvM413a3Z5fQWZMTHBkatz5+FAgWL3hj\ny6yPJ/wbNPmxgq0M56cIqqVlk1A69PghXo84HOlQ9M/EcImyiZi/YiGRktKV\ndiQM\r\n=QwA5\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEQCIGDO8WVKvs33NfdLti/wfoz8Y9Q38RBe/uUM2tqhoyjgAiBciojbxp8Kdplqaw7VxbVSgS4AxiP712NiDD8mhHfknA=="}]},"maintainers":[{"email":"hyytiala.jukka@gmail.com","name":"jukkah"},{"email":"mail@pascalpflaum.de","name":"pascal.pflaum"},{"email":"sascha@depold.com","name":"sdepold"}],"_npmUser":{"name":"papb","email":"papb1996@gmail.com"},"directories":{},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/umzug_3.0.0-beta.3_1586227721019_0.7279663821116216"},"_hasShrinkwrap":false},"3.0.0-beta.4":{"name":"umzug","version":"3.0.0-beta.4","description":"Framework-agnostic migration tool for Node","keywords":["migrate","migration","migrations","sequelize"],"main":"lib/src/index.js","dependencies":{"fs-jetpack":"^2.2.3","p-each-series":"^2.1.0","p-map":"^4.0.0","tory":"~0.4.3"},"devDependencies":{"@types/jest":"^25.2.1","@typescript-eslint/eslint-plugin":"^2.28.0","@typescript-eslint/parser":"^2.28.0","chai":"^4.2.0","del-cli":"^3.0.0","eslint":"^6.8.0","eslint-config-xo":"^0.29.1","eslint-config-xo-typescript":"^0.27.0","eslint-plugin-import":"^2.20.2","eslint-plugin-jest":"^23.8.2","eslint-plugin-mocha":"^6.3.0","eslint-plugin-prettier":"^3.1.3","eslint-plugin-unicorn":"^18.0.1","jest":"^25.4.0","lodash":"^4.17.15","mocha":"^6.2.2","np":"https://github.com/pixelastic/np/tarball/c3ab2e3b053c7da0ce40a572ca1616273ac080f8","prettier":"^2.0.4","sequelize":"^5.21.5","sinon":"^7.5.0","sinon-chai":"^3.5.0","source-map-support":"^0.5.16","sqlite3":"^4.1.1","ts-jest":"^25.4.0","type-fest":"^0.13.0","typescript":"~3.8.3","uuid":"^7.0.2"},"scripts":{"build":"del-cli lib && tsc","lint":"eslint --ext .ts .","mocha":"node legacy-tests/clear-tmp.js && mocha --check-leaks legacy-tests/index.js --timeout 10000","prepare":"npm run build","release":"np --no-2fa","test":"jest && npm run mocha"},"repository":{"type":"git","url":"git+https://github.com/sequelize/umzug.git"},"author":{"name":"Sascha Depold","email":"sascha@depold.com"},"contributors":[{"name":"Jukka Hyytiälä","email":"hyytiala.jukka@gmail.com"},{"name":"Pascal Pflaum","email":"mail@pascalpflaum.de"},{"name":"Pedro Augusto de Paula Barbosa","email":"papb1996@gmail.com"}],"license":"MIT","bugs":{"url":"https://github.com/sequelize/umzug/issues"},"homepage":"https://github.com/sequelize/umzug","engines":{"node":">=10.0.0"},"jest":{"preset":"ts-jest","testEnvironment":"node","testMatch":["**/*test.ts"]},"readme":"# Umzug [![Build Status](https://travis-ci.org/sequelize/umzug.svg?branch=master)](https://travis-ci.org/sequelize/umzug) [![npm version](https://badgen.net/npm/v/umzug)](https://www.npmjs.com/package/umzug)\n\nUmzug is a framework-agnostic migration tool for Node. It provides a clean API for running and rolling back tasks.\n\n_Note: master represents the next major version of umzug - v3 - which is currently in beta. For the stable version, please refer to the [v2.x branch](https://github.com/sequelize/umzug/tree/v2.x)._\n\n## Highlights\n\n* Written in TypeScript\n\t* Built-in typings\n\t* Auto-completion right in your IDE\n\t* Documentation right in your IDE\n* Programmatic API for migrations\n* Database agnostic\n* Supports logging of migration process\n* Supports multiple storages for migration data\n\n## Documentation\n\n### Minimal Example\n\nThe following example uses a Sqlite database through sequelize and persists the migration data in the database itself through the sequelize storage.\n\n* **`index.js`**:\n\n```js\nconst { Sequelize } = require('sequelize');\nconst { Umzug } = require('umzug');\n\nconst sequelize = new Sequelize({ dialect: 'sqlite', storage: './db.sqlite' });\n\nconst umzug = new Umzug({\n  migrations: {\n    path: './migrations',\n    params: [\n      sequelize.getQueryInterface()\n    ]\n  },\n  storage: 'sequelize',\n  storageOptions: { sequelize }\n});\n\n(async () => {\n  // Checks migrations and run them if they are not already applied. To keep\n  // track of the executed migrations, a table (and sequelize model) called SequelizeMeta\n  // will be automatically created (if it doesn't exist already) and parsed.\n  await umzug.up();\n})();\n```\n\n* **`migrations/00_initial.js`**:\n\n```js\nconst { Sequelize } = require('sequelize');\n\nasync function up(queryInterface) {\n\tawait queryInterface.createTable('users', {\n\t\tid: {\n\t\t\ttype: Sequelize.INTEGER,\n\t\t\tallowNull: false,\n\t\t\tprimaryKey: true\n\t\t},\n\t\tname: {\n\t\t\ttype: Sequelize.STRING,\n\t\t\tallowNull: false\n\t\t},\n\t\tcreatedAt: {\n\t\t\ttype: Sequelize.DATE,\n\t\t\tallowNull: false\n\t\t},\n\t\tupdatedAt: {\n\t\t\ttype: Sequelize.DATE,\n\t\t\tallowNull: false\n\t\t}\n\t});\n}\n\nasync function down(queryInterface) {\n\tawait queryInterface.dropTable('users');\n}\n\nmodule.exports = { up, down };\n```\n\nSee [this test](./test/test.ts) for another example of Umzug usage.\n\n### Usage\n\n#### Installation\n\nUmzug is available on npm:\n\n```bash\nnpm install umzug\n```\n\n#### Umzug instance\n\nIt is possible to configure an Umzug instance by passing an object to the constructor.\n\n```js\nconst { Umzug } = require('umzug');\nconst umzug = new Umzug({ /* ... options ... */ });\n```\n\nDetailed documentation for these options are in the `UmzugConstructorOptions` TypeScript interface, which can be found in [src/types.ts](./src/types.ts).\n\n#### Executing migrations\n\nThe `execute` method is a general purpose function that runs for every specified migrations the respective function.\n\n```js\nconst migrations = await umzug.execute({\n  migrations: ['some-id', 'some-other-id'],\n  method: 'up'\n});\n// returns an array of all executed/reverted migrations.\n```\n\n#### Getting all pending migrations\n\nYou can get a list of pending (i.e. not yet executed) migrations with the `pending()` method:\n\n```js\nconst migrations = await umzug.pending();\n// returns an array of all pending migrations.\n```\n\n#### Getting all executed migrations\n\nYou can get a list of already executed migrations with the `executed()` method:\n\n```js\nconst migrations = await umzug.executed();\n// returns an array of all already executed migrations\n```\n\n#### Executing pending migrations\n\nThe `up` method can be used to execute all pending migrations.\n\n```js\nconst migrations = await umzug.up();\n// returns an array of all executed migrations\n```\n\nIt is also possible to pass the name of a migration in order to just run the migrations from the current state to the passed migration name (inclusive).\n\n```js\nawait umzug.up({ to: '20141101203500-task' });\n```\n\nYou also have the ability to choose to run migrations *from* a specific migration, excluding it:\n\n```js\nawait umzug.up({ from: '20141101203500-task' });\n```\n\nIn the above example umzug will execute all the pending migrations found **after** the specified migration. This is particularly useful if you are using migrations on your native desktop application and you don't need to run past migrations on new installs while they need to run on updated installations.\n\nYou can combine `from` and `to` options to select a specific subset:\n\n```js\nawait umzug.up({ from: '20141101203500-task', to: '20151201103412-items' });\n```\n\nRunning specific migrations while ignoring the right order, can be done like this:\n\n```js\nawait umzug.up({ migrations: ['20141101203500-task', '20141101203501-task-2'] });\n```\n\nThere are also shorthand version of that:\n\n```js\nawait umzug.up('20141101203500-task'); // Runs just the passed migration\nawait umzug.up(['20141101203500-task', '20141101203501-task-2']);\n```\n\n#### Reverting executed migration\n\nThe `down` method can be used to revert the last executed migration.\n\n```js\nconst migration = await umzug.down();\n// reverts the last migration and returns it.\n```\n\nIt is possible to pass the name of a migration until which (inclusive) the migrations should be reverted. This allows the reverting of multiple migrations at once.\n\n```js\nconst migrations = await umzug.down({ to: '20141031080000-task' });\n// returns an array of all reverted migrations.\n```\n\nTo revert all migrations, you can pass 0 as the `to` parameter:\n\n```js\nawait umzug.down({ to: 0 });\n```\n\nReverting specific migrations while ignoring the right order, can be done like this:\n\n```js\nawait umzug.down({ migrations: ['20141101203500-task', '20141101203501-task-2'] });\n```\n\nThere are also shorthand versions of that:\n\n```js\nawait umzug.down('20141101203500-task'); // Runs just the passed migration\nawait umzug.down(['20141101203500-task', '20141101203501-task-2']);\n```\n\n### Migrations\n\nThere are two ways to specify migrations: via files or directly via an array of migrations.\n\n#### Migration files\n\nA migration file ideally exposes an `up` and a `down` async functions. They will perform the task of upgrading or downgrading the database.\n\n```js\nmodule.exports = {\n  async up() {\n    /* ... */\n  },\n  async down() {\n    /* ... */\n  }\n};\n```\n\nMigration files should be located in the same directory, according to the info you gave to the `Umzug` constructor.\n\n#### Direct migrations list\n\nYou can also specify directly a list of migrations to the `Umzug` constructor. We recommend the usage of the `Umzug.migrationsList()` function\nas bellow:\n\n```js\nconst { Umzug, migrationsList } = require('umzug');\n\nconst umzug = new Umzug({\n  migrations: migrationsList(\n    [\n      {\n        // the name of the migration is mandatory\n        name: '00-first-migration',\n        async up(queryInterface) { /* ... */ },\n        async down(queryInterface) { /* ... */ }\n      },\n      {\n        name: '01-foo-bar-migration',\n        async up(queryInterface) { /* ... */ },\n        async down(queryInterface) { /* ... */ }\n      }\n    ],\n    // an optional list of parameters that will be sent to the `up` and `down` functions\n    [\n      sequelize.getQueryInterface()\n    ]\n  )\n});\n```\n\n### Storages\n\nStorages define where the migration data is stored.\n\n#### JSON Storage\n\nUsing the `json` storage will create a JSON file which will contain an array with all the executed migrations. You can specify the path to the file. The default for that is `umzug.json` in the working directory of the process.\n\nDetailed documentation for the options it can take are in the `JSONStorageConstructorOptions` TypeScript interface, which can be found in [src/storages/JSONStorage.ts](./src/storages/JSONStorage.ts).\n\n#### Sequelize Storage\n\nUsing the `sequelize` storage will create a table in your SQL database called `SequelizeMeta` containing an entry for each executed migration. You will have to pass a configured instance of Sequelize or an existing Sequelize model. Optionally you can specify the model name, table name, or column name. All major Sequelize versions are supported.\n\nDetailed documentation for the options it can take are in the `_SequelizeStorageConstructorOptions` TypeScript interface, which can be found in [src/storages/SequelizeStorage.ts](./src/storages/SequelizeStorage.ts).\n\n#### MongoDB Storage\n\nUsing the `mongodb` storage will create a collection in your MongoDB database called `migrations` containing an entry for each executed migration. You will have either to pass a MongoDB Driver Collection as `collection` property. Alternatively you can pass a established MongoDB Driver connection and a collection name.\n\nDetailed documentation for the options it can take are in the `MongoDBStorageConstructorOptions` TypeScript interface, which can be found in [src/storages/MongoDBStorage.ts](./src/storages/MongoDBStorage.ts).\n\n#### Custom\n\nIn order to use custom storage, you have two options:\n\n##### Method 1: Pass instance to constructor\n\nYou can pass your storage instance to Umzug constructor.\n\n```js\nclass CustomStorage {\n  constructor(...) {...}\n  logMigration(...) {...}\n  unlogMigration(...) {...}\n  executed(...) {...}\n}\nlet umzug = new Umzug({ storage: new CustomStorage(...) })\n```\n\nYour instance must adhere to the [UmzugStorage](./src/storages/type-helpers/umzug-storage.ts) interface.\n\n##### Method 2: Pass module name to be required\n\nCreate a module which has to fulfill the following API. You can just pass the name of the module to the configuration and *umzug* will require it accordingly. \n\nThe module must export a class that implements the [UmzugStorage](./src/storages/type-helpers/umzug-storage.ts) interface.\n\nFor example, if you're using TypeScript:\n\n```js\nimport { UmzugStorage } from 'umzug/lib/src/storages/type-helpers'\n\nclass MyStorage implements UmzugStorage {\n  /* ... */\n}\n\nmodule.exports = MyStorage;\n```\n\n### Events\n\nUmzug is an [EventEmitter](https://nodejs.org/docs/latest-v10.x/api/events.html#events_class_eventemitter). Each of the following events will be called with `name` and `migration` as arguments. Events are a convenient place to implement application-specific logic that must run around each migration:\n\n* `migrating` - A migration is about to be executed.\n* `migrated` - A migration has successfully been executed.\n* `reverting` - A migration is about to be reverted.\n* `reverted` - A migration has successfully been reverted.\n\n## License\n\nSee the [LICENSE file](./LICENSE)\n","readmeFilename":"README.md","gitHead":"4ef3220721e78cc4c60a093e5b3a8567d9568021","_id":"umzug@3.0.0-beta.4","_nodeVersion":"12.14.1","_npmVersion":"6.14.4","dist":{"integrity":"sha512-r2QKj2Pb73OE6d4enk377B3RMU7qS7RIRtXtsv0bw3C5LOBUOeq95kjOvBbOwFMUKlZqfD1eHma6v7lG9cKm4A==","shasum":"5b1b135913cfe0373b8a5c4b821538ba531b2eb1","tarball":"https://registry.npmjs.org/umzug/-/umzug-3.0.0-beta.4.tgz","fileCount":40,"unpackedSize":89135,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJerGobCRA9TVsSAnZWagAArCAP/jn33qtmwmzRHP5g9DNo\nxLwq7y3jRBMKpMih70MJ0qylavheDpWFhRzBlnYVKwOo98UbePBCBXpmIRdd\nEJ0qJ9aL3AYIvgb6VHXeX9Q4TbEhBZ/OkZF34cWg1wUAeu1jRgcs8tuPssDZ\n6Uo1EqzSVxQBVUErNkU6KFoAd4VVTubUUxTdZBa1s9uSvqb41V0dehsyHDs6\nvTuZYxw96dRT5hcUMM2dUiuyX8kte3DOZMx7DTyyg76gj6KlMmrAaUkXB/47\ngPjKV6qVPt/MK4kvIPiJ3n66pxuVD17HY+U2+qB96AsZx1FrTgSKfoUz6zqP\nAwp5ecKRfs6yasdCJXShXG98q/rveHawHr9TTj03kLakXUuZCZCKYvDyYy5Q\nXIe25TGF1qXG0sn8mNFbgJMAdmE+qNoa1oKmOGtVlUGrkVK+QBoevJ7+/ibf\nEB/UHwi8BHs49ryERsaSdmCdX2mQ6mW7XnWQy+4e/1s5feqHZOwPpVCqCMa9\npFz0ZouIyjzU2oZ8HRifyujPoPJoMR1DC6AfBroXvRpff/x9mC0NmF4Z1UPK\nqcN7vtdsWIVDcjo5GvvkRvG1ver6ij+MSSFwPTlP/2jHWZOO6tsQqkVAWyTF\nBJ8uvvVtFI+zKzYuMEhs/4tzlZcH1vppQ8VBCpsDoemFaciyq3oY7uHc6KDz\ncAat\r\n=/RvL\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEYCIQDTxI27oFep6uHi9LbvoVZZ/DiYZg8jj7zwQhXiO7R+1wIhAPJoADtBLaqAEd7NNwnn1wR8RRBzU7+g/r22SJ4H1JJf"}]},"maintainers":[{"email":"hyytiala.jukka@gmail.com","name":"jukkah"},{"email":"mail@pascalpflaum.de","name":"pascal.pflaum"},{"email":"sascha@depold.com","name":"sdepold"}],"_npmUser":{"name":"papb","email":"papb1996@gmail.com"},"directories":{},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/umzug_3.0.0-beta.4_1588357658765_0.6980245840169061"},"_hasShrinkwrap":false},"3.0.0-beta.5":{"name":"umzug","version":"3.0.0-beta.5","description":"Framework-agnostic migration tool for Node","keywords":["migrate","migration","migrations","sequelize"],"main":"lib/index.js","dependencies":{"fs-jetpack":"^2.2.3","p-each-series":"^2.1.0","p-map":"^4.0.0","tory":"~0.4.3"},"devDependencies":{"@types/jest":"^25.2.1","@typescript-eslint/eslint-plugin":"^2.28.0","@typescript-eslint/parser":"^2.28.0","del-cli":"^3.0.0","eslint":"^6.8.0","eslint-config-xo":"^0.29.1","eslint-config-xo-typescript":"^0.27.0","eslint-plugin-codegen":"^0.8.6","eslint-plugin-import":"^2.20.2","eslint-plugin-jest":"^23.8.2","eslint-plugin-mocha":"^6.3.0","eslint-plugin-prettier":"^3.1.3","eslint-plugin-unicorn":"^18.0.1","expect-type":"^0.7.0","fs-syncer":"^0.2.0","jest":"^25.4.0","lodash":"^4.17.15","np":"https://github.com/pixelastic/np/tarball/c3ab2e3b053c7da0ce40a572ca1616273ac080f8","prettier":"^2.0.4","sequelize":"^5.21.5","sinon":"^7.5.0","source-map-support":"^0.5.16","sqlite3":"^4.1.1","ts-jest":"^25.4.0","type-fest":"^0.13.0","typescript":"~3.9.2","uuid":"^7.0.2"},"scripts":{"build":"del-cli lib && tsc","lint":"eslint --ext .js,.ts .","prepare":"npm run build","release":"np --no-2fa","pretest":"del-cli test/generated","test":"jest"},"repository":{"type":"git","url":"git+https://github.com/sequelize/umzug.git"},"author":{"name":"Sascha Depold","email":"sascha@depold.com"},"contributors":[{"name":"Jukka Hyytiälä","email":"hyytiala.jukka@gmail.com"},{"name":"Pascal Pflaum","email":"mail@pascalpflaum.de"},{"name":"Pedro Augusto de Paula Barbosa","email":"papb1996@gmail.com"}],"license":"MIT","bugs":{"url":"https://github.com/sequelize/umzug/issues"},"homepage":"https://github.com/sequelize/umzug","engines":{"node":">=10.0.0"},"jest":{"preset":"ts-jest","testEnvironment":"node","testMatch":["**/*test.ts","**/*test.js"],"collectCoverageFrom":["src/**"]},"readme":"# Umzug [![Build Status](https://travis-ci.org/sequelize/umzug.svg?branch=master)](https://travis-ci.org/sequelize/umzug) [![npm version](https://badgen.net/npm/v/umzug)](https://www.npmjs.com/package/umzug)\n\nUmzug is a framework-agnostic migration tool for Node. It provides a clean API for running and rolling back tasks.\n\n_Note: master represents the next major version of umzug - v3 - which is currently in beta. For the stable version, please refer to the [v2.x branch](https://github.com/sequelize/umzug/tree/v2.x)._\n\n## Highlights\n\n* Written in TypeScript\n\t* Built-in typings\n\t* Auto-completion right in your IDE\n\t* Documentation right in your IDE\n* Programmatic API for migrations\n* Database agnostic\n* Supports logging of migration process\n* Supports multiple storages for migration data\n\n## Documentation\n\n### Minimal Example\n\nThe following example uses a Sqlite database through sequelize and persists the migration data in the database itself through the sequelize storage.\n\n* **`index.js`**:\n\n```js\nconst { Sequelize } = require('sequelize');\nconst { Umzug, SequelizeStorage } = require('umzug');\n\nconst sequelize = new Sequelize({ dialect: 'sqlite', storage: './db.sqlite' });\n\nconst umzug = new Umzug({\n  migrations: {\n    path: './migrations',\n    params: [\n      sequelize.getQueryInterface()\n    ]\n  },\n  storage: new SequelizeStorage({ sequelize })\n});\n\n(async () => {\n  // Checks migrations and run them if they are not already applied. To keep\n  // track of the executed migrations, a table (and sequelize model) called SequelizeMeta\n  // will be automatically created (if it doesn't exist already) and parsed.\n  await umzug.up();\n})();\n```\n\n* **`migrations/00_initial.js`**:\n\n```js\nconst { Sequelize } = require('sequelize');\n\nasync function up(queryInterface) {\n\tawait queryInterface.createTable('users', {\n\t\tid: {\n\t\t\ttype: Sequelize.INTEGER,\n\t\t\tallowNull: false,\n\t\t\tprimaryKey: true\n\t\t},\n\t\tname: {\n\t\t\ttype: Sequelize.STRING,\n\t\t\tallowNull: false\n\t\t},\n\t\tcreatedAt: {\n\t\t\ttype: Sequelize.DATE,\n\t\t\tallowNull: false\n\t\t},\n\t\tupdatedAt: {\n\t\t\ttype: Sequelize.DATE,\n\t\t\tallowNull: false\n\t\t}\n\t});\n}\n\nasync function down(queryInterface) {\n\tawait queryInterface.dropTable('users');\n}\n\nmodule.exports = { up, down };\n```\n\nSee [this test](./test/test.ts) for another example of Umzug usage.\n\n### Usage\n\n#### Installation\n\nUmzug is available on npm:\n\n```bash\nnpm install umzug\n```\n\n#### Umzug instance\n\nIt is possible to configure an Umzug instance by passing an object to the constructor.\n\n```js\nconst { Umzug } = require('umzug');\nconst umzug = new Umzug({ /* ... options ... */ });\n```\n\nDetailed documentation for these options are in the `UmzugConstructorOptions` TypeScript interface, which can be found in [src/types.ts](./src/types.ts).\n\n#### Executing migrations\n\nThe `execute` method is a general purpose function that runs for every specified migrations the respective function.\n\n```js\nconst migrations = await umzug.execute({\n  migrations: ['some-id', 'some-other-id'],\n  method: 'up'\n});\n// returns an array of all executed/reverted migrations.\n```\n\n#### Getting all pending migrations\n\nYou can get a list of pending (i.e. not yet executed) migrations with the `pending()` method:\n\n```js\nconst migrations = await umzug.pending();\n// returns an array of all pending migrations.\n```\n\n#### Getting all executed migrations\n\nYou can get a list of already executed migrations with the `executed()` method:\n\n```js\nconst migrations = await umzug.executed();\n// returns an array of all already executed migrations\n```\n\n#### Executing pending migrations\n\nThe `up` method can be used to execute all pending migrations.\n\n```js\nconst migrations = await umzug.up();\n// returns an array of all executed migrations\n```\n\nIt is also possible to pass the name of a migration in order to just run the migrations from the current state to the passed migration name (inclusive).\n\n```js\nawait umzug.up({ to: '20141101203500-task' });\n```\n\nYou also have the ability to choose to run migrations *from* a specific migration, excluding it:\n\n```js\nawait umzug.up({ from: '20141101203500-task' });\n```\n\nIn the above example umzug will execute all the pending migrations found **after** the specified migration. This is particularly useful if you are using migrations on your native desktop application and you don't need to run past migrations on new installs while they need to run on updated installations.\n\nYou can combine `from` and `to` options to select a specific subset:\n\n```js\nawait umzug.up({ from: '20141101203500-task', to: '20151201103412-items' });\n```\n\nRunning specific migrations while ignoring the right order, can be done like this:\n\n```js\nawait umzug.up({ migrations: ['20141101203500-task', '20141101203501-task-2'] });\n```\n\nThere are also shorthand version of that:\n\n```js\nawait umzug.up('20141101203500-task'); // Runs just the passed migration\nawait umzug.up(['20141101203500-task', '20141101203501-task-2']);\n```\n\n#### Reverting executed migration\n\nThe `down` method can be used to revert the last executed migration.\n\n```js\nconst migration = await umzug.down();\n// reverts the last migration and returns it.\n```\n\nIt is possible to pass the name of a migration until which (inclusive) the migrations should be reverted. This allows the reverting of multiple migrations at once.\n\n```js\nconst migrations = await umzug.down({ to: '20141031080000-task' });\n// returns an array of all reverted migrations.\n```\n\nTo revert all migrations, you can pass 0 as the `to` parameter:\n\n```js\nawait umzug.down({ to: 0 });\n```\n\nReverting specific migrations while ignoring the right order, can be done like this:\n\n```js\nawait umzug.down({ migrations: ['20141101203500-task', '20141101203501-task-2'] });\n```\n\nThere are also shorthand versions of that:\n\n```js\nawait umzug.down('20141101203500-task'); // Runs just the passed migration\nawait umzug.down(['20141101203500-task', '20141101203501-task-2']);\n```\n\n### Migrations\n\nThere are two ways to specify migrations: via files or directly via an array of migrations.\n\n#### Migration files\n\nA migration file ideally exposes an `up` and a `down` async functions. They will perform the task of upgrading or downgrading the database.\n\n```js\nmodule.exports = {\n  async up() {\n    /* ... */\n  },\n  async down() {\n    /* ... */\n  }\n};\n```\n\nMigration files should be located in the same directory, according to the info you gave to the `Umzug` constructor.\n\n#### Direct migrations list\n\nYou can also specify directly a list of migrations to the `Umzug` constructor. We recommend the usage of the `Umzug.migrationsList()` function\nas bellow:\n\n```js\nconst { Umzug, migrationsList } = require('umzug');\n\nconst umzug = new Umzug({\n  migrations: migrationsList(\n    [\n      {\n        // the name of the migration is mandatory\n        name: '00-first-migration',\n        async up(queryInterface) { /* ... */ },\n        async down(queryInterface) { /* ... */ }\n      },\n      {\n        name: '01-foo-bar-migration',\n        async up(queryInterface) { /* ... */ },\n        async down(queryInterface) { /* ... */ }\n      }\n    ],\n    // an optional list of parameters that will be sent to the `up` and `down` functions\n    [\n      sequelize.getQueryInterface()\n    ]\n  )\n});\n```\n\n### Storages\n\nStorages define where the migration data is stored.\n\n#### JSON Storage\n\nUsing `JSONStorage` will create a JSON file which will contain an array with all the executed migrations. You can specify the path to the file. The default for that is `umzug.json` in the working directory of the process.\n\nDetailed documentation for the options it can take are in the `JSONStorageConstructorOptions` TypeScript interface, which can be found in [src/storage/json.ts](./src/storage/json.ts).\n\n#### Memory Storage\n\nUsing `memoryStorage` will store migrations with an in-memory array. This can be useful for proof-of-concepts or tests, since it doesn't interact with databases or filesystems.\n\nIt doesn't take any options, just import the `memoryStorage` function and call it to return a storage instance:\n\n```typescript\nimport { Umzug, memoryStorage } from 'umzug'\n\nconst umzug = new Umzug({\n  migrations: ...,\n  storage: memoryStorage(),\n})\n```\n\n#### Sequelize Storage\n\nUsing `SequelizeStorage` will create a table in your SQL database called `SequelizeMeta` containing an entry for each executed migration. You will have to pass a configured instance of Sequelize or an existing Sequelize model. Optionally you can specify the model name, table name, or column name. All major Sequelize versions are supported.\n\nDetailed documentation for the options it can take are in the `_SequelizeStorageConstructorOptions` TypeScript interface, which can be found in [src/storage/sequelize.ts](./src/storage/sequelize.ts).\n\n#### MongoDB Storage\n\nUsing `MongoDBStorage` will create a collection in your MongoDB database called `migrations` containing an entry for each executed migration. You will have either to pass a MongoDB Driver Collection as `collection` property. Alternatively you can pass a established MongoDB Driver connection and a collection name.\n\nDetailed documentation for the options it can take are in the `MongoDBStorageConstructorOptions` TypeScript interface, which can be found in [src/storage/mongodb.ts](./src/storage/mongodb.ts).\n\n#### Custom\n\nIn order to use a custom storage, you can pass your storage instance to Umzug constructor.\n\n```js\nclass CustomStorage {\n  constructor(...) {...}\n  logMigration(...) {...}\n  unlogMigration(...) {...}\n  executed(...) {...}\n}\n\nconst umzug = new Umzug({ storage: new CustomStorage(...) })\n```\n\nYour instance must adhere to the [UmzugStorage](./src/storage/contract.ts) interface. If you're using TypeScript you can ensure this at compile time, and get IDE type hints by importing it:\n\n```typescript\nimport { UmzugStorage } from 'umzug'\n\nclass CustomStorage implements UmzugStorage {\n  /* ... */\n}\n```\n\n### Events\n\nUmzug is an [EventEmitter](https://nodejs.org/docs/latest-v10.x/api/events.html#events_class_eventemitter). Each of the following events will be called with `name` and `migration` as arguments. Events are a convenient place to implement application-specific logic that must run around each migration:\n\n* `migrating` - A migration is about to be executed.\n* `migrated` - A migration has successfully been executed.\n* `reverting` - A migration is about to be reverted.\n* `reverted` - A migration has successfully been reverted.\n\n## License\n\nSee the [LICENSE file](./LICENSE)\n","readmeFilename":"README.md","gitHead":"05890943aea1f06582de91136e7b8a8260c2b483","_id":"umzug@3.0.0-beta.5","_nodeVersion":"12.14.1","_npmVersion":"6.14.5","dist":{"integrity":"sha512-f9R1rNgtvZgeilVgnS3ULGGTYu5ve0Xw7qgIIIfqYeYH6AFbWRSS5j9x2Lj4vnMMmHqqZimarxYHhMVQUikQWQ==","shasum":"b0a6e2fbaafb5cdb9c4557e74ec25d26e1576cdd","tarball":"https://registry.npmjs.org/umzug/-/umzug-3.0.0-beta.5.tgz","fileCount":37,"unpackedSize":76185,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJevJMBCRA9TVsSAnZWagAAd1EP/15FsJnKhFR8sZy83Odq\nuquJy5Hu4RUrlrzPjAy/HE/lugCkf3JgHylG986rxeREIszad1c4wKq7YfMH\nVS1mImvWL8OYfJFqAZ1PiUkZGuaEIQhmc7Oggk5JfCTNUNadLqPyRnBN1+B9\nNr1u+wzsmlHF1mRiX7V8jnvBfVxgDYgELu1DJZLVMF/b+DhvwM78FJce12z1\n8L/0XLLL1J/SRRFZS8lTBei25HGyzI7R8yYA6q+KHSZaCJMoacRP0NUJ8qRW\n/GiLWXZWshdiK1UonZxHV7WQbpXe8TKf13WNijN3VJ8+eMkaRYYhNEbU7PDj\n1oxv+srzmGhvbelVmWdqTEHTE5Np48yDEimmhHA9/rInUveiN3/HPcjHPyEE\n1g3jikayqcasw7POuoAp5G31xYI46lAPwEemMVHSjIy3Dj32ayoJjKouX/hL\ntwhtfIDOmC4MOmJ2tJgspdMkuHqxRnV2QEaXfM317La/3ath4sYxrubDD+Sx\ndO7W7WNrYurynQtK22xqIHGwY9RFgYTmHYg0aVdWBTXoulQbMhVk6cXHnnbH\nos8hWkbQqMUW9A4e1/CaSINISGEyGwKRRCJqggyCp3qtu7W18jvGPf5r8Zd1\nIuHHPyOrQ2WMwbRy7WZeMgGyq6Aj6JZ/5MMIZTE6JIeVMhJQR7+SeGUaa1pW\n+Q0o\r\n=zNty\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEYCIQDnFOC73UNKWniIqMUEk2hFyhmnCLTENIsxRodoyg9+OwIhAJ7zg2T4PvyiekGFq+BA0rpJwQhBdawdbJS63GqNdOAD"}]},"maintainers":[{"email":"hyytiala.jukka@gmail.com","name":"jukkah"},{"email":"mail@pascalpflaum.de","name":"pascal.pflaum"},{"email":"sascha@depold.com","name":"sdepold"}],"_npmUser":{"name":"papb","email":"papb1996@gmail.com"},"directories":{},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/umzug_3.0.0-beta.5_1589416704704_0.8076119942177218"},"_hasShrinkwrap":false},"3.0.0-beta.6":{"name":"umzug","version":"3.0.0-beta.6","description":"Framework-agnostic migration tool for Node","keywords":["migrate","migration","migrations","sequelize","database"],"main":"lib/index.js","dependencies":{"fs-jetpack":"^3.0.0","glob":"^7.1.6"},"devDependencies":{"@types/jest":"26.0.14","@typescript-eslint/eslint-plugin":"4.4.0","@typescript-eslint/parser":"4.4.0","del-cli":"3.0.1","eslint":"7.11.0","eslint-config-xo":"0.32.1","eslint-config-xo-typescript":"0.33.0","eslint-plugin-codegen":"0.13.2","eslint-plugin-import":"2.22.1","eslint-plugin-jest":"24.1.0","eslint-plugin-mocha":"8.0.0","eslint-plugin-prettier":"3.1.4","eslint-plugin-unicorn":"22.0.0","expect-type":"0.8.0","fs-syncer":"0.2.7","jest":"26.5.3","lodash":"4.17.20","np":"6.5.0","prettier":"2.1.2","sequelize":"5.21.6","sinon":"9.2.0","source-map-support":"0.5.19","sqlite3":"5.0.0","ts-jest":"26.4.1","type-fest":"0.17.0","typescript":"4.0.3","uuid":"8.3.1"},"scripts":{"build":"del-cli lib && tsc","lint":"eslint --ext .js,.ts . --max-warnings 0","prepare":"npm run build","release":"np --no-yarn --no-2fa","pretest":"del-cli test/generated","test":"jest"},"repository":{"type":"git","url":"git+https://github.com/sequelize/umzug.git"},"author":{"name":"Sascha Depold","email":"sascha@depold.com"},"contributors":[{"name":"Jukka Hyytiälä","email":"hyytiala.jukka@gmail.com"},{"name":"Pascal Pflaum","email":"mail@pascalpflaum.de"},{"name":"Pedro Augusto de Paula Barbosa","email":"papb1996@gmail.com"}],"license":"MIT","bugs":{"url":"https://github.com/sequelize/umzug/issues"},"homepage":"https://github.com/sequelize/umzug","engines":{"node":">=10.0.0"},"jest":{"preset":"ts-jest","globals":{"ts-jest":{"diagnostics":false}},"testEnvironment":"node","testMatch":["**/*test.ts"],"collectCoverageFrom":["src/**"]},"readme":"# Umzug [![Build Status](https://travis-ci.org/sequelize/umzug.svg?branch=master)](https://travis-ci.org/sequelize/umzug) [![npm version](https://badgen.net/npm/v/umzug)](https://www.npmjs.com/package/umzug)\n\nUmzug is a framework-agnostic migration tool for Node. It provides a clean API for running and rolling back tasks.\n\n_Note: master represents the next major version of umzug - v3 - which is currently in beta. For the stable version, please refer to the [v2.x branch](https://github.com/sequelize/umzug/tree/v2.x)._\n\n## Highlights\n\n* Written in TypeScript\n\t* Built-in typings\n\t* Auto-completion right in your IDE\n\t* Documentation right in your IDE\n* Programmatic API for migrations\n* Database agnostic\n* Supports logging of migration process\n* Supports multiple storages for migration data\n\n## Documentation\n\n### Minimal Example\n\nThe following example uses a Sqlite database through sequelize and persists the migration data in the database itself through the sequelize storage.\n\n```js\n// index.js\nconst { Sequelize } = require('sequelize');\nconst { Umzug, SequelizeStorage } = require('umzug');\n\nconst sequelize = new Sequelize({ dialect: 'sqlite', storage: './db.sqlite' });\n\nconst umzug = new Umzug({\n  migrations: { glob: 'migrations/*.js' },\n  context: sequelize.getQueryInterface(),\n  storage: new SequelizeStorage({ sequelize }),\n  logger: console,\n});\n\n(async () => {\n  // Checks migrations and run them if they are not already applied. To keep\n  // track of the executed migrations, a table (and sequelize model) called SequelizeMeta\n  // will be automatically created (if it doesn't exist already) and parsed.\n  await umzug.up();\n})();\n```\n\n```js\n// migrations/00_initial.js\n\nconst { Sequelize } = require('sequelize');\n\nasync function up({ context: queryInterface }) {\n\tawait queryInterface.createTable('users', {\n\t\tid: {\n\t\t\ttype: Sequelize.INTEGER,\n\t\t\tallowNull: false,\n\t\t\tprimaryKey: true\n\t\t},\n\t\tname: {\n\t\t\ttype: Sequelize.STRING,\n\t\t\tallowNull: false\n\t\t},\n\t\tcreatedAt: {\n\t\t\ttype: Sequelize.DATE,\n\t\t\tallowNull: false\n\t\t},\n\t\tupdatedAt: {\n\t\t\ttype: Sequelize.DATE,\n\t\t\tallowNull: false\n\t\t}\n\t});\n}\n\nasync function down({ context: queryInterface }) {\n\tawait queryInterface.dropTable('users');\n}\n\nmodule.exports = { up, down };\n```\n\nNote that we renamed the `context` argument to `queryInterface` for clarity. The `context` is whatever we specified when creating the Umzug instance in `index.js`.\n\n<details>\n<summary>You can also write your migrations in typescript by using `ts-node` in the entrypoint:</summary>\n\n```typescript\n// index.ts\nrequire('ts-node/register')\n\nimport { Sequelize } from 'sequelize';\nimport { Umzug, SequelizeStorage } from 'umzug';\n\nconst sequelize = new Sequelize({ dialect: 'sqlite', storage: './db.sqlite' });\n\nconst umzug = new Umzug({\n  migrations: { glob: 'migrations/*.ts' },\n  context: sequelize.getQueryInterface(),\n  storage: new SequelizeStorage({ sequelize }),\n  logger: console,\n});\n\n// export the type helper exposed by umzug, which will have the `context` argument typed correctly\nexport type Migration = typeof umzug._types.migration;\n\n(async () => {\n  await umzug.up();\n})();\n```\n\n```typescript\n// migrations/00_initial.ts\nimport type { Migration } from '..';\n\n// types will now be available for `queryInterface`\nexport const up: Migration = ({ context: queryInterface }) => queryInterface.createTable(...)\nexport const down: Migration = ({ context: queryInterface }) => queryInterface.dropTable(...)\n```\n</details>\n\nSee [these tests](./test/umzug.test.ts) for more examples of Umzug usage, including:\n\n- passing `ignore` and `cwd` parameters to the glob instructions\n- customising migrations ordering\n- finding migrations from multiple different directories\n- using non-js file extensions via a custom resolver, e.g. `.sql`\n\n### Usage\n\n#### Installation\n\nThe beta version of Umzug is available on npm by specifying the correct tag:\n\n```bash\nnpm install umzug@3.0.0-beta.6\n```\n\n#### Umzug instance\n\nIt is possible to configure an Umzug instance by passing an object to the constructor.\n\n```js\nconst { Umzug } = require('umzug');\nconst umzug = new Umzug({ /* ... options ... */ });\n```\n\nDetailed documentation for these options are in the `UmzugConstructorOptions` TypeScript interface, which can be found in [src/types.ts](./src/types.ts).\n\n#### Getting all pending migrations\n\nYou can get a list of pending (i.e. not yet executed) migrations with the `pending()` method:\n\n```js\nconst migrations = await umzug.pending();\n// returns an array of all pending migrations.\n```\n\n#### Getting all executed migrations\n\nYou can get a list of already executed migrations with the `executed()` method:\n\n```js\nconst migrations = await umzug.executed();\n// returns an array of all already executed migrations\n```\n\n#### Executing pending migrations\n\nThe `up` method can be used to execute all pending migrations.\n\n```js\nconst migrations = await umzug.up();\n// returns an array of all executed migrations\n```\n\nIt is also possible to pass the name of a migration in order to just run the migrations from the current state to the passed migration name (inclusive).\n\n```js\nawait umzug.up({ to: '20141101203500-task' });\n```\n\n\nRunning specific migrations while ignoring the right order, can be done like this:\n\n```js\nawait umzug.up({ migrations: ['20141101203500-task', '20141101203501-task-2'] });\n```\n\n#### Reverting executed migration\n\nThe `down` method can be used to revert the last executed migration.\n\n```js\nconst migration = await umzug.down();\n// reverts the last migration and returns it.\n```\n\nIt is possible to pass the name of a migration until which (inclusive) the migrations should be reverted. This allows the reverting of multiple migrations at once.\n\n```js\nconst migrations = await umzug.down({ to: '20141031080000-task' });\n// returns an array of all reverted migrations.\n```\n\nTo revert all migrations, you can pass 0 as the `to` parameter:\n\n```js\nawait umzug.down({ to: 0 });\n```\n\nReverting specific migrations while ignoring the right order, can be done like this:\n\n```js\nawait umzug.down({ migrations: ['20141101203500-task', '20141101203501-task-2'] });\n```\n\n### Migrations\n\nThere are two ways to specify migrations: via files or directly via an array of migrations.\n\n#### Migration files\n\nA migration file ideally exposes an `up` and a `down` async functions. They will perform the task of upgrading or downgrading the database.\n\n```js\nmodule.exports = {\n  async up() {\n    /* ... */\n  },\n  async down() {\n    /* ... */\n  }\n};\n```\n\nMigration files can be located anywhere - they will typically be loaded according to a glob pattern provided to the `Umzug` constructor.\n\n#### Direct migrations list\n\nYou can also specify directly a list of migrations to the `Umzug` constructor:\n\n```js\nconst { Umzug } = require('umzug');\n\nconst umzug = new Umzug({\n  migrations: [\n    {\n      // the name of the migration is mandatory\n      name: '00-first-migration',\n      async up({ context }) { /* ... */ },\n      async down({ context }) { /* ... */ }\n    },\n    {\n      name: '01-foo-bar-migration',\n      async up({ context }) { /* ... */ },\n      async down({ context }) { /* ... */ }\n    }\n  ],\n  context: sequelize.getQueryInterface(),\n  logger: console,\n});\n```\n\nTo load migrations in another format, you can use the `resolve` function:\n\n```js\nconst { Umzug } = require('umzug')\nconst { Sequelize } = require('sequelize')\nconst fs = require('fs')\n\nconst umzug = new Umzug({\n  migrations: {\n    glob: 'migrations/*.up.sql',\n    resolve: ({ name, path, context: sequelize }) => ({\n      name,\n      up: async () => {\n        const sql = fs.readFileSync(path).toString()\n        return sequelize.query(sql)\n      },\n      down: async () => {\n        // Get the corresponding `.down.sql` file to undo this migration\n        const sql = fs.readFileSync(path.replace('.up.sql', '.down.sql')).toString()\n        return sequelize.query(sql)\n      }\n    })\n  },\n  context: new Sequelize(...),\n  logger: console,\n});\n```\n\nYou can support mixed migration file types, and use umzug's default resolver for javascript/typescript:\n\n```js\nconst { Umzug } = require('umzug')\nconst { Sequelize } = require('sequelize')\nconst fs = require('fs')\n\nconst umzug = new Umzug({\n  migrations: {\n    glob: 'migrations/*.{js,ts,up.sql}',\n    resolve: (params) => {\n      if (!params.path.endsWith('.sql')) {\n        return Umzug.defaultResolver(params)\n      }\n      const { context: sequelize } = params\n      return {\n        name: params.name,\n        up: async () => {\n          const sql = fs.readFileSync(params.path).toString()\n          return sequelize.query(sql)\n        },\n        down: async () => {\n          // Get the corresponding `.down.sql` file to undo this migration\n          const sql = fs.readFileSync(params.path.replace('.up.sql', '.down.sql')).toString()\n          return sequelize.query(sql)\n        }\n      }\n    },\n  },\n  logger: console,\n  context: new Sequelize(...),\n});\n```\n\nThe glob syntax allows loading migrations from multiple locations:\n\n```js\nconst { Umzug } = require('umzug')\nconst { Sequelize } = require('sequelize')\n\nconst umzug = new Umzug({\n  migrations: {\n    glob: '{first-folder/*.js,second-folder-with-different-naming-convention/*.js}',\n  },\n  context: new Sequelize(...),\n  logger: console,\n});\n```\n\nNote on migration file sorting:\n\n- file matches, found using [glob](https://npmjs.com/package/glob), will be lexicographically sorted based on their paths\n  - so if your migrations are `one/m1.js`, `two/m2.js`, `three/m3.js`, the resultant order will be `one/m1.js`, `three/m3.js`, `two/m2.js`\n  - similarly, if your migrations are called `m1.js`, `m2.js`, ... `m10.js`, `m11.js`, the resultant ordering will be `m1.js`, `m10.js`, `m11.js`, ... `m2.js`\n- The easiest way to deal with this is to ensure your migrations appear in a single folder, and their paths match lexicographically with the order they should run in\n- If this isn't possible, the ordering can be customised using `.extend(...)` (see below)\n\n### Upgrading from v2.x\n\nThe Umzug class should be imported as a named import, i.e. `import { Umzug } from 'umzug'`.\n\nThe `MigrationMeta` type, which is returned by `umzug.executed()` and `umzug.pending()`, no longer has a `file` property - it has a `name` and *optional* `path` - since migrations are not necessarily bound to files on the file system.\n\nThe `migrations.glob` parameter replaces `path`, `pattern` and `traverseDirectories`. It can be used, in combination with `cwd` and `ignore` to do much more flexible file lookups. See https://npmjs.com/package/glob for more information on the syntax.\n\nThe `migrations.resolve` parameter replaces `customResolver`. Explicit support for `wrap` and `nameFormatter` has been removed - these can be easily implemented in a `resolve` function.\n\nThe constructor option `logging` is replaced by `logger` to allow for `warn` and `error` messages in future. NodeJS's global `console` object can be passed to this. To disable logging, replace `logging: false` with `logger: undefined`.\n\nThe `Umzug#execute` method is removed. Use `Umzug#up` or `Umzug#down`.\n\nThe options for `Umguz#up` and `Umzug#down` have changed:\n- `umzug.up({ to: 'some-name' })` and `umzug.down({ to: 'some-name' })` are still valid.\n- `umzug.up({ from: '...' })` and `umzug.down({ from: '...' })` are no longer supported. To run migrations out-of-order (which is not generally recommended), you can explicitly use `umzug.up({ migrations: ['...'] })` and `umzug.down({ migrations: ['...'] })`.\n- name matches must be exact. `umzug.up({ to: 'some-n' })` will no longer match a migration called `some-name`.\n- `umzug.down({ to: 0 })` is still valid but `umzug.up({ to: 0 })` is not.\n- `umzug.up({ migrations: ['m1', 'm2'] })` is still valid but the shorthand `umzug.up(['m1', 'm2'])` has been removed.\n- `umzug.down({ migrations: ['m1', 'm2'] })` is still valid but the shorthand `umzug.down(['m1', 'm2'])` has been removed.\n- `umzug.up({ migrations: ['m1', 'already-run'] })` will throw an error, if `already-run` is not found in the list of pending migrations.\n- `umzug.down({ migrations: ['m1', 'has-not-been-run'] })` will throw an error, if `has-not-been-run` is not found in the list of executed migrations.\n- `umzug.up({ migrations: ['m1', 'm2'], rerun: 'ALLOW' })` will re-apply migrations `m1` and `m2` even if they've already been run.\n- `umzug.up({ migrations: ['m1', 'm2'], rerun: 'SKIP' })` will skip migrations `m1` and `m2` if they've already been run.\n- `umzug.down({ migrations: ['m1', 'm2'], rerun: 'ALLOW' })` will \"revert\" migrations `m1` and `m2` even if they've never been run.\n- `umzug.down({ migrations: ['m1', 'm2'], rerun: 'SKIP' })` will skip reverting migrations `m1` and `m2` if they haven't been run or are already reverted.\n- `umzug.up({ migrations: ['m1', 'does-not-exist', 'm2'] })` will throw an error if the migration name is not found. Note that the error will be thrown and no migrations run unless _all_ migration names are found - whether or not `rerun: 'ALLOW'` is added.\n\nThe `context` parameter replaces `params`, and is passed in as a property to migration functions as an options object, alongs side `name` and `path`. This means the signature for migrations, which in v2 was `(context) => Promise<void>`, has changed slightly in v3, to `({ name, path, context }) => Promise<void>`. The `resolve` function can also be used to upgrade your umzug version to v3 when you have existing v2-compatible migrations:\n\n```js\nconst { Umzug } = require('umzug');\n\nconst umzug = new Umzug({\n  migrations: {\n    glob: 'migrations/umzug-v2-format/*.js',\n    resolve: ({name, path, context}) => {\n      // Adjust the migration from the new signature to the v2 signature, making easier to upgrade to v3\n      const migration = require(path)\n      return { up: async () => migration.up(context), down: async () => migration.down(context) }\n    }\n  },\n  context: sequelize.getQueryInterface(),\n  logger: console,\n});\n```\n\nSimilarly, you no longer need `migrationSorting`, you can use `Umzug#extend` to manipulate migration lists directly:\n\n```js\nconst { Umzug } = require('umzug');\n\nconst umzug =\n  new Umzug({\n    migrations: { glob: 'migrations/**/*.js' },\n    context: sequelize.getQueryInterface(),\n  })\n  .extend(migrations => migrations.sort((a, b) => b.path.localeCompare(a.path)));\n```\n\n### Storages\n\nStorages define where the migration data is stored.\n\n#### JSON Storage\n\nUsing `JSONStorage` will create a JSON file which will contain an array with all the executed migrations. You can specify the path to the file. The default for that is `umzug.json` in the working directory of the process.\n\nDetailed documentation for the options it can take are in the `JSONStorageConstructorOptions` TypeScript interface, which can be found in [src/storage/json.ts](./src/storage/json.ts).\n\n#### Memory Storage\n\nUsing `memoryStorage` will store migrations with an in-memory array. This can be useful for proof-of-concepts or tests, since it doesn't interact with databases or filesystems.\n\nIt doesn't take any options, just import the `memoryStorage` function and call it to return a storage instance:\n\n```typescript\nimport { Umzug, memoryStorage } from 'umzug'\n\nconst umzug = new Umzug({\n  migrations: ...,\n  storage: memoryStorage(),\n  logger: console,\n})\n```\n\n#### Sequelize Storage\n\nUsing `SequelizeStorage` will create a table in your SQL database called `SequelizeMeta` containing an entry for each executed migration. You will have to pass a configured instance of Sequelize or an existing Sequelize model. Optionally you can specify the model name, table name, or column name. All major Sequelize versions are supported.\n\nDetailed documentation for the options it can take are in the `_SequelizeStorageConstructorOptions` TypeScript interface, which can be found in [src/storage/sequelize.ts](./src/storage/sequelize.ts).\n\n#### MongoDB Storage\n\nUsing `MongoDBStorage` will create a collection in your MongoDB database called `migrations` containing an entry for each executed migration. You will have either to pass a MongoDB Driver Collection as `collection` property. Alternatively you can pass a established MongoDB Driver connection and a collection name.\n\nDetailed documentation for the options it can take are in the `MongoDBStorageConstructorOptions` TypeScript interface, which can be found in [src/storage/mongodb.ts](./src/storage/mongodb.ts).\n\n#### Custom\n\nIn order to use a custom storage, you can pass your storage instance to Umzug constructor.\n\n```js\nclass CustomStorage {\n  constructor(...) {...}\n  logMigration(...) {...}\n  unlogMigration(...) {...}\n  executed(...) {...}\n}\n\nconst umzug = new Umzug({ storage: new CustomStorage(...), logger: console })\n```\n\nYour instance must adhere to the [UmzugStorage](./src/storage/contract.ts) interface. If you're using TypeScript you can ensure this at compile time, and get IDE type hints by importing it:\n\n```typescript\nimport { UmzugStorage } from 'umzug'\n\nclass CustomStorage implements UmzugStorage {\n  /* ... */\n}\n```\n\n### Events\n\nUmzug is an [EventEmitter](https://nodejs.org/docs/latest-v10.x/api/events.html#events_class_eventemitter). Each of the following events will be called with `name` and `migration` as arguments. Events are a convenient place to implement application-specific logic that must run around each migration:\n\n* `migrating` - A migration is about to be executed.\n* `migrated` - A migration has successfully been executed.\n* `reverting` - A migration is about to be reverted.\n* `reverted` - A migration has successfully been reverted.\n\n## License\n\nSee the [LICENSE file](./LICENSE)\n","readmeFilename":"README.md","gitHead":"ce8aefc14812990ab07c3ef5276de18b58725365","_id":"umzug@3.0.0-beta.6","_nodeVersion":"12.14.1","_npmVersion":"6.14.7","dist":{"integrity":"sha512-wCHoAZJD04P44bW/amAkffeuMzQx2r/kDpzhNydXO/x7tEuB0/wvBv5kkUvtstYXGpZ7sl2zuUNAN/NzYfberw==","shasum":"e2ad369e9fa4a0194e3bad97e916e0414d4afeae","tarball":"https://registry.npmjs.org/umzug/-/umzug-3.0.0-beta.6.tgz","fileCount":28,"unpackedSize":69943,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJfg5QdCRA9TVsSAnZWagAAQ0gP/1qjVBtL/cjuOMkuwIKI\nv/R+mSeYr2Xl7tXrjzQNKo1N8JDkCQlZmDEvLw8PqUi5YurXiXbbgQGTXwCx\nnI4d1XpIgdWvJmMeUonF1Lo2FuvyVEEgLHl77Ztt0BgM/+wG4BiR8aH0zDBo\nm0LDSeXkacyuALwMnEwCu9FhgaCkpPOiYKttQ+2uZrgr6+1LxRD+gY/lthp3\n8oZ8oSvXQbz0huVwntv+WdSMMvVOcB83qufESDojLVLwDBE0RuHVlF8VbW+Q\nIDPuB66Cj01U5oWSYkdblpqx8E1Ek5BSMpHx5PUX/Zbkb6RfJ15pPjATG+hM\nmzmj6g21JYbX8I3UFTKnvSdxIhAWLVYb+yt1LH7J/uPb09pWQgZuUkwuGJRn\ne7wJn085CN90SjKKtHdjJZCmh1v9oeX3AYL/tVRo30U4dacZREU0RESK2te8\n/tDDN4wfGtVBpZotAUxBsgfXwpFBSFd14kJoVKHRe8P8pC4xMQIH9zg2qErj\nPenFZxvgZ3EXA4RKRo/K0IPqgo8QE3TtMsExxeQ/x9xssmU6BJCXMmMOvukW\nkt4gv90XZh8+nkmRkRZDBNczgQC/3XBn11p926uxBmTBdaC5TMxOUthUs260\ny4v48Ou3TjiANFubRjtVOAUeZcAIJPWAvpcCKqJ4J7MlwUEtdu4BfQ/hLPvY\nyxk6\r\n=KrLS\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIHoPw29gM3Y6DkKlF6SzoUADM+a0nE8AK4qpuDHugsE1AiEA5+gJS7iykt5GHPYaeF0BkW/CFP6cahmR9l++AkshIho="}]},"maintainers":[{"name":"pascal.pflaum","email":"mail@pascalpflaum.de"},{"name":"sdepold","email":"sascha@depold.com"},{"name":"sushantdhiman","email":"sushantdhiman@outlook.com"},{"name":"papb","email":"papb1996@gmail.com"}],"_npmUser":{"name":"papb","email":"papb1996@gmail.com"},"directories":{},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/umzug_3.0.0-beta.6_1602458653394_0.12363928572901473"},"_hasShrinkwrap":false},"3.0.0-beta.7":{"name":"umzug","version":"3.0.0-beta.7","description":"Framework-agnostic migration tool for Node","keywords":["migrate","migration","migrations","sequelize","database"],"main":"lib/index.js","dependencies":{"fs-jetpack":"^4.0.0","glob":"^7.1.6"},"devDependencies":{"@types/jest":"26.0.15","@types/uuid":"8.3.0","@typescript-eslint/eslint-plugin":"4.6.0","@typescript-eslint/parser":"4.6.0","del-cli":"3.0.1","eslint":"7.12.1","eslint-config-xo":"0.33.1","eslint-config-xo-typescript":"0.35.0","eslint-plugin-codegen":"0.14.0","eslint-plugin-import":"2.22.1","eslint-plugin-jest":"24.1.0","eslint-plugin-mocha":"8.0.0","eslint-plugin-prettier":"3.1.4","eslint-plugin-unicorn":"22.0.0","expect-type":"0.9.0","fs-syncer":"0.3.0","jest":"26.6.1","lodash":"4.17.20","np":"6.5.0","prettier":"2.1.2","sequelize":"5.21.6","sinon":"9.2.1","source-map-support":"0.5.19","sqlite3":"5.0.0","ts-jest":"26.4.3","type-fest":"0.18.0","typescript":"4.0.5","uuid":"8.3.1"},"scripts":{"build":"del-cli lib && tsc","lint":"eslint --ext .js,.ts . --max-warnings 0","prepare":"npm run build","release":"np --no-yarn --no-2fa","pretest":"del-cli test/generated","test":"jest"},"repository":{"type":"git","url":"git+https://github.com/sequelize/umzug.git"},"author":{"name":"Sascha Depold","email":"sascha@depold.com"},"contributors":[{"name":"Jukka Hyytiälä","email":"hyytiala.jukka@gmail.com"},{"name":"Pascal Pflaum","email":"mail@pascalpflaum.de"},{"name":"Pedro Augusto de Paula Barbosa","email":"papb1996@gmail.com"}],"license":"MIT","bugs":{"url":"https://github.com/sequelize/umzug/issues"},"homepage":"https://github.com/sequelize/umzug","engines":{"node":">=10.0.0"},"jest":{"preset":"ts-jest","globals":{"ts-jest":{"diagnostics":false}},"testEnvironment":"node","testMatch":["**/*test.ts"],"collectCoverageFrom":["src/**"]},"readme":"# Umzug\r\n\r\n[![Build Status](https://badgen.net/github/checks/sequelize/umzug/master)](https://github.com/sequelize/umzug/actions?query=workflow%3ACI)\r\n[![npm (stable)](https://badgen.net/npm/v/umzug)](https://www.npmjs.com/package/umzug)\r\n[![npm (beta)](https://badgen.net/npm/v/umzug/beta)](https://www.npmjs.com/package/umzug/v/beta)\r\n[![npm (downloads)](https://badgen.net/npm/dm/umzug)](https://npmjs.com/package/umzug)\r\n\r\nUmzug is a framework-agnostic migration tool for Node. It provides a clean API for running and rolling back tasks.\r\n\r\n_Note: master represents the next major version of umzug - v3 - which is currently in beta. For the stable version, please refer to the [v2.x branch](https://github.com/sequelize/umzug/tree/v2.x)._\r\n\r\nTo install the v3-beta package:\r\n\r\n```\r\nnpm install umzug@beta\r\n```\r\n\r\nTo install the stable package (v2.x):\r\n\r\n```\r\nnpm install umzug\r\n```\r\n\r\n## Highlights\r\n\r\n* Written in TypeScript\r\n\t* Built-in typings\r\n\t* Auto-completion right in your IDE\r\n\t* Documentation right in your IDE\r\n* Programmatic API for migrations\r\n* Database agnostic\r\n* Supports logging of migration process\r\n* Supports multiple storages for migration data\r\n\r\n## Documentation\r\n\r\n### Minimal Example\r\n\r\nThe following example uses a Sqlite database through sequelize and persists the migration data in the database itself through the sequelize storage.\r\n\r\n```js\r\n// index.js\r\nconst { Sequelize } = require('sequelize');\r\nconst { Umzug, SequelizeStorage } = require('umzug');\r\n\r\nconst sequelize = new Sequelize({ dialect: 'sqlite', storage: './db.sqlite' });\r\n\r\nconst umzug = new Umzug({\r\n  migrations: { glob: 'migrations/*.js' },\r\n  context: sequelize.getQueryInterface(),\r\n  storage: new SequelizeStorage({ sequelize }),\r\n  logger: console,\r\n});\r\n\r\n(async () => {\r\n  // Checks migrations and run them if they are not already applied. To keep\r\n  // track of the executed migrations, a table (and sequelize model) called SequelizeMeta\r\n  // will be automatically created (if it doesn't exist already) and parsed.\r\n  await umzug.up();\r\n})();\r\n```\r\n\r\n```js\r\n// migrations/00_initial.js\r\n\r\nconst { Sequelize } = require('sequelize');\r\n\r\nasync function up({ context: queryInterface }) {\r\n\tawait queryInterface.createTable('users', {\r\n\t\tid: {\r\n\t\t\ttype: Sequelize.INTEGER,\r\n\t\t\tallowNull: false,\r\n\t\t\tprimaryKey: true\r\n\t\t},\r\n\t\tname: {\r\n\t\t\ttype: Sequelize.STRING,\r\n\t\t\tallowNull: false\r\n\t\t},\r\n\t\tcreatedAt: {\r\n\t\t\ttype: Sequelize.DATE,\r\n\t\t\tallowNull: false\r\n\t\t},\r\n\t\tupdatedAt: {\r\n\t\t\ttype: Sequelize.DATE,\r\n\t\t\tallowNull: false\r\n\t\t}\r\n\t});\r\n}\r\n\r\nasync function down({ context: queryInterface }) {\r\n\tawait queryInterface.dropTable('users');\r\n}\r\n\r\nmodule.exports = { up, down };\r\n```\r\n\r\nNote that we renamed the `context` argument to `queryInterface` for clarity. The `context` is whatever we specified when creating the Umzug instance in `index.js`.\r\n\r\n<details>\r\n<summary>You can also write your migrations in typescript by using `ts-node` in the entrypoint:</summary>\r\n\r\n```typescript\r\n// index.ts\r\nrequire('ts-node/register')\r\n\r\nimport { Sequelize } from 'sequelize';\r\nimport { Umzug, SequelizeStorage } from 'umzug';\r\n\r\nconst sequelize = new Sequelize({ dialect: 'sqlite', storage: './db.sqlite' });\r\n\r\nconst umzug = new Umzug({\r\n  migrations: { glob: 'migrations/*.ts' },\r\n  context: sequelize.getQueryInterface(),\r\n  storage: new SequelizeStorage({ sequelize }),\r\n  logger: console,\r\n});\r\n\r\n// export the type helper exposed by umzug, which will have the `context` argument typed correctly\r\nexport type Migration = typeof umzug._types.migration;\r\n\r\n(async () => {\r\n  await umzug.up();\r\n})();\r\n```\r\n\r\n```typescript\r\n// migrations/00_initial.ts\r\nimport type { Migration } from '..';\r\n\r\n// types will now be available for `queryInterface`\r\nexport const up: Migration = ({ context: queryInterface }) => queryInterface.createTable(...)\r\nexport const down: Migration = ({ context: queryInterface }) => queryInterface.dropTable(...)\r\n```\r\n</details>\r\n\r\nSee [these tests](./test/umzug.test.ts) for more examples of Umzug usage, including:\r\n\r\n- passing `ignore` and `cwd` parameters to the glob instructions\r\n- customising migrations ordering\r\n- finding migrations from multiple different directories\r\n- using non-js file extensions via a custom resolver, e.g. `.sql`\r\n\r\n### Usage\r\n\r\n#### Installation\r\n\r\nThe beta version of Umzug is available on npm by specifying the correct tag:\r\n\r\n```bash\r\nnpm install umzug@beta\r\n```\r\n\r\n#### Umzug instance\r\n\r\nIt is possible to configure an Umzug instance by passing an object to the constructor.\r\n\r\n```js\r\nconst { Umzug } = require('umzug');\r\nconst umzug = new Umzug({ /* ... options ... */ });\r\n```\r\n\r\nDetailed documentation for these options are in the `UmzugConstructorOptions` TypeScript interface, which can be found in [src/types.ts](./src/types.ts).\r\n\r\n#### Getting all pending migrations\r\n\r\nYou can get a list of pending (i.e. not yet executed) migrations with the `pending()` method:\r\n\r\n```js\r\nconst migrations = await umzug.pending();\r\n// returns an array of all pending migrations.\r\n```\r\n\r\n#### Getting all executed migrations\r\n\r\nYou can get a list of already executed migrations with the `executed()` method:\r\n\r\n```js\r\nconst migrations = await umzug.executed();\r\n// returns an array of all already executed migrations\r\n```\r\n\r\n#### Executing pending migrations\r\n\r\nThe `up` method can be used to execute all pending migrations.\r\n\r\n```js\r\nconst migrations = await umzug.up();\r\n// returns an array of all executed migrations\r\n```\r\n\r\nIt is also possible to pass the name of a migration in order to just run the migrations from the current state to the passed migration name (inclusive).\r\n\r\n```js\r\nawait umzug.up({ to: '20141101203500-task' });\r\n```\r\n\r\n\r\nRunning specific migrations while ignoring the right order, can be done like this:\r\n\r\n```js\r\nawait umzug.up({ migrations: ['20141101203500-task', '20141101203501-task-2'] });\r\n```\r\n\r\n#### Reverting executed migration\r\n\r\nThe `down` method can be used to revert the last executed migration.\r\n\r\n```js\r\nconst migration = await umzug.down();\r\n// reverts the last migration and returns it.\r\n```\r\n\r\nIt is possible to pass the name of a migration until which (inclusive) the migrations should be reverted. This allows the reverting of multiple migrations at once.\r\n\r\n```js\r\nconst migrations = await umzug.down({ to: '20141031080000-task' });\r\n// returns an array of all reverted migrations.\r\n```\r\n\r\nTo revert all migrations, you can pass 0 as the `to` parameter:\r\n\r\n```js\r\nawait umzug.down({ to: 0 });\r\n```\r\n\r\nReverting specific migrations while ignoring the right order, can be done like this:\r\n\r\n```js\r\nawait umzug.down({ migrations: ['20141101203500-task', '20141101203501-task-2'] });\r\n```\r\n\r\n### Migrations\r\n\r\nThere are two ways to specify migrations: via files or directly via an array of migrations.\r\n\r\n#### Migration files\r\n\r\nA migration file ideally exposes an `up` and a `down` async functions. They will perform the task of upgrading or downgrading the database.\r\n\r\n```js\r\nmodule.exports = {\r\n  async up() {\r\n    /* ... */\r\n  },\r\n  async down() {\r\n    /* ... */\r\n  }\r\n};\r\n```\r\n\r\nMigration files can be located anywhere - they will typically be loaded according to a glob pattern provided to the `Umzug` constructor.\r\n\r\n#### Direct migrations list\r\n\r\nYou can also specify directly a list of migrations to the `Umzug` constructor:\r\n\r\n```js\r\nconst { Umzug } = require('umzug');\r\n\r\nconst umzug = new Umzug({\r\n  migrations: [\r\n    {\r\n      // the name of the migration is mandatory\r\n      name: '00-first-migration',\r\n      async up({ context }) { /* ... */ },\r\n      async down({ context }) { /* ... */ }\r\n    },\r\n    {\r\n      name: '01-foo-bar-migration',\r\n      async up({ context }) { /* ... */ },\r\n      async down({ context }) { /* ... */ }\r\n    }\r\n  ],\r\n  context: sequelize.getQueryInterface(),\r\n  logger: console,\r\n});\r\n```\r\n\r\nTo load migrations in another format, you can use the `resolve` function:\r\n\r\n```js\r\nconst { Umzug } = require('umzug')\r\nconst { Sequelize } = require('sequelize')\r\nconst fs = require('fs')\r\n\r\nconst umzug = new Umzug({\r\n  migrations: {\r\n    glob: 'migrations/*.up.sql',\r\n    resolve: ({ name, path, context: sequelize }) => ({\r\n      name,\r\n      up: async () => {\r\n        const sql = fs.readFileSync(path).toString()\r\n        return sequelize.query(sql)\r\n      },\r\n      down: async () => {\r\n        // Get the corresponding `.down.sql` file to undo this migration\r\n        const sql = fs.readFileSync(path.replace('.up.sql', '.down.sql')).toString()\r\n        return sequelize.query(sql)\r\n      }\r\n    })\r\n  },\r\n  context: new Sequelize(...),\r\n  logger: console,\r\n});\r\n```\r\n\r\nYou can support mixed migration file types, and use umzug's default resolver for javascript/typescript:\r\n\r\n```js\r\nconst { Umzug } = require('umzug')\r\nconst { Sequelize } = require('sequelize')\r\nconst fs = require('fs')\r\n\r\nconst umzug = new Umzug({\r\n  migrations: {\r\n    glob: 'migrations/*.{js,ts,up.sql}',\r\n    resolve: (params) => {\r\n      if (!params.path.endsWith('.sql')) {\r\n        return Umzug.defaultResolver(params)\r\n      }\r\n      const { context: sequelize } = params\r\n      return {\r\n        name: params.name,\r\n        up: async () => {\r\n          const sql = fs.readFileSync(params.path).toString()\r\n          return sequelize.query(sql)\r\n        },\r\n        down: async () => {\r\n          // Get the corresponding `.down.sql` file to undo this migration\r\n          const sql = fs.readFileSync(params.path.replace('.up.sql', '.down.sql')).toString()\r\n          return sequelize.query(sql)\r\n        }\r\n      }\r\n    },\r\n  },\r\n  logger: console,\r\n  context: new Sequelize(...),\r\n});\r\n```\r\n\r\nThe glob syntax allows loading migrations from multiple locations:\r\n\r\n```js\r\nconst { Umzug } = require('umzug')\r\nconst { Sequelize } = require('sequelize')\r\n\r\nconst umzug = new Umzug({\r\n  migrations: {\r\n    glob: '{first-folder/*.js,second-folder-with-different-naming-convention/*.js}',\r\n  },\r\n  context: new Sequelize(...),\r\n  logger: console,\r\n});\r\n```\r\n\r\nNote on migration file sorting:\r\n\r\n- file matches, found using [glob](https://npmjs.com/package/glob), will be lexicographically sorted based on their paths\r\n  - so if your migrations are `one/m1.js`, `two/m2.js`, `three/m3.js`, the resultant order will be `one/m1.js`, `three/m3.js`, `two/m2.js`\r\n  - similarly, if your migrations are called `m1.js`, `m2.js`, ... `m10.js`, `m11.js`, the resultant ordering will be `m1.js`, `m10.js`, `m11.js`, ... `m2.js`\r\n- The easiest way to deal with this is to ensure your migrations appear in a single folder, and their paths match lexicographically with the order they should run in\r\n- If this isn't possible, the ordering can be customised using `.extend(...)` (see below)\r\n\r\n### Upgrading from v2.x\r\n\r\nThe Umzug class should be imported as a named import, i.e. `import { Umzug } from 'umzug'`.\r\n\r\nThe `MigrationMeta` type, which is returned by `umzug.executed()` and `umzug.pending()`, no longer has a `file` property - it has a `name` and *optional* `path` - since migrations are not necessarily bound to files on the file system.\r\n\r\nThe `migrations.glob` parameter replaces `path`, `pattern` and `traverseDirectories`. It can be used, in combination with `cwd` and `ignore` to do much more flexible file lookups. See https://npmjs.com/package/glob for more information on the syntax.\r\n\r\nThe `migrations.resolve` parameter replaces `customResolver`. Explicit support for `wrap` and `nameFormatter` has been removed - these can be easily implemented in a `resolve` function.\r\n\r\nThe constructor option `logging` is replaced by `logger` to allow for `warn` and `error` messages in future. NodeJS's global `console` object can be passed to this. To disable logging, replace `logging: false` with `logger: undefined`.\r\n\r\nThe `Umzug#execute` method is removed. Use `Umzug#up` or `Umzug#down`.\r\n\r\nThe options for `Umguz#up` and `Umzug#down` have changed:\r\n- `umzug.up({ to: 'some-name' })` and `umzug.down({ to: 'some-name' })` are still valid.\r\n- `umzug.up({ from: '...' })` and `umzug.down({ from: '...' })` are no longer supported. To run migrations out-of-order (which is not generally recommended), you can explicitly use `umzug.up({ migrations: ['...'] })` and `umzug.down({ migrations: ['...'] })`.\r\n- name matches must be exact. `umzug.up({ to: 'some-n' })` will no longer match a migration called `some-name`.\r\n- `umzug.down({ to: 0 })` is still valid but `umzug.up({ to: 0 })` is not.\r\n- `umzug.up({ migrations: ['m1', 'm2'] })` is still valid but the shorthand `umzug.up(['m1', 'm2'])` has been removed.\r\n- `umzug.down({ migrations: ['m1', 'm2'] })` is still valid but the shorthand `umzug.down(['m1', 'm2'])` has been removed.\r\n- `umzug.up({ migrations: ['m1', 'already-run'] })` will throw an error, if `already-run` is not found in the list of pending migrations.\r\n- `umzug.down({ migrations: ['m1', 'has-not-been-run'] })` will throw an error, if `has-not-been-run` is not found in the list of executed migrations.\r\n- `umzug.up({ migrations: ['m1', 'm2'], rerun: 'ALLOW' })` will re-apply migrations `m1` and `m2` even if they've already been run.\r\n- `umzug.up({ migrations: ['m1', 'm2'], rerun: 'SKIP' })` will skip migrations `m1` and `m2` if they've already been run.\r\n- `umzug.down({ migrations: ['m1', 'm2'], rerun: 'ALLOW' })` will \"revert\" migrations `m1` and `m2` even if they've never been run.\r\n- `umzug.down({ migrations: ['m1', 'm2'], rerun: 'SKIP' })` will skip reverting migrations `m1` and `m2` if they haven't been run or are already reverted.\r\n- `umzug.up({ migrations: ['m1', 'does-not-exist', 'm2'] })` will throw an error if the migration name is not found. Note that the error will be thrown and no migrations run unless _all_ migration names are found - whether or not `rerun: 'ALLOW'` is added.\r\n\r\nThe `context` parameter replaces `params`, and is passed in as a property to migration functions as an options object, alongs side `name` and `path`. This means the signature for migrations, which in v2 was `(context) => Promise<void>`, has changed slightly in v3, to `({ name, path, context }) => Promise<void>`. The `resolve` function can also be used to upgrade your umzug version to v3 when you have existing v2-compatible migrations:\r\n\r\n```js\r\nconst { Umzug } = require('umzug');\r\n\r\nconst umzug = new Umzug({\r\n  migrations: {\r\n    glob: 'migrations/umzug-v2-format/*.js',\r\n    resolve: ({name, path, context}) => {\r\n      // Adjust the migration from the new signature to the v2 signature, making easier to upgrade to v3\r\n      const migration = require(path)\r\n      return { up: async () => migration.up(context), down: async () => migration.down(context) }\r\n    }\r\n  },\r\n  context: sequelize.getQueryInterface(),\r\n  logger: console,\r\n});\r\n```\r\n\r\nSimilarly, you no longer need `migrationSorting`, you can use `Umzug#extend` to manipulate migration lists directly:\r\n\r\n```js\r\nconst { Umzug } = require('umzug');\r\n\r\nconst umzug =\r\n  new Umzug({\r\n    migrations: { glob: 'migrations/**/*.js' },\r\n    context: sequelize.getQueryInterface(),\r\n  })\r\n  .extend(migrations => migrations.sort((a, b) => b.path.localeCompare(a.path)));\r\n```\r\n\r\n### Storages\r\n\r\nStorages define where the migration data is stored.\r\n\r\n#### JSON Storage\r\n\r\nUsing `JSONStorage` will create a JSON file which will contain an array with all the executed migrations. You can specify the path to the file. The default for that is `umzug.json` in the working directory of the process.\r\n\r\nDetailed documentation for the options it can take are in the `JSONStorageConstructorOptions` TypeScript interface, which can be found in [src/storage/json.ts](./src/storage/json.ts).\r\n\r\n#### Memory Storage\r\n\r\nUsing `memoryStorage` will store migrations with an in-memory array. This can be useful for proof-of-concepts or tests, since it doesn't interact with databases or filesystems.\r\n\r\nIt doesn't take any options, just import the `memoryStorage` function and call it to return a storage instance:\r\n\r\n```typescript\r\nimport { Umzug, memoryStorage } from 'umzug'\r\n\r\nconst umzug = new Umzug({\r\n  migrations: ...,\r\n  storage: memoryStorage(),\r\n  logger: console,\r\n})\r\n```\r\n\r\n#### Sequelize Storage\r\n\r\nUsing `SequelizeStorage` will create a table in your SQL database called `SequelizeMeta` containing an entry for each executed migration. You will have to pass a configured instance of Sequelize or an existing Sequelize model. Optionally you can specify the model name, table name, or column name. All major Sequelize versions are supported.\r\n\r\nDetailed documentation for the options it can take are in the `_SequelizeStorageConstructorOptions` TypeScript interface, which can be found in [src/storage/sequelize.ts](./src/storage/sequelize.ts).\r\n\r\n#### MongoDB Storage\r\n\r\nUsing `MongoDBStorage` will create a collection in your MongoDB database called `migrations` containing an entry for each executed migration. You will have either to pass a MongoDB Driver Collection as `collection` property. Alternatively you can pass a established MongoDB Driver connection and a collection name.\r\n\r\nDetailed documentation for the options it can take are in the `MongoDBStorageConstructorOptions` TypeScript interface, which can be found in [src/storage/mongodb.ts](./src/storage/mongodb.ts).\r\n\r\n#### Custom\r\n\r\nIn order to use a custom storage, you can pass your storage instance to Umzug constructor.\r\n\r\n```js\r\nclass CustomStorage {\r\n  constructor(...) {...}\r\n  logMigration(...) {...}\r\n  unlogMigration(...) {...}\r\n  executed(...) {...}\r\n}\r\n\r\nconst umzug = new Umzug({ storage: new CustomStorage(...), logger: console })\r\n```\r\n\r\nYour instance must adhere to the [UmzugStorage](./src/storage/contract.ts) interface. If you're using TypeScript you can ensure this at compile time, and get IDE type hints by importing it:\r\n\r\n```typescript\r\nimport { UmzugStorage } from 'umzug'\r\n\r\nclass CustomStorage implements UmzugStorage {\r\n  /* ... */\r\n}\r\n```\r\n\r\n### Events\r\n\r\nUmzug is an [EventEmitter](https://nodejs.org/docs/latest-v10.x/api/events.html#events_class_eventemitter). Each of the following events will be called with `name` and `migration` as arguments. Events are a convenient place to implement application-specific logic that must run around each migration:\r\n\r\n* `migrating` - A migration is about to be executed.\r\n* `migrated` - A migration has successfully been executed.\r\n* `reverting` - A migration is about to be reverted.\r\n* `reverted` - A migration has successfully been reverted.\r\n\r\n## License\r\n\r\nSee the [LICENSE file](./LICENSE)\r\n","readmeFilename":"README.md","gitHead":"07a1c1ffd9a3ec1f446312fa7513eaf67cba604f","_id":"umzug@3.0.0-beta.7","_nodeVersion":"12.18.0","_npmVersion":"6.14.8","dist":{"integrity":"sha512-m1WXs74dN6TYU0edehq+9NGmP9eoogHH/XG32pQ8SsJ5QzFmECnRUdkaH22QrZkhdOadzqC9L5Je/m5+wAhExQ==","shasum":"40e4136a1d5e32b37fa10c2d526724c2a2ecdcf5","tarball":"https://registry.npmjs.org/umzug/-/umzug-3.0.0-beta.7.tgz","fileCount":28,"unpackedSize":72584,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJfnbEqCRA9TVsSAnZWagAAUHUP/ifU4Qa6bwCAPh91yRYL\nPZh6cLTcS8qugUhIlCP+ckpMypA8USFe8U5xa6/cyQyLivbIf9fh2NEpGPi2\nQVmNa0aobKu+IruE8VLlOBp7d9BFT8YlX7VtWVtcM1I6R2PF/xtKm+oAgTG1\nItggEkOHU1FTsFE5sBiE+ko9aa5ahCy+im8lnYpT5SfEXg0IyPECy8Ax2CaG\nIyl5IqzpYK9B/C67xpA2vkViicX+bwabO7oNLrFgkl5pjYi1YgkMSOkKlkh3\nlR7X1sOWHQGyB0JdoL/itBmWBzdxDt03vsHTwhrPfsw5Zt81sBQnrJgPHJCy\nTOuq12MLUHv3DEU+EEqxQGlBH41QxV6RudRVK7r7cvZWxjnUBHxLjCRFtWyj\nyFzX9rxPOJILackJSZsz3ALAkfvBOZ8V8QW7B+apCs3pE4yN6MZQmUjkElfg\nEsbFsYx9ncMbMKM+isolPX3sATyAvCPkG7xGmcqDLfRSKg+RrWF2bp5aiT1n\nuHYWAcZeRYx6JPQ2UN3/K+l3QdR6LOreeWS/91N0AF5q5ppYPlci398/lX0d\ngPi0ytrgouW06q6uEmOXI+UHAs0j66jYx5J2cJ+JEDSz9t7iwQ2fhz3xxNzX\n9HicppTN/VtjUpJqnyFrmB7ap+j4C4JqbubzXi6bwM/q7RW3/E5/4oMXq0Cy\nxgRf\r\n=c/F2\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIQDYDxJyAaKCf+wV2Z74Eyq4OOPpPpmFv2txbh8AJw8PdgIgPtbjwsAaCzKIYz7b6STg6URt01db7lC/QkRXlpOO14Q="}]},"maintainers":[{"name":"pascal.pflaum","email":"mail@pascalpflaum.de"},{"name":"sdepold","email":"sascha@depold.com"},{"name":"sushantdhiman","email":"sushantdhiman@outlook.com"},{"name":"papb","email":"papb1996@gmail.com"},{"name":"mmkale","email":"mmkal1@outlook.com"}],"_npmUser":{"name":"mmkale","email":"mmkal1@outlook.com"},"directories":{},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/umzug_3.0.0-beta.7_1604170026037_0.7047502292183068"},"_hasShrinkwrap":false},"3.0.0-beta.8":{"name":"umzug","version":"3.0.0-beta.8","description":"Framework-agnostic migration tool for Node","keywords":["migrate","migration","migrations","sequelize","database"],"main":"lib/index.js","dependencies":{"fs-jetpack":"^4.0.0","glob":"^7.1.6"},"devDependencies":{"@types/jest":"26.0.15","@types/uuid":"8.3.0","@typescript-eslint/eslint-plugin":"4.6.0","@typescript-eslint/parser":"4.6.0","del-cli":"3.0.1","eslint":"7.12.1","eslint-config-xo":"0.33.1","eslint-config-xo-typescript":"0.35.0","eslint-plugin-codegen":"0.14.0","eslint-plugin-import":"2.22.1","eslint-plugin-jest":"24.1.0","eslint-plugin-mocha":"8.0.0","eslint-plugin-prettier":"3.1.4","eslint-plugin-unicorn":"22.0.0","expect-type":"0.9.0","fs-syncer":"0.3.0","jest":"26.6.1","lodash":"4.17.20","np":"6.5.0","prettier":"2.1.2","sequelize":"5.21.6","sinon":"9.2.1","source-map-support":"0.5.19","sqlite3":"5.0.0","ts-jest":"26.4.3","type-fest":"0.18.0","typescript":"4.0.5","uuid":"8.3.1"},"scripts":{"build":"del-cli lib && tsc","lint":"eslint --ext .js,.ts . --max-warnings 0","prepare":"npm run build","release":"np --no-yarn --no-2fa","pretest":"del-cli test/generated","test":"jest"},"repository":{"type":"git","url":"git+https://github.com/sequelize/umzug.git"},"author":{"name":"Sascha Depold","email":"sascha@depold.com"},"contributors":[{"name":"Jukka Hyytiälä","email":"hyytiala.jukka@gmail.com"},{"name":"Pascal Pflaum","email":"mail@pascalpflaum.de"},{"name":"Pedro Augusto de Paula Barbosa","email":"papb1996@gmail.com"}],"license":"MIT","bugs":{"url":"https://github.com/sequelize/umzug/issues"},"homepage":"https://github.com/sequelize/umzug","engines":{"node":">=10.0.0"},"jest":{"preset":"ts-jest","globals":{"ts-jest":{"diagnostics":false}},"testEnvironment":"node","testMatch":["**/*test.ts"],"collectCoverageFrom":["src/**"]},"readme":"# Umzug\r\n\r\n[![Build Status](https://badgen.net/github/checks/sequelize/umzug/master)](https://github.com/sequelize/umzug/actions?query=workflow%3ACI)\r\n[![npm (stable)](https://badgen.net/npm/v/umzug)](https://www.npmjs.com/package/umzug)\r\n[![npm (beta)](https://badgen.net/npm/v/umzug/beta)](https://www.npmjs.com/package/umzug/v/beta)\r\n[![npm (downloads)](https://badgen.net/npm/dm/umzug)](https://npmjs.com/package/umzug)\r\n\r\nUmzug is a framework-agnostic migration tool for Node. It provides a clean API for running and rolling back tasks.\r\n\r\n_Note: master represents the next major version of umzug - v3 - which is currently in beta. For the stable version, please refer to the [v2.x branch](https://github.com/sequelize/umzug/tree/v2.x)._\r\n\r\nTo install the v3-beta package:\r\n\r\n```\r\nnpm install umzug@beta\r\n```\r\n\r\nTo install the stable package (v2.x):\r\n\r\n```\r\nnpm install umzug\r\n```\r\n\r\n## Highlights\r\n\r\n* Written in TypeScript\r\n\t* Built-in typings\r\n\t* Auto-completion right in your IDE\r\n\t* Documentation right in your IDE\r\n* Programmatic API for migrations\r\n* Database agnostic\r\n* Supports logging of migration process\r\n* Supports multiple storages for migration data\r\n\r\n## Documentation\r\n\r\n### Minimal Example\r\n\r\nThe following example uses a Sqlite database through sequelize and persists the migration data in the database itself through the sequelize storage.\r\n\r\n```js\r\n// index.js\r\nconst { Sequelize } = require('sequelize');\r\nconst { Umzug, SequelizeStorage } = require('umzug');\r\n\r\nconst sequelize = new Sequelize({ dialect: 'sqlite', storage: './db.sqlite' });\r\n\r\nconst umzug = new Umzug({\r\n  migrations: { glob: 'migrations/*.js' },\r\n  context: sequelize.getQueryInterface(),\r\n  storage: new SequelizeStorage({ sequelize }),\r\n  logger: console,\r\n});\r\n\r\n(async () => {\r\n  // Checks migrations and run them if they are not already applied. To keep\r\n  // track of the executed migrations, a table (and sequelize model) called SequelizeMeta\r\n  // will be automatically created (if it doesn't exist already) and parsed.\r\n  await umzug.up();\r\n})();\r\n```\r\n\r\n```js\r\n// migrations/00_initial.js\r\n\r\nconst { Sequelize } = require('sequelize');\r\n\r\nasync function up({ context: queryInterface }) {\r\n\tawait queryInterface.createTable('users', {\r\n\t\tid: {\r\n\t\t\ttype: Sequelize.INTEGER,\r\n\t\t\tallowNull: false,\r\n\t\t\tprimaryKey: true\r\n\t\t},\r\n\t\tname: {\r\n\t\t\ttype: Sequelize.STRING,\r\n\t\t\tallowNull: false\r\n\t\t},\r\n\t\tcreatedAt: {\r\n\t\t\ttype: Sequelize.DATE,\r\n\t\t\tallowNull: false\r\n\t\t},\r\n\t\tupdatedAt: {\r\n\t\t\ttype: Sequelize.DATE,\r\n\t\t\tallowNull: false\r\n\t\t}\r\n\t});\r\n}\r\n\r\nasync function down({ context: queryInterface }) {\r\n\tawait queryInterface.dropTable('users');\r\n}\r\n\r\nmodule.exports = { up, down };\r\n```\r\n\r\nNote that we renamed the `context` argument to `queryInterface` for clarity. The `context` is whatever we specified when creating the Umzug instance in `index.js`.\r\n\r\n<details>\r\n<summary>You can also write your migrations in typescript by using `ts-node` in the entrypoint:</summary>\r\n\r\n```typescript\r\n// index.ts\r\nrequire('ts-node/register')\r\n\r\nimport { Sequelize } from 'sequelize';\r\nimport { Umzug, SequelizeStorage } from 'umzug';\r\n\r\nconst sequelize = new Sequelize({ dialect: 'sqlite', storage: './db.sqlite' });\r\n\r\nconst umzug = new Umzug({\r\n  migrations: { glob: 'migrations/*.ts' },\r\n  context: sequelize.getQueryInterface(),\r\n  storage: new SequelizeStorage({ sequelize }),\r\n  logger: console,\r\n});\r\n\r\n// export the type helper exposed by umzug, which will have the `context` argument typed correctly\r\nexport type Migration = typeof umzug._types.migration;\r\n\r\n(async () => {\r\n  await umzug.up();\r\n})();\r\n```\r\n\r\n```typescript\r\n// migrations/00_initial.ts\r\nimport type { Migration } from '..';\r\n\r\n// types will now be available for `queryInterface`\r\nexport const up: Migration = ({ context: queryInterface }) => queryInterface.createTable(...)\r\nexport const down: Migration = ({ context: queryInterface }) => queryInterface.dropTable(...)\r\n```\r\n</details>\r\n\r\nSee [these tests](./test/umzug.test.ts) for more examples of Umzug usage, including:\r\n\r\n- passing `ignore` and `cwd` parameters to the glob instructions\r\n- customising migrations ordering\r\n- finding migrations from multiple different directories\r\n- using non-js file extensions via a custom resolver, e.g. `.sql`\r\n\r\n### Usage\r\n\r\n#### Installation\r\n\r\nThe beta version of Umzug is available on npm by specifying the correct tag:\r\n\r\n```bash\r\nnpm install umzug@beta\r\n```\r\n\r\n#### Umzug instance\r\n\r\nIt is possible to configure an Umzug instance by passing an object to the constructor.\r\n\r\n```js\r\nconst { Umzug } = require('umzug');\r\nconst umzug = new Umzug({ /* ... options ... */ });\r\n```\r\n\r\nDetailed documentation for these options are in the `UmzugConstructorOptions` TypeScript interface, which can be found in [src/types.ts](./src/types.ts).\r\n\r\n#### Getting all pending migrations\r\n\r\nYou can get a list of pending (i.e. not yet executed) migrations with the `pending()` method:\r\n\r\n```js\r\nconst migrations = await umzug.pending();\r\n// returns an array of all pending migrations.\r\n```\r\n\r\n#### Getting all executed migrations\r\n\r\nYou can get a list of already executed migrations with the `executed()` method:\r\n\r\n```js\r\nconst migrations = await umzug.executed();\r\n// returns an array of all already executed migrations\r\n```\r\n\r\n#### Executing pending migrations\r\n\r\nThe `up` method can be used to execute all pending migrations.\r\n\r\n```js\r\nconst migrations = await umzug.up();\r\n// returns an array of all executed migrations\r\n```\r\n\r\nIt is also possible to pass the name of a migration in order to just run the migrations from the current state to the passed migration name (inclusive).\r\n\r\n```js\r\nawait umzug.up({ to: '20141101203500-task' });\r\n```\r\n\r\n\r\nRunning specific migrations while ignoring the right order, can be done like this:\r\n\r\n```js\r\nawait umzug.up({ migrations: ['20141101203500-task', '20141101203501-task-2'] });\r\n```\r\n\r\n#### Reverting executed migration\r\n\r\nThe `down` method can be used to revert the last executed migration.\r\n\r\n```js\r\nconst migration = await umzug.down();\r\n// reverts the last migration and returns it.\r\n```\r\n\r\nIt is possible to pass the name of a migration until which (inclusive) the migrations should be reverted. This allows the reverting of multiple migrations at once.\r\n\r\n```js\r\nconst migrations = await umzug.down({ to: '20141031080000-task' });\r\n// returns an array of all reverted migrations.\r\n```\r\n\r\nTo revert all migrations, you can pass 0 as the `to` parameter:\r\n\r\n```js\r\nawait umzug.down({ to: 0 });\r\n```\r\n\r\nReverting specific migrations while ignoring the right order, can be done like this:\r\n\r\n```js\r\nawait umzug.down({ migrations: ['20141101203500-task', '20141101203501-task-2'] });\r\n```\r\n\r\n### Migrations\r\n\r\nThere are two ways to specify migrations: via files or directly via an array of migrations.\r\n\r\n#### Migration files\r\n\r\nA migration file ideally exposes an `up` and a `down` async functions. They will perform the task of upgrading or downgrading the database.\r\n\r\n```js\r\nmodule.exports = {\r\n  async up() {\r\n    /* ... */\r\n  },\r\n  async down() {\r\n    /* ... */\r\n  }\r\n};\r\n```\r\n\r\nMigration files can be located anywhere - they will typically be loaded according to a glob pattern provided to the `Umzug` constructor.\r\n\r\n#### Direct migrations list\r\n\r\nYou can also specify directly a list of migrations to the `Umzug` constructor:\r\n\r\n```js\r\nconst { Umzug } = require('umzug');\r\n\r\nconst umzug = new Umzug({\r\n  migrations: [\r\n    {\r\n      // the name of the migration is mandatory\r\n      name: '00-first-migration',\r\n      async up({ context }) { /* ... */ },\r\n      async down({ context }) { /* ... */ }\r\n    },\r\n    {\r\n      name: '01-foo-bar-migration',\r\n      async up({ context }) { /* ... */ },\r\n      async down({ context }) { /* ... */ }\r\n    }\r\n  ],\r\n  context: sequelize.getQueryInterface(),\r\n  logger: console,\r\n});\r\n```\r\n\r\nTo load migrations in another format, you can use the `resolve` function:\r\n\r\n```js\r\nconst { Umzug } = require('umzug')\r\nconst { Sequelize } = require('sequelize')\r\nconst fs = require('fs')\r\n\r\nconst umzug = new Umzug({\r\n  migrations: {\r\n    glob: 'migrations/*.up.sql',\r\n    resolve: ({ name, path, context: sequelize }) => ({\r\n      name,\r\n      up: async () => {\r\n        const sql = fs.readFileSync(path).toString()\r\n        return sequelize.query(sql)\r\n      },\r\n      down: async () => {\r\n        // Get the corresponding `.down.sql` file to undo this migration\r\n        const sql = fs.readFileSync(path.replace('.up.sql', '.down.sql')).toString()\r\n        return sequelize.query(sql)\r\n      }\r\n    })\r\n  },\r\n  context: new Sequelize(...),\r\n  logger: console,\r\n});\r\n```\r\n\r\nYou can support mixed migration file types, and use umzug's default resolver for javascript/typescript:\r\n\r\n```js\r\nconst { Umzug } = require('umzug')\r\nconst { Sequelize } = require('sequelize')\r\nconst fs = require('fs')\r\n\r\nconst umzug = new Umzug({\r\n  migrations: {\r\n    glob: 'migrations/*.{js,ts,up.sql}',\r\n    resolve: (params) => {\r\n      if (!params.path.endsWith('.sql')) {\r\n        return Umzug.defaultResolver(params)\r\n      }\r\n      const { context: sequelize } = params\r\n      return {\r\n        name: params.name,\r\n        up: async () => {\r\n          const sql = fs.readFileSync(params.path).toString()\r\n          return sequelize.query(sql)\r\n        },\r\n        down: async () => {\r\n          // Get the corresponding `.down.sql` file to undo this migration\r\n          const sql = fs.readFileSync(params.path.replace('.up.sql', '.down.sql')).toString()\r\n          return sequelize.query(sql)\r\n        }\r\n      }\r\n    },\r\n  },\r\n  logger: console,\r\n  context: new Sequelize(...),\r\n});\r\n```\r\n\r\nThe glob syntax allows loading migrations from multiple locations:\r\n\r\n```js\r\nconst { Umzug } = require('umzug')\r\nconst { Sequelize } = require('sequelize')\r\n\r\nconst umzug = new Umzug({\r\n  migrations: {\r\n    glob: '{first-folder/*.js,second-folder-with-different-naming-convention/*.js}',\r\n  },\r\n  context: new Sequelize(...),\r\n  logger: console,\r\n});\r\n```\r\n\r\nNote on migration file sorting:\r\n\r\n- file matches, found using [glob](https://npmjs.com/package/glob), will be lexicographically sorted based on their paths\r\n  - so if your migrations are `one/m1.js`, `two/m2.js`, `three/m3.js`, the resultant order will be `one/m1.js`, `three/m3.js`, `two/m2.js`\r\n  - similarly, if your migrations are called `m1.js`, `m2.js`, ... `m10.js`, `m11.js`, the resultant ordering will be `m1.js`, `m10.js`, `m11.js`, ... `m2.js`\r\n- The easiest way to deal with this is to ensure your migrations appear in a single folder, and their paths match lexicographically with the order they should run in\r\n- If this isn't possible, the ordering can be customised using `.extend(...)` (see below)\r\n\r\n### Upgrading from v2.x\r\n\r\nThe Umzug class should be imported as a named import, i.e. `import { Umzug } from 'umzug'`.\r\n\r\nThe `MigrationMeta` type, which is returned by `umzug.executed()` and `umzug.pending()`, no longer has a `file` property - it has a `name` and *optional* `path` - since migrations are not necessarily bound to files on the file system.\r\n\r\nThe `migrations.glob` parameter replaces `path`, `pattern` and `traverseDirectories`. It can be used, in combination with `cwd` and `ignore` to do much more flexible file lookups. See https://npmjs.com/package/glob for more information on the syntax.\r\n\r\nThe `migrations.resolve` parameter replaces `customResolver`. Explicit support for `wrap` and `nameFormatter` has been removed - these can be easily implemented in a `resolve` function.\r\n\r\nThe constructor option `logging` is replaced by `logger` to allow for `warn` and `error` messages in future. NodeJS's global `console` object can be passed to this. To disable logging, replace `logging: false` with `logger: undefined`.\r\n\r\nThe `Umzug#execute` method is removed. Use `Umzug#up` or `Umzug#down`.\r\n\r\nThe options for `Umguz#up` and `Umzug#down` have changed:\r\n- `umzug.up({ to: 'some-name' })` and `umzug.down({ to: 'some-name' })` are still valid.\r\n- `umzug.up({ from: '...' })` and `umzug.down({ from: '...' })` are no longer supported. To run migrations out-of-order (which is not generally recommended), you can explicitly use `umzug.up({ migrations: ['...'] })` and `umzug.down({ migrations: ['...'] })`.\r\n- name matches must be exact. `umzug.up({ to: 'some-n' })` will no longer match a migration called `some-name`.\r\n- `umzug.down({ to: 0 })` is still valid but `umzug.up({ to: 0 })` is not.\r\n- `umzug.up({ migrations: ['m1', 'm2'] })` is still valid but the shorthand `umzug.up(['m1', 'm2'])` has been removed.\r\n- `umzug.down({ migrations: ['m1', 'm2'] })` is still valid but the shorthand `umzug.down(['m1', 'm2'])` has been removed.\r\n- `umzug.up({ migrations: ['m1', 'already-run'] })` will throw an error, if `already-run` is not found in the list of pending migrations.\r\n- `umzug.down({ migrations: ['m1', 'has-not-been-run'] })` will throw an error, if `has-not-been-run` is not found in the list of executed migrations.\r\n- `umzug.up({ migrations: ['m1', 'm2'], rerun: 'ALLOW' })` will re-apply migrations `m1` and `m2` even if they've already been run.\r\n- `umzug.up({ migrations: ['m1', 'm2'], rerun: 'SKIP' })` will skip migrations `m1` and `m2` if they've already been run.\r\n- `umzug.down({ migrations: ['m1', 'm2'], rerun: 'ALLOW' })` will \"revert\" migrations `m1` and `m2` even if they've never been run.\r\n- `umzug.down({ migrations: ['m1', 'm2'], rerun: 'SKIP' })` will skip reverting migrations `m1` and `m2` if they haven't been run or are already reverted.\r\n- `umzug.up({ migrations: ['m1', 'does-not-exist', 'm2'] })` will throw an error if the migration name is not found. Note that the error will be thrown and no migrations run unless _all_ migration names are found - whether or not `rerun: 'ALLOW'` is added.\r\n\r\nThe `context` parameter replaces `params`, and is passed in as a property to migration functions as an options object, alongs side `name` and `path`. This means the signature for migrations, which in v2 was `(context) => Promise<void>`, has changed slightly in v3, to `({ name, path, context }) => Promise<void>`. The `resolve` function can also be used to upgrade your umzug version to v3 when you have existing v2-compatible migrations:\r\n\r\n```js\r\nconst { Umzug } = require('umzug');\r\n\r\nconst umzug = new Umzug({\r\n  migrations: {\r\n    glob: 'migrations/umzug-v2-format/*.js',\r\n    resolve: ({name, path, context}) => {\r\n      // Adjust the migration from the new signature to the v2 signature, making easier to upgrade to v3\r\n      const migration = require(path)\r\n      return { up: async () => migration.up(context), down: async () => migration.down(context) }\r\n    }\r\n  },\r\n  context: sequelize.getQueryInterface(),\r\n  logger: console,\r\n});\r\n```\r\n\r\nSimilarly, you no longer need `migrationSorting`, you can use `Umzug#extend` to manipulate migration lists directly:\r\n\r\n```js\r\nconst { Umzug } = require('umzug');\r\n\r\nconst umzug =\r\n  new Umzug({\r\n    migrations: { glob: 'migrations/**/*.js' },\r\n    context: sequelize.getQueryInterface(),\r\n  })\r\n  .extend(migrations => migrations.sort((a, b) => b.path.localeCompare(a.path)));\r\n```\r\n\r\n### Storages\r\n\r\nStorages define where the migration data is stored.\r\n\r\n#### JSON Storage\r\n\r\nUsing `JSONStorage` will create a JSON file which will contain an array with all the executed migrations. You can specify the path to the file. The default for that is `umzug.json` in the working directory of the process.\r\n\r\nDetailed documentation for the options it can take are in the `JSONStorageConstructorOptions` TypeScript interface, which can be found in [src/storage/json.ts](./src/storage/json.ts).\r\n\r\n#### Memory Storage\r\n\r\nUsing `memoryStorage` will store migrations with an in-memory array. This can be useful for proof-of-concepts or tests, since it doesn't interact with databases or filesystems.\r\n\r\nIt doesn't take any options, just import the `memoryStorage` function and call it to return a storage instance:\r\n\r\n```typescript\r\nimport { Umzug, memoryStorage } from 'umzug'\r\n\r\nconst umzug = new Umzug({\r\n  migrations: ...,\r\n  storage: memoryStorage(),\r\n  logger: console,\r\n})\r\n```\r\n\r\n#### Sequelize Storage\r\n\r\nUsing `SequelizeStorage` will create a table in your SQL database called `SequelizeMeta` containing an entry for each executed migration. You will have to pass a configured instance of Sequelize or an existing Sequelize model. Optionally you can specify the model name, table name, or column name. All major Sequelize versions are supported.\r\n\r\nDetailed documentation for the options it can take are in the `_SequelizeStorageConstructorOptions` TypeScript interface, which can be found in [src/storage/sequelize.ts](./src/storage/sequelize.ts).\r\n\r\n#### MongoDB Storage\r\n\r\nUsing `MongoDBStorage` will create a collection in your MongoDB database called `migrations` containing an entry for each executed migration. You will have either to pass a MongoDB Driver Collection as `collection` property. Alternatively you can pass a established MongoDB Driver connection and a collection name.\r\n\r\nDetailed documentation for the options it can take are in the `MongoDBStorageConstructorOptions` TypeScript interface, which can be found in [src/storage/mongodb.ts](./src/storage/mongodb.ts).\r\n\r\n#### Custom\r\n\r\nIn order to use a custom storage, you can pass your storage instance to Umzug constructor.\r\n\r\n```js\r\nclass CustomStorage {\r\n  constructor(...) {...}\r\n  logMigration(...) {...}\r\n  unlogMigration(...) {...}\r\n  executed(...) {...}\r\n}\r\n\r\nconst umzug = new Umzug({ storage: new CustomStorage(...), logger: console })\r\n```\r\n\r\nYour instance must adhere to the [UmzugStorage](./src/storage/contract.ts) interface. If you're using TypeScript you can ensure this at compile time, and get IDE type hints by importing it:\r\n\r\n```typescript\r\nimport { UmzugStorage } from 'umzug'\r\n\r\nclass CustomStorage implements UmzugStorage {\r\n  /* ... */\r\n}\r\n```\r\n\r\n### Events\r\n\r\nUmzug is an [EventEmitter](https://nodejs.org/docs/latest-v10.x/api/events.html#events_class_eventemitter). Each of the following events will be called with `name` and `migration` as arguments. Events are a convenient place to implement application-specific logic that must run around each migration:\r\n\r\n* `migrating` - A migration is about to be executed.\r\n* `migrated` - A migration has successfully been executed.\r\n* `reverting` - A migration is about to be reverted.\r\n* `reverted` - A migration has successfully been reverted.\r\n\r\n## License\r\n\r\nSee the [LICENSE file](./LICENSE)\r\n","readmeFilename":"README.md","gitHead":"980eaa945a8a8aad72ab0f3d02244c005fc609c3","_id":"umzug@3.0.0-beta.8","_nodeVersion":"12.18.0","_npmVersion":"6.14.8","dist":{"integrity":"sha512-yetNoOprmfAR7eI5vvbWiVTmd0Y+h8CdSiYyyOC+/8anxeppbfFWnXrNrCyJqP3qCpTBKHJhEi25BxMlRDvvyw==","shasum":"242f782637cfbbb725dccac121df43c6536e2dd0","tarball":"https://registry.npmjs.org/umzug/-/umzug-3.0.0-beta.8.tgz","fileCount":28,"unpackedSize":73272,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJfncTgCRA9TVsSAnZWagAAfhYQAIO/vIdkbnDzeoxjDLls\n5QdUKY8sLnlImVE3VRIPUis3ZOhfHRVgkDmTwda7T5pP/712/E/f6xd1zz+B\nYh2N6g3yVNs5QxKE+xhSf1eNjqwhvBeHdcDCTlZD/ThMjtFyDRFUlTgLWThk\nmTut2b/jMVKBS5DNwnCKwmgT1iAJGV0Tozweh8uXKBhd0Igb/S8OqH130q7E\nIw+0BYTwGlzIWLOfKDhorTU0RCzjQMxI40wSs3nrEHkbUyQ9s18T1kHYultL\nQhoIxifA7arIyzS8J1hEAg3He3v2YZ8x+YXI1FHT2/twr1mR+sS20b5/wiRw\nAxD5afult4uhwop9jiC9QZUDjxBlQm8E5M2uNRv0k4yyt0OGXSRQ2qz1iqBb\nXu2rWPUzw9tovrhOxum0lWZABDy0S2lvFWkMZw/b2/H0S9OOKM/XHsBDAjLB\nGcr7W10+32BFN2ZLrtFGrItZ6GjGLOV5uzi+iUSTbYvwBfnxXto/3ykqRH5f\nfg2Fbh+scWoirGhNKo6baoVtJ2nQs/RyYQpQGNF1uSn/3XbpL1nGpHFt43JB\nGV+nAKroBZct+1iN4/+F6LNFep37xv/hUpRAeZmgkqoYvOnNoLhk4gZMDh2M\nsPp4J4oTgp+A+pcQXpxZPfPxCT06wNsmPYn6nEFZcXmVXz2fEIEmXsbnALhX\n6fam\r\n=QEXP\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIQCFCao/g1Ih9s0oiQVV/RQ55G6yTsX+LhetUeproz1s+AIgYEeab2bWIW1Qx/RC35En/WkMRquragQbzZW0hYW+NpY="}]},"maintainers":[{"name":"pascal.pflaum","email":"mail@pascalpflaum.de"},{"name":"sdepold","email":"sascha@depold.com"},{"name":"sushantdhiman","email":"sushantdhiman@outlook.com"},{"name":"papb","email":"papb1996@gmail.com"},{"name":"mmkale","email":"mmkal1@outlook.com"}],"_npmUser":{"name":"mmkale","email":"mmkal1@outlook.com"},"directories":{},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/umzug_3.0.0-beta.8_1604175072463_0.25127928964463453"},"_hasShrinkwrap":false},"3.0.0-beta.9":{"name":"umzug","version":"3.0.0-beta.9","description":"Framework-agnostic migration tool for Node","keywords":["migrate","migration","migrations","sequelize","database"],"main":"lib/index.js","dependencies":{"fs-jetpack":"^4.0.0","glob":"^7.1.6","type-fest":"^0.19.0"},"devDependencies":{"@types/jest":"26.0.15","@types/uuid":"8.3.0","@typescript-eslint/eslint-plugin":"4.8.1","@typescript-eslint/parser":"4.8.1","del-cli":"3.0.1","eslint":"7.13.0","eslint-config-xo":"0.33.1","eslint-config-xo-typescript":"0.35.0","eslint-plugin-codegen":"0.14.0","eslint-plugin-import":"2.22.1","eslint-plugin-jest":"24.1.3","eslint-plugin-mocha":"8.0.0","eslint-plugin-prettier":"3.1.4","eslint-plugin-unicorn":"23.0.0","expect-type":"0.9.0","fs-syncer":"0.3.0","jest":"26.6.3","lodash":"4.17.20","np":"7.0.0","prettier":"2.1.2","sequelize":"5.22.3","sinon":"9.2.1","source-map-support":"0.5.19","sqlite3":"5.0.0","ts-jest":"26.4.4","typescript":"4.0.5","uuid":"8.3.1"},"scripts":{"build":"del-cli lib && tsc","lint":"eslint --ext .js,.ts . --max-warnings 0","prepare":"npm run build","release":"np --no-yarn --no-2fa","pretest":"del-cli test/generated","test":"jest"},"repository":{"type":"git","url":"git+https://github.com/sequelize/umzug.git"},"author":{"name":"Sascha Depold","email":"sascha@depold.com"},"contributors":[{"name":"Jukka Hyytiälä","email":"hyytiala.jukka@gmail.com"},{"name":"Pascal Pflaum","email":"mail@pascalpflaum.de"},{"name":"Pedro Augusto de Paula Barbosa","email":"papb1996@gmail.com"}],"license":"MIT","bugs":{"url":"https://github.com/sequelize/umzug/issues"},"homepage":"https://github.com/sequelize/umzug","engines":{"node":">=10.0.0"},"jest":{"preset":"ts-jest","globals":{"ts-jest":{"diagnostics":false}},"testEnvironment":"node","testMatch":["**/*test.ts"],"collectCoverageFrom":["src/**"]},"readme":"# Umzug\r\n\r\n[![Build Status](https://badgen.net/github/checks/sequelize/umzug/master)](https://github.com/sequelize/umzug/actions?query=workflow%3ACI)\r\n[![npm (stable)](https://badgen.net/npm/v/umzug)](https://www.npmjs.com/package/umzug)\r\n[![npm (beta)](https://badgen.net/npm/v/umzug/beta)](https://www.npmjs.com/package/umzug/v/beta)\r\n[![npm (downloads)](https://badgen.net/npm/dm/umzug)](https://npmjs.com/package/umzug)\r\n\r\nUmzug is a framework-agnostic migration tool for Node. It provides a clean API for running and rolling back tasks.\r\n\r\n_Note: master represents the next major version of umzug - v3 - which is currently in beta. For the stable version, please refer to the [v2.x branch](https://github.com/sequelize/umzug/tree/v2.x)._\r\n\r\nTo install the v3-beta package:\r\n\r\n```\r\nnpm install umzug@beta\r\n```\r\n\r\nTo install the stable package (v2.x):\r\n\r\n```\r\nnpm install umzug\r\n```\r\n\r\n## Highlights\r\n\r\n* Written in TypeScript\r\n\t* Built-in typings\r\n\t* Auto-completion right in your IDE\r\n\t* Documentation right in your IDE\r\n* Programmatic API for migrations\r\n* Database agnostic\r\n* Supports logging of migration process\r\n* Supports multiple storages for migration data\r\n\r\n## Documentation\r\n\r\n### Minimal Example\r\n\r\nThe following example uses a Sqlite database through sequelize and persists the migration data in the database itself through the sequelize storage.\r\n\r\n```js\r\n// index.js\r\nconst { Sequelize } = require('sequelize');\r\nconst { Umzug, SequelizeStorage } = require('umzug');\r\n\r\nconst sequelize = new Sequelize({ dialect: 'sqlite', storage: './db.sqlite' });\r\n\r\nconst umzug = new Umzug({\r\n  migrations: { glob: 'migrations/*.js' },\r\n  context: sequelize.getQueryInterface(),\r\n  storage: new SequelizeStorage({ sequelize }),\r\n  logger: console,\r\n});\r\n\r\n(async () => {\r\n  // Checks migrations and run them if they are not already applied. To keep\r\n  // track of the executed migrations, a table (and sequelize model) called SequelizeMeta\r\n  // will be automatically created (if it doesn't exist already) and parsed.\r\n  await umzug.up();\r\n})();\r\n```\r\n\r\n```js\r\n// migrations/00_initial.js\r\n\r\nconst { Sequelize } = require('sequelize');\r\n\r\nasync function up({ context: queryInterface }) {\r\n\tawait queryInterface.createTable('users', {\r\n\t\tid: {\r\n\t\t\ttype: Sequelize.INTEGER,\r\n\t\t\tallowNull: false,\r\n\t\t\tprimaryKey: true\r\n\t\t},\r\n\t\tname: {\r\n\t\t\ttype: Sequelize.STRING,\r\n\t\t\tallowNull: false\r\n\t\t},\r\n\t\tcreatedAt: {\r\n\t\t\ttype: Sequelize.DATE,\r\n\t\t\tallowNull: false\r\n\t\t},\r\n\t\tupdatedAt: {\r\n\t\t\ttype: Sequelize.DATE,\r\n\t\t\tallowNull: false\r\n\t\t}\r\n\t});\r\n}\r\n\r\nasync function down({ context: queryInterface }) {\r\n\tawait queryInterface.dropTable('users');\r\n}\r\n\r\nmodule.exports = { up, down };\r\n```\r\n\r\nNote that we renamed the `context` argument to `queryInterface` for clarity. The `context` is whatever we specified when creating the Umzug instance in `index.js`.\r\n\r\n<details>\r\n<summary>You can also write your migrations in typescript by using `ts-node` in the entrypoint:</summary>\r\n\r\n```typescript\r\n// index.ts\r\nrequire('ts-node/register')\r\n\r\nimport { Sequelize } from 'sequelize';\r\nimport { Umzug, SequelizeStorage } from 'umzug';\r\n\r\nconst sequelize = new Sequelize({ dialect: 'sqlite', storage: './db.sqlite' });\r\n\r\nconst umzug = new Umzug({\r\n  migrations: { glob: 'migrations/*.ts' },\r\n  context: sequelize.getQueryInterface(),\r\n  storage: new SequelizeStorage({ sequelize }),\r\n  logger: console,\r\n});\r\n\r\n// export the type helper exposed by umzug, which will have the `context` argument typed correctly\r\nexport type Migration = typeof umzug._types.migration;\r\n\r\n(async () => {\r\n  await umzug.up();\r\n})();\r\n```\r\n\r\n```typescript\r\n// migrations/00_initial.ts\r\nimport type { Migration } from '..';\r\n\r\n// types will now be available for `queryInterface`\r\nexport const up: Migration = ({ context: queryInterface }) => queryInterface.createTable(...)\r\nexport const down: Migration = ({ context: queryInterface }) => queryInterface.dropTable(...)\r\n```\r\n</details>\r\n\r\nSee [these tests](./test/umzug.test.ts) for more examples of Umzug usage, including:\r\n\r\n- passing `ignore` and `cwd` parameters to the glob instructions\r\n- customising migrations ordering\r\n- finding migrations from multiple different directories\r\n- using non-js file extensions via a custom resolver, e.g. `.sql`\r\n\r\n### Usage\r\n\r\n#### Installation\r\n\r\nThe beta version of Umzug is available on npm by specifying the correct tag:\r\n\r\n```bash\r\nnpm install umzug@beta\r\n```\r\n\r\n#### Umzug instance\r\n\r\nIt is possible to configure an Umzug instance by passing an object to the constructor.\r\n\r\n```js\r\nconst { Umzug } = require('umzug');\r\nconst umzug = new Umzug({ /* ... options ... */ });\r\n```\r\n\r\nDetailed documentation for these options are in the `UmzugConstructorOptions` TypeScript interface, which can be found in [src/types.ts](./src/types.ts).\r\n\r\n#### Getting all pending migrations\r\n\r\nYou can get a list of pending (i.e. not yet executed) migrations with the `pending()` method:\r\n\r\n```js\r\nconst migrations = await umzug.pending();\r\n// returns an array of all pending migrations.\r\n```\r\n\r\n#### Getting all executed migrations\r\n\r\nYou can get a list of already executed migrations with the `executed()` method:\r\n\r\n```js\r\nconst migrations = await umzug.executed();\r\n// returns an array of all already executed migrations\r\n```\r\n\r\n#### Executing pending migrations\r\n\r\nThe `up` method can be used to execute all pending migrations.\r\n\r\n```js\r\nconst migrations = await umzug.up();\r\n// returns an array of all executed migrations\r\n```\r\n\r\nIt is also possible to pass the name of a migration in order to just run the migrations from the current state to the passed migration name (inclusive).\r\n\r\n```js\r\nawait umzug.up({ to: '20141101203500-task' });\r\n```\r\n\r\nTo limit the number of migrations that are run, `step` can be used:\r\n\r\n```js\r\nawait umzug.up({ step: 2 })\r\n```\r\n\r\nRunning specific migrations while ignoring the right order, can be done like this:\r\n\r\n```js\r\nawait umzug.up({ migrations: ['20141101203500-task', '20141101203501-task-2'] });\r\n```\r\n\r\n#### Reverting executed migration\r\n\r\nThe `down` method can be used to revert the last executed migration.\r\n\r\n```js\r\nconst migration = await umzug.down();\r\n// reverts the last migration and returns it.\r\n```\r\n\r\nTo revert more than one migration, you can use `step`:\r\n\r\n```js\r\nawait umzug.down({ step: 2 });\r\n```\r\n\r\nIt is possible to pass the name of a migration until which (inclusive) the migrations should be reverted. This allows the reverting of multiple migrations at once.\r\n\r\n```js\r\nconst migrations = await umzug.down({ to: '20141031080000-task' });\r\n// returns an array of all reverted migrations.\r\n```\r\n\r\nTo revert all migrations, you can pass 0 as the `to` parameter:\r\n\r\n```js\r\nawait umzug.down({ to: 0 });\r\n```\r\n\r\nReverting specific migrations while ignoring the right order, can be done like this:\r\n\r\n```js\r\nawait umzug.down({ migrations: ['20141101203500-task', '20141101203501-task-2'] });\r\n```\r\n\r\n### Migrations\r\n\r\nThere are two ways to specify migrations: via files or directly via an array of migrations.\r\n\r\n#### Migration files\r\n\r\nA migration file ideally exposes an `up` and a `down` async functions. They will perform the task of upgrading or downgrading the database.\r\n\r\n```js\r\nmodule.exports = {\r\n  async up() {\r\n    /* ... */\r\n  },\r\n  async down() {\r\n    /* ... */\r\n  }\r\n};\r\n```\r\n\r\nMigration files can be located anywhere - they will typically be loaded according to a glob pattern provided to the `Umzug` constructor.\r\n\r\n#### Direct migrations list\r\n\r\nYou can also specify directly a list of migrations to the `Umzug` constructor:\r\n\r\n```js\r\nconst { Umzug } = require('umzug');\r\n\r\nconst umzug = new Umzug({\r\n  migrations: [\r\n    {\r\n      // the name of the migration is mandatory\r\n      name: '00-first-migration',\r\n      async up({ context }) { /* ... */ },\r\n      async down({ context }) { /* ... */ }\r\n    },\r\n    {\r\n      name: '01-foo-bar-migration',\r\n      async up({ context }) { /* ... */ },\r\n      async down({ context }) { /* ... */ }\r\n    }\r\n  ],\r\n  context: sequelize.getQueryInterface(),\r\n  logger: console,\r\n});\r\n```\r\n\r\nTo load migrations in another format, you can use the `resolve` function:\r\n\r\n```js\r\nconst { Umzug } = require('umzug')\r\nconst { Sequelize } = require('sequelize')\r\nconst fs = require('fs')\r\n\r\nconst umzug = new Umzug({\r\n  migrations: {\r\n    glob: 'migrations/*.up.sql',\r\n    resolve: ({ name, path, context: sequelize }) => ({\r\n      name,\r\n      up: async () => {\r\n        const sql = fs.readFileSync(path).toString()\r\n        return sequelize.query(sql)\r\n      },\r\n      down: async () => {\r\n        // Get the corresponding `.down.sql` file to undo this migration\r\n        const sql = fs.readFileSync(path.replace('.up.sql', '.down.sql')).toString()\r\n        return sequelize.query(sql)\r\n      }\r\n    })\r\n  },\r\n  context: new Sequelize(...),\r\n  logger: console,\r\n});\r\n```\r\n\r\nYou can support mixed migration file types, and use umzug's default resolver for javascript/typescript:\r\n\r\n```js\r\nconst { Umzug } = require('umzug')\r\nconst { Sequelize } = require('sequelize')\r\nconst fs = require('fs')\r\n\r\nconst umzug = new Umzug({\r\n  migrations: {\r\n    glob: 'migrations/*.{js,ts,up.sql}',\r\n    resolve: (params) => {\r\n      if (!params.path.endsWith('.sql')) {\r\n        return Umzug.defaultResolver(params)\r\n      }\r\n      const { context: sequelize } = params\r\n      return {\r\n        name: params.name,\r\n        up: async () => {\r\n          const sql = fs.readFileSync(params.path).toString()\r\n          return sequelize.query(sql)\r\n        },\r\n        down: async () => {\r\n          // Get the corresponding `.down.sql` file to undo this migration\r\n          const sql = fs.readFileSync(params.path.replace('.up.sql', '.down.sql')).toString()\r\n          return sequelize.query(sql)\r\n        }\r\n      }\r\n    },\r\n  },\r\n  logger: console,\r\n  context: new Sequelize(...),\r\n});\r\n```\r\n\r\nThe glob syntax allows loading migrations from multiple locations:\r\n\r\n```js\r\nconst { Umzug } = require('umzug')\r\nconst { Sequelize } = require('sequelize')\r\n\r\nconst umzug = new Umzug({\r\n  migrations: {\r\n    glob: '{first-folder/*.js,second-folder-with-different-naming-convention/*.js}',\r\n  },\r\n  context: new Sequelize(...),\r\n  logger: console,\r\n});\r\n```\r\n\r\nNote on migration file sorting:\r\n\r\n- file matches, found using [glob](https://npmjs.com/package/glob), will be lexicographically sorted based on their paths\r\n  - so if your migrations are `one/m1.js`, `two/m2.js`, `three/m3.js`, the resultant order will be `one/m1.js`, `three/m3.js`, `two/m2.js`\r\n  - similarly, if your migrations are called `m1.js`, `m2.js`, ... `m10.js`, `m11.js`, the resultant ordering will be `m1.js`, `m10.js`, `m11.js`, ... `m2.js`\r\n- The easiest way to deal with this is to ensure your migrations appear in a single folder, and their paths match lexicographically with the order they should run in\r\n- If this isn't possible, the ordering can be customised using `.extend(...)` (see below)\r\n\r\n### Upgrading from v2.x\r\n\r\nThe Umzug class should be imported as a named import, i.e. `import { Umzug } from 'umzug'`.\r\n\r\nThe `MigrationMeta` type, which is returned by `umzug.executed()` and `umzug.pending()`, no longer has a `file` property - it has a `name` and *optional* `path` - since migrations are not necessarily bound to files on the file system.\r\n\r\nThe `migrations.glob` parameter replaces `path`, `pattern` and `traverseDirectories`. It can be used, in combination with `cwd` and `ignore` to do much more flexible file lookups. See https://npmjs.com/package/glob for more information on the syntax.\r\n\r\nThe `migrations.resolve` parameter replaces `customResolver`. Explicit support for `wrap` and `nameFormatter` has been removed - these can be easily implemented in a `resolve` function.\r\n\r\nThe constructor option `logging` is replaced by `logger` to allow for `warn` and `error` messages in future. NodeJS's global `console` object can be passed to this. To disable logging, replace `logging: false` with `logger: undefined`.\r\n\r\nThe `Umzug#execute` method is removed. Use `Umzug#up` or `Umzug#down`.\r\n\r\nThe options for `Umguz#up` and `Umzug#down` have changed:\r\n- `umzug.up({ to: 'some-name' })` and `umzug.down({ to: 'some-name' })` are still valid.\r\n- `umzug.up({ from: '...' })` and `umzug.down({ from: '...' })` are no longer supported. To run migrations out-of-order (which is not generally recommended), you can explicitly use `umzug.up({ migrations: ['...'] })` and `umzug.down({ migrations: ['...'] })`.\r\n- name matches must be exact. `umzug.up({ to: 'some-n' })` will no longer match a migration called `some-name`.\r\n- `umzug.down({ to: 0 })` is still valid but `umzug.up({ to: 0 })` is not.\r\n- `umzug.up({ migrations: ['m1', 'm2'] })` is still valid but the shorthand `umzug.up(['m1', 'm2'])` has been removed.\r\n- `umzug.down({ migrations: ['m1', 'm2'] })` is still valid but the shorthand `umzug.down(['m1', 'm2'])` has been removed.\r\n- `umzug.up({ migrations: ['m1', 'already-run'] })` will throw an error, if `already-run` is not found in the list of pending migrations.\r\n- `umzug.down({ migrations: ['m1', 'has-not-been-run'] })` will throw an error, if `has-not-been-run` is not found in the list of executed migrations.\r\n- `umzug.up({ migrations: ['m1', 'm2'], rerun: 'ALLOW' })` will re-apply migrations `m1` and `m2` even if they've already been run.\r\n- `umzug.up({ migrations: ['m1', 'm2'], rerun: 'SKIP' })` will skip migrations `m1` and `m2` if they've already been run.\r\n- `umzug.down({ migrations: ['m1', 'm2'], rerun: 'ALLOW' })` will \"revert\" migrations `m1` and `m2` even if they've never been run.\r\n- `umzug.down({ migrations: ['m1', 'm2'], rerun: 'SKIP' })` will skip reverting migrations `m1` and `m2` if they haven't been run or are already reverted.\r\n- `umzug.up({ migrations: ['m1', 'does-not-exist', 'm2'] })` will throw an error if the migration name is not found. Note that the error will be thrown and no migrations run unless _all_ migration names are found - whether or not `rerun: 'ALLOW'` is added.\r\n\r\nThe `context` parameter replaces `params`, and is passed in as a property to migration functions as an options object, alongs side `name` and `path`. This means the signature for migrations, which in v2 was `(context) => Promise<void>`, has changed slightly in v3, to `({ name, path, context }) => Promise<void>`. The `resolve` function can also be used to upgrade your umzug version to v3 when you have existing v2-compatible migrations:\r\n\r\n```js\r\nconst { Umzug } = require('umzug');\r\n\r\nconst umzug = new Umzug({\r\n  migrations: {\r\n    glob: 'migrations/umzug-v2-format/*.js',\r\n    resolve: ({name, path, context}) => {\r\n      // Adjust the migration from the new signature to the v2 signature, making easier to upgrade to v3\r\n      const migration = require(path)\r\n      return { name, up: async () => migration.up(context), down: async () => migration.down(context) }\r\n    }\r\n  },\r\n  context: sequelize.getQueryInterface(),\r\n  logger: console,\r\n});\r\n```\r\n\r\nSimilarly, you no longer need `migrationSorting`, you can use `Umzug#extend` to manipulate migration lists directly:\r\n\r\n```js\r\nconst { Umzug } = require('umzug');\r\n\r\nconst umzug =\r\n  new Umzug({\r\n    migrations: { glob: 'migrations/**/*.js' },\r\n    context: sequelize.getQueryInterface(),\r\n  })\r\n  .extend(migrations => migrations.sort((a, b) => b.path.localeCompare(a.path)));\r\n```\r\n\r\n### Storages\r\n\r\nStorages define where the migration data is stored.\r\n\r\n#### JSON Storage\r\n\r\nUsing `JSONStorage` will create a JSON file which will contain an array with all the executed migrations. You can specify the path to the file. The default for that is `umzug.json` in the working directory of the process.\r\n\r\nDetailed documentation for the options it can take are in the `JSONStorageConstructorOptions` TypeScript interface, which can be found in [src/storage/json.ts](./src/storage/json.ts).\r\n\r\n#### Memory Storage\r\n\r\nUsing `memoryStorage` will store migrations with an in-memory array. This can be useful for proof-of-concepts or tests, since it doesn't interact with databases or filesystems.\r\n\r\nIt doesn't take any options, just import the `memoryStorage` function and call it to return a storage instance:\r\n\r\n```typescript\r\nimport { Umzug, memoryStorage } from 'umzug'\r\n\r\nconst umzug = new Umzug({\r\n  migrations: ...,\r\n  storage: memoryStorage(),\r\n  logger: console,\r\n})\r\n```\r\n\r\n#### Sequelize Storage\r\n\r\nUsing `SequelizeStorage` will create a table in your SQL database called `SequelizeMeta` containing an entry for each executed migration. You will have to pass a configured instance of Sequelize or an existing Sequelize model. Optionally you can specify the model name, table name, or column name. All major Sequelize versions are supported.\r\n\r\nDetailed documentation for the options it can take are in the `_SequelizeStorageConstructorOptions` TypeScript interface, which can be found in [src/storage/sequelize.ts](./src/storage/sequelize.ts).\r\n\r\n#### MongoDB Storage\r\n\r\nUsing `MongoDBStorage` will create a collection in your MongoDB database called `migrations` containing an entry for each executed migration. You will have either to pass a MongoDB Driver Collection as `collection` property. Alternatively you can pass a established MongoDB Driver connection and a collection name.\r\n\r\nDetailed documentation for the options it can take are in the `MongoDBStorageConstructorOptions` TypeScript interface, which can be found in [src/storage/mongodb.ts](./src/storage/mongodb.ts).\r\n\r\n#### Custom\r\n\r\nIn order to use a custom storage, you can pass your storage instance to Umzug constructor.\r\n\r\n```js\r\nclass CustomStorage {\r\n  constructor(...) {...}\r\n  logMigration(...) {...}\r\n  unlogMigration(...) {...}\r\n  executed(...) {...}\r\n}\r\n\r\nconst umzug = new Umzug({ storage: new CustomStorage(...), logger: console })\r\n```\r\n\r\nYour instance must adhere to the [UmzugStorage](./src/storage/contract.ts) interface. If you're using TypeScript you can ensure this at compile time, and get IDE type hints by importing it:\r\n\r\n```typescript\r\nimport { UmzugStorage } from 'umzug'\r\n\r\nclass CustomStorage implements UmzugStorage {\r\n  /* ... */\r\n}\r\n```\r\n\r\n### Events\r\n\r\nUmzug is an [EventEmitter](https://nodejs.org/docs/latest-v10.x/api/events.html#events_class_eventemitter). Each of the following events will be called with `name` and `migration` as arguments. Events are a convenient place to implement application-specific logic that must run around each migration:\r\n\r\n* `migrating` - A migration is about to be executed.\r\n* `migrated` - A migration has successfully been executed.\r\n* `reverting` - A migration is about to be reverted.\r\n* `reverted` - A migration has successfully been reverted.\r\n\r\n## License\r\n\r\nSee the [LICENSE file](./LICENSE)\r\n","readmeFilename":"README.md","gitHead":"cc9408d91d47e8bedf9a8a4d7d190083b9d87779","_id":"umzug@3.0.0-beta.9","_nodeVersion":"12.18.0","_npmVersion":"6.14.8","dist":{"integrity":"sha512-NkGzGkpbuRO+dpnqxnQM781w0I9o0uf2lDeoUJZS6lckh0P5P7DTpW+Pc718NtZUYVA1QPGen0sIIVrV2lSbbw==","shasum":"003109c6ab5717e4a0e8cbca55fd8e38dc5adbfd","tarball":"https://registry.npmjs.org/umzug/-/umzug-3.0.0-beta.9.tgz","fileCount":31,"unpackedSize":74635,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJftpu5CRA9TVsSAnZWagAAkc4QAJ1Qx7H+OZ8iEEyjN6hy\nKquDHxRWRZR5Gl/93auDKqCEoedEbVnE2BLaU9QZO3JvTqyFl+lsogWvPAhz\nQDNkHQkVEzdvTLAeLYPAszi8RNaZ+5IUl2ZT+7Usg4RSMn7+LAJ6axBgtOkP\nGn1IczrmYaL9iOSy/8rReqZtOFyAs5icsZsYLtpMP7py9cP/4q2vGNYLwyGb\npbu8TOJzU2pMBboP/sIrwS2pKHnJhNGKQKhKdl8WDYmF/jAUvfykeSTr63u1\nwerV/3ufpaWEz7P61FCkwkBEW5hBBHz+qospCPEj3hHbrbSEYGQbM7XzZXOt\nc80kG2pKpqJnVp8t/QJpNA00ve49xoz3Lo3CcjfB5aZZL03/Uijt3ebwC07L\nYzOWY+F7waP9bHNOXpHHnZeaG2aMdYN5n5wKXPfGr2UaJxEDGqvEQVzxPxtX\nablpwmSwTGBf+kpflnzt9Wum8cc7XuBImBhFq52x0VtDc06p6b50cyLlaJ8I\nwg0u7+F/x2R1WMr2r64YXOOC7EPTvib/vu7YYwhJY/dRSha0xHtD8gjkplJu\nJl7xplnczV+9d8cepKaqXinEfcWWEn7EDASxTafE3V5cpuSnNAVIWPEyD8+y\nHUFmFWzOBRvK03ycNTcaATl8nFed+6j05b4qkr53S8TfUQ53U6TRlVMrh0Qr\n20+Q\r\n=A8/N\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEYCIQDTOG4iS+TBa6bsxcSEJvMws5ajPFbL8wTHaIyHgxzhCAIhAK0AP7iZgqcKv+QLSLYoT7dY7/SFQtf0nA2/044proZS"}]},"_npmUser":{"name":"mmkale","email":"mmkal1@outlook.com"},"directories":{},"maintainers":[{"name":"pascal.pflaum","email":"mail@pascalpflaum.de"},{"name":"sdepold","email":"sascha@depold.com"},{"name":"sushantdhiman","email":"sushantdhiman@outlook.com"},{"name":"papb","email":"papb1996@gmail.com"},{"name":"mmkale","email":"mmkal1@outlook.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/umzug_3.0.0-beta.9_1605802937506_0.6476328397886597"},"_hasShrinkwrap":false},"3.0.0-beta-cli.9":{"name":"umzug","version":"3.0.0-beta-cli.9","description":"Framework-agnostic migration tool for Node","keywords":["migrate","migration","migrations","sequelize","database"],"main":"lib/index.js","dependencies":{"@rushstack/ts-command-line":"^4.7.7","fs-jetpack":"^4.0.0","glob":"^7.1.6","type-fest":"^0.19.0"},"devDependencies":{"@types/jest":"26.0.15","@types/uuid":"8.3.0","@typescript-eslint/eslint-plugin":"4.8.1","@typescript-eslint/parser":"4.8.1","del-cli":"3.0.1","eslint":"7.13.0","eslint-config-xo":"0.33.1","eslint-config-xo-typescript":"0.35.0","eslint-plugin-codegen":"0.14.0","eslint-plugin-import":"2.22.1","eslint-plugin-jest":"24.1.3","eslint-plugin-mocha":"8.0.0","eslint-plugin-prettier":"3.1.4","eslint-plugin-unicorn":"23.0.0","expect-type":"0.9.0","fs-syncer":"0.3.0","jest":"26.6.3","lodash":"4.17.20","np":"7.0.0","prettier":"2.1.2","sequelize":"5.22.3","sinon":"9.2.1","source-map-support":"0.5.19","sqlite3":"5.0.0","ts-jest":"26.4.4","typescript":"4.0.5","uuid":"8.3.1"},"scripts":{"build":"del-cli lib && tsc","lint":"eslint --ext .js,.ts,.md . --max-warnings 0","prepare":"npm run build","release":"np --no-yarn --no-2fa","pretest":"del-cli test/generated","test":"jest"},"repository":{"type":"git","url":"git+https://github.com/sequelize/umzug.git"},"author":{"name":"Sascha Depold","email":"sascha@depold.com"},"contributors":[{"name":"Jukka Hyytiälä","email":"hyytiala.jukka@gmail.com"},{"name":"Pascal Pflaum","email":"mail@pascalpflaum.de"},{"name":"Pedro Augusto de Paula Barbosa","email":"papb1996@gmail.com"}],"license":"MIT","bugs":{"url":"https://github.com/sequelize/umzug/issues"},"homepage":"https://github.com/sequelize/umzug","engines":{"node":">=10.0.0"},"jest":{"preset":"ts-jest","globals":{"ts-jest":{"diagnostics":false}},"testEnvironment":"node","testMatch":["**/*test.ts"],"collectCoverageFrom":["src/**"]},"readme":"# Umzug\r\n\r\n[![Build Status](https://badgen.net/github/checks/sequelize/umzug/master)](https://github.com/sequelize/umzug/actions?query=workflow%3ACI)\r\n[![npm (stable)](https://badgen.net/npm/v/umzug)](https://www.npmjs.com/package/umzug)\r\n[![npm (beta)](https://badgen.net/npm/v/umzug/beta)](https://www.npmjs.com/package/umzug/v/beta)\r\n[![npm (downloads)](https://badgen.net/npm/dm/umzug)](https://npmjs.com/package/umzug)\r\n\r\nUmzug is a framework-agnostic migration tool for Node. It provides a clean API for running and rolling back tasks.\r\n\r\n_Note: master represents the next major version of umzug - v3 - which is currently in beta. For the stable version, please refer to the [v2.x branch](https://github.com/sequelize/umzug/tree/v2.x)._\r\n\r\nTo install the v3-beta package:\r\n\r\n```\r\nnpm install umzug@beta\r\n```\r\n\r\nTo install the stable package (v2.x):\r\n\r\n```\r\nnpm install umzug\r\n```\r\n\r\n## Highlights\r\n\r\n* Written in TypeScript\r\n\t* Built-in typings\r\n\t* Auto-completion right in your IDE\r\n\t* Documentation right in your IDE\r\n* Programmatic API for migrations\r\n* Built in [CLI](#cli)\r\n* Database agnostic\r\n* Supports logging of migration process\r\n* Supports multiple storages for migration data\r\n\r\n## Documentation\r\n\r\n### Minimal Example\r\n\r\nThe following example uses a Sqlite database through sequelize and persists the migration data in the database itself through the sequelize storage.\r\n\r\n```js\r\n// index.js\r\nconst { Sequelize } = require('sequelize');\r\nconst { Umzug, SequelizeStorage } = require('umzug');\r\n\r\nconst sequelize = new Sequelize({ dialect: 'sqlite', storage: './db.sqlite' });\r\n\r\nconst umzug = new Umzug({\r\n  migrations: { glob: 'migrations/*.js' },\r\n  context: sequelize.getQueryInterface(),\r\n  storage: new SequelizeStorage({ sequelize }),\r\n  logger: console,\r\n});\r\n\r\n(async () => {\r\n  // Checks migrations and run them if they are not already applied. To keep\r\n  // track of the executed migrations, a table (and sequelize model) called SequelizeMeta\r\n  // will be automatically created (if it doesn't exist already) and parsed.\r\n  await umzug.up();\r\n})();\r\n```\r\n\r\n```js\r\n// migrations/00_initial.js\r\n\r\nconst { Sequelize } = require('sequelize');\r\n\r\nasync function up({ context: queryInterface }) {\r\n\tawait queryInterface.createTable('users', {\r\n\t\tid: {\r\n\t\t\ttype: Sequelize.INTEGER,\r\n\t\t\tallowNull: false,\r\n\t\t\tprimaryKey: true\r\n\t\t},\r\n\t\tname: {\r\n\t\t\ttype: Sequelize.STRING,\r\n\t\t\tallowNull: false\r\n\t\t},\r\n\t\tcreatedAt: {\r\n\t\t\ttype: Sequelize.DATE,\r\n\t\t\tallowNull: false\r\n\t\t},\r\n\t\tupdatedAt: {\r\n\t\t\ttype: Sequelize.DATE,\r\n\t\t\tallowNull: false\r\n\t\t}\r\n\t});\r\n}\r\n\r\nasync function down({ context: queryInterface }) {\r\n\tawait queryInterface.dropTable('users');\r\n}\r\n\r\nmodule.exports = { up, down };\r\n```\r\n\r\nNote that we renamed the `context` argument to `queryInterface` for clarity. The `context` is whatever we specified when creating the Umzug instance in `index.js`.\r\n\r\n<details>\r\n<summary>You can also write your migrations in typescript by using `ts-node` in the entrypoint:</summary>\r\n\r\n```typescript\r\n// index.ts\r\nrequire('ts-node/register')\r\n\r\nimport { Sequelize } from 'sequelize';\r\nimport { Umzug, SequelizeStorage } from 'umzug';\r\n\r\nconst sequelize = new Sequelize({ dialect: 'sqlite', storage: './db.sqlite' });\r\n\r\nconst umzug = new Umzug({\r\n  migrations: { glob: 'migrations/*.ts' },\r\n  context: sequelize.getQueryInterface(),\r\n  storage: new SequelizeStorage({ sequelize }),\r\n  logger: console,\r\n});\r\n\r\n// export the type helper exposed by umzug, which will have the `context` argument typed correctly\r\nexport type Migration = typeof umzug._types.migration;\r\n\r\n(async () => {\r\n  await umzug.up();\r\n})();\r\n```\r\n\r\n```typescript\r\n// migrations/00_initial.ts\r\nimport type { Migration } from '..';\r\n\r\n// types will now be available for `queryInterface`\r\nexport const up: Migration = ({ context: queryInterface }) => queryInterface.createTable(...)\r\nexport const down: Migration = ({ context: queryInterface }) => queryInterface.dropTable(...)\r\n```\r\n</details>\r\n\r\nSee [these tests](./test/umzug.test.ts) for more examples of Umzug usage, including:\r\n\r\n- passing `ignore` and `cwd` parameters to the glob instructions\r\n- customising migrations ordering\r\n- finding migrations from multiple different directories\r\n- using non-js file extensions via a custom resolver, e.g. `.sql`\r\n\r\n### Usage\r\n\r\n#### Installation\r\n\r\nThe beta version of Umzug is available on npm by specifying the correct tag:\r\n\r\n```bash\r\nnpm install umzug@beta\r\n```\r\n\r\n#### Umzug instance\r\n\r\nIt is possible to configure an Umzug instance by passing an object to the constructor.\r\n\r\n```js\r\nconst { Umzug } = require('umzug');\r\nconst umzug = new Umzug({ /* ... options ... */ });\r\n```\r\n\r\nDetailed documentation for these options are in the `UmzugConstructorOptions` TypeScript interface, which can be found in [src/types.ts](./src/types.ts).\r\n\r\n#### Getting all pending migrations\r\n\r\nYou can get a list of pending (i.e. not yet executed) migrations with the `pending()` method:\r\n\r\n```js\r\nconst migrations = await umzug.pending();\r\n// returns an array of all pending migrations.\r\n```\r\n\r\n#### Getting all executed migrations\r\n\r\nYou can get a list of already executed migrations with the `executed()` method:\r\n\r\n```js\r\nconst migrations = await umzug.executed();\r\n// returns an array of all already executed migrations\r\n```\r\n\r\n#### Executing pending migrations\r\n\r\nThe `up` method can be used to execute all pending migrations.\r\n\r\n```js\r\nconst migrations = await umzug.up();\r\n// returns an array of all executed migrations\r\n```\r\n\r\nIt is also possible to pass the name of a migration in order to just run the migrations from the current state to the passed migration name (inclusive).\r\n\r\n```js\r\nawait umzug.up({ to: '20141101203500-task' });\r\n```\r\n\r\nTo limit the number of migrations that are run, `step` can be used:\r\n\r\n```js\r\nawait umzug.up({ step: 2 })\r\n```\r\n\r\nRunning specific migrations while ignoring the right order, can be done like this:\r\n\r\n```js\r\nawait umzug.up({ migrations: ['20141101203500-task', '20141101203501-task-2'] });\r\n```\r\n\r\n#### Reverting executed migration\r\n\r\nThe `down` method can be used to revert the last executed migration.\r\n\r\n```js\r\nconst migration = await umzug.down();\r\n// reverts the last migration and returns it.\r\n```\r\n\r\nTo revert more than one migration, you can use `step`:\r\n\r\n```js\r\nawait umzug.down({ step: 2 });\r\n```\r\n\r\nIt is possible to pass the name of a migration until which (inclusive) the migrations should be reverted. This allows the reverting of multiple migrations at once.\r\n\r\n```js\r\nconst migrations = await umzug.down({ to: '20141031080000-task' });\r\n// returns an array of all reverted migrations.\r\n```\r\n\r\nTo revert all migrations, you can pass 0 as the `to` parameter:\r\n\r\n```js\r\nawait umzug.down({ to: 0 });\r\n```\r\n\r\nReverting specific migrations while ignoring the right order, can be done like this:\r\n\r\n```js\r\nawait umzug.down({ migrations: ['20141101203500-task', '20141101203501-task-2'] });\r\n```\r\n\r\n### Migrations\r\n\r\nThere are two ways to specify migrations: via files or directly via an array of migrations.\r\n\r\n#### Migration files\r\n\r\nA migration file ideally exposes an `up` and a `down` async functions. They will perform the task of upgrading or downgrading the database.\r\n\r\n```js\r\nmodule.exports = {\r\n  async up() {\r\n    /* ... */\r\n  },\r\n  async down() {\r\n    /* ... */\r\n  }\r\n};\r\n```\r\n\r\nMigration files can be located anywhere - they will typically be loaded according to a glob pattern provided to the `Umzug` constructor.\r\n\r\n#### Direct migrations list\r\n\r\nYou can also specify directly a list of migrations to the `Umzug` constructor:\r\n\r\n```js\r\nconst { Umzug } = require('umzug');\r\n\r\nconst umzug = new Umzug({\r\n  migrations: [\r\n    {\r\n      // the name of the migration is mandatory\r\n      name: '00-first-migration',\r\n      async up({ context }) { /* ... */ },\r\n      async down({ context }) { /* ... */ }\r\n    },\r\n    {\r\n      name: '01-foo-bar-migration',\r\n      async up({ context }) { /* ... */ },\r\n      async down({ context }) { /* ... */ }\r\n    }\r\n  ],\r\n  context: sequelize.getQueryInterface(),\r\n  logger: console,\r\n});\r\n```\r\n\r\nTo load migrations in another format, you can use the `resolve` function:\r\n\r\n```js\r\nconst { Umzug } = require('umzug')\r\nconst { Sequelize } = require('sequelize')\r\nconst fs = require('fs')\r\n\r\nconst umzug = new Umzug({\r\n  migrations: {\r\n    glob: 'migrations/*.up.sql',\r\n    resolve: ({ name, path, context: sequelize }) => ({\r\n      name,\r\n      up: async () => {\r\n        const sql = fs.readFileSync(path).toString()\r\n        return sequelize.query(sql)\r\n      },\r\n      down: async () => {\r\n        // Get the corresponding `.down.sql` file to undo this migration\r\n        const sql = fs.readFileSync(path.replace('.up.sql', '.down.sql')).toString()\r\n        return sequelize.query(sql)\r\n      }\r\n    })\r\n  },\r\n  context: new Sequelize(...),\r\n  logger: console,\r\n});\r\n```\r\n\r\nYou can support mixed migration file types, and use umzug's default resolver for javascript/typescript:\r\n\r\n```js\r\nconst { Umzug } = require('umzug')\r\nconst { Sequelize } = require('sequelize')\r\nconst fs = require('fs')\r\n\r\nconst umzug = new Umzug({\r\n  migrations: {\r\n    glob: 'migrations/*.{js,ts,up.sql}',\r\n    resolve: (params) => {\r\n      if (!params.path.endsWith('.sql')) {\r\n        return Umzug.defaultResolver(params)\r\n      }\r\n      const { context: sequelize } = params\r\n      return {\r\n        name: params.name,\r\n        up: async () => {\r\n          const sql = fs.readFileSync(params.path).toString()\r\n          return sequelize.query(sql)\r\n        },\r\n        down: async () => {\r\n          // Get the corresponding `.down.sql` file to undo this migration\r\n          const sql = fs.readFileSync(params.path.replace('.up.sql', '.down.sql')).toString()\r\n          return sequelize.query(sql)\r\n        }\r\n      }\r\n    },\r\n  },\r\n  logger: console,\r\n  context: new Sequelize(...),\r\n});\r\n```\r\n\r\nThe glob syntax allows loading migrations from multiple locations:\r\n\r\n```js\r\nconst { Umzug } = require('umzug')\r\nconst { Sequelize } = require('sequelize')\r\n\r\nconst umzug = new Umzug({\r\n  migrations: {\r\n    glob: '{first-folder/*.js,second-folder-with-different-naming-convention/*.js}',\r\n  },\r\n  context: new Sequelize(...),\r\n  logger: console,\r\n});\r\n```\r\n\r\nNote on migration file sorting:\r\n\r\n- file matches, found using [glob](https://npmjs.com/package/glob), will be lexicographically sorted based on their paths\r\n  - so if your migrations are `one/m1.js`, `two/m2.js`, `three/m3.js`, the resultant order will be `one/m1.js`, `three/m3.js`, `two/m2.js`\r\n  - similarly, if your migrations are called `m1.js`, `m2.js`, ... `m10.js`, `m11.js`, the resultant ordering will be `m1.js`, `m10.js`, `m11.js`, ... `m2.js`\r\n- The easiest way to deal with this is to ensure your migrations appear in a single folder, and their paths match lexicographically with the order they should run in\r\n- If this isn't possible, the ordering can be customised using `.extend(...)` (see below)\r\n\r\n### Upgrading from v2.x\r\n\r\nThe Umzug class should be imported as a named import, i.e. `import { Umzug } from 'umzug'`.\r\n\r\nThe `MigrationMeta` type, which is returned by `umzug.executed()` and `umzug.pending()`, no longer has a `file` property - it has a `name` and *optional* `path` - since migrations are not necessarily bound to files on the file system.\r\n\r\nThe `migrations.glob` parameter replaces `path`, `pattern` and `traverseDirectories`. It can be used, in combination with `cwd` and `ignore` to do much more flexible file lookups. See https://npmjs.com/package/glob for more information on the syntax.\r\n\r\nThe `migrations.resolve` parameter replaces `customResolver`. Explicit support for `wrap` and `nameFormatter` has been removed - these can be easily implemented in a `resolve` function.\r\n\r\nThe constructor option `logging` is replaced by `logger` to allow for `warn` and `error` messages in future. NodeJS's global `console` object can be passed to this. To disable logging, replace `logging: false` with `logger: undefined`.\r\n\r\nThe `Umzug#execute` method is removed. Use `Umzug#up` or `Umzug#down`.\r\n\r\nThe options for `Umguz#up` and `Umzug#down` have changed:\r\n- `umzug.up({ to: 'some-name' })` and `umzug.down({ to: 'some-name' })` are still valid.\r\n- `umzug.up({ from: '...' })` and `umzug.down({ from: '...' })` are no longer supported. To run migrations out-of-order (which is not generally recommended), you can explicitly use `umzug.up({ migrations: ['...'] })` and `umzug.down({ migrations: ['...'] })`.\r\n- name matches must be exact. `umzug.up({ to: 'some-n' })` will no longer match a migration called `some-name`.\r\n- `umzug.down({ to: 0 })` is still valid but `umzug.up({ to: 0 })` is not.\r\n- `umzug.up({ migrations: ['m1', 'm2'] })` is still valid but the shorthand `umzug.up(['m1', 'm2'])` has been removed.\r\n- `umzug.down({ migrations: ['m1', 'm2'] })` is still valid but the shorthand `umzug.down(['m1', 'm2'])` has been removed.\r\n- `umzug.up({ migrations: ['m1', 'already-run'] })` will throw an error, if `already-run` is not found in the list of pending migrations.\r\n- `umzug.down({ migrations: ['m1', 'has-not-been-run'] })` will throw an error, if `has-not-been-run` is not found in the list of executed migrations.\r\n- `umzug.up({ migrations: ['m1', 'm2'], rerun: 'ALLOW' })` will re-apply migrations `m1` and `m2` even if they've already been run.\r\n- `umzug.up({ migrations: ['m1', 'm2'], rerun: 'SKIP' })` will skip migrations `m1` and `m2` if they've already been run.\r\n- `umzug.down({ migrations: ['m1', 'm2'], rerun: 'ALLOW' })` will \"revert\" migrations `m1` and `m2` even if they've never been run.\r\n- `umzug.down({ migrations: ['m1', 'm2'], rerun: 'SKIP' })` will skip reverting migrations `m1` and `m2` if they haven't been run or are already reverted.\r\n- `umzug.up({ migrations: ['m1', 'does-not-exist', 'm2'] })` will throw an error if the migration name is not found. Note that the error will be thrown and no migrations run unless _all_ migration names are found - whether or not `rerun: 'ALLOW'` is added.\r\n\r\nThe `context` parameter replaces `params`, and is passed in as a property to migration functions as an options object, alongs side `name` and `path`. This means the signature for migrations, which in v2 was `(context) => Promise<void>`, has changed slightly in v3, to `({ name, path, context }) => Promise<void>`. The `resolve` function can also be used to upgrade your umzug version to v3 when you have existing v2-compatible migrations:\r\n\r\n```js\r\nconst { Umzug } = require('umzug');\r\n\r\nconst umzug = new Umzug({\r\n  migrations: {\r\n    glob: 'migrations/umzug-v2-format/*.js',\r\n    resolve: ({name, path, context}) => {\r\n      // Adjust the migration from the new signature to the v2 signature, making easier to upgrade to v3\r\n      const migration = require(path)\r\n      return { name, up: async () => migration.up(context), down: async () => migration.down(context) }\r\n    }\r\n  },\r\n  context: sequelize.getQueryInterface(),\r\n  logger: console,\r\n});\r\n```\r\n\r\nSimilarly, you no longer need `migrationSorting`, you can use `Umzug#extend` to manipulate migration lists directly:\r\n\r\n```js\r\nconst { Umzug } = require('umzug');\r\n\r\nconst umzug =\r\n  new Umzug({\r\n    migrations: { glob: 'migrations/**/*.js' },\r\n    context: sequelize.getQueryInterface(),\r\n  })\r\n  .extend(migrations => migrations.sort((a, b) => b.path.localeCompare(a.path)));\r\n```\r\n\r\n### Storages\r\n\r\nStorages define where the migration data is stored.\r\n\r\n#### JSON Storage\r\n\r\nUsing `JSONStorage` will create a JSON file which will contain an array with all the executed migrations. You can specify the path to the file. The default for that is `umzug.json` in the working directory of the process.\r\n\r\nDetailed documentation for the options it can take are in the `JSONStorageConstructorOptions` TypeScript interface, which can be found in [src/storage/json.ts](./src/storage/json.ts).\r\n\r\n#### Memory Storage\r\n\r\nUsing `memoryStorage` will store migrations with an in-memory array. This can be useful for proof-of-concepts or tests, since it doesn't interact with databases or filesystems.\r\n\r\nIt doesn't take any options, just import the `memoryStorage` function and call it to return a storage instance:\r\n\r\n```typescript\r\nimport { Umzug, memoryStorage } from 'umzug'\r\n\r\nconst umzug = new Umzug({\r\n  migrations: ...,\r\n  storage: memoryStorage(),\r\n  logger: console,\r\n})\r\n```\r\n\r\n#### Sequelize Storage\r\n\r\nUsing `SequelizeStorage` will create a table in your SQL database called `SequelizeMeta` containing an entry for each executed migration. You will have to pass a configured instance of Sequelize or an existing Sequelize model. Optionally you can specify the model name, table name, or column name. All major Sequelize versions are supported.\r\n\r\nDetailed documentation for the options it can take are in the `_SequelizeStorageConstructorOptions` TypeScript interface, which can be found in [src/storage/sequelize.ts](./src/storage/sequelize.ts).\r\n\r\n#### MongoDB Storage\r\n\r\nUsing `MongoDBStorage` will create a collection in your MongoDB database called `migrations` containing an entry for each executed migration. You will have either to pass a MongoDB Driver Collection as `collection` property. Alternatively you can pass a established MongoDB Driver connection and a collection name.\r\n\r\nDetailed documentation for the options it can take are in the `MongoDBStorageConstructorOptions` TypeScript interface, which can be found in [src/storage/mongodb.ts](./src/storage/mongodb.ts).\r\n\r\n#### Custom\r\n\r\nIn order to use a custom storage, you can pass your storage instance to Umzug constructor.\r\n\r\n```js\r\nclass CustomStorage {\r\n  constructor(...) {...}\r\n  logMigration(...) {...}\r\n  unlogMigration(...) {...}\r\n  executed(...) {...}\r\n}\r\n\r\nconst umzug = new Umzug({ storage: new CustomStorage(...), logger: console })\r\n```\r\n\r\nYour instance must adhere to the [UmzugStorage](./src/storage/contract.ts) interface. If you're using TypeScript you can ensure this at compile time, and get IDE type hints by importing it:\r\n\r\n```typescript\r\nimport { UmzugStorage } from 'umzug'\r\n\r\nclass CustomStorage implements UmzugStorage {\r\n  /* ... */\r\n}\r\n```\r\n\r\n### Creating migrations - API\r\n\r\nUmzug includes an optional helper for generating migration files. This will, by default, include a timestamp-based prefix and generate a file in the same folder as the most recent existing migration. It also includes some safety checks to make sure migrations aren't created with ambiguous ordering, and that they will be picked up by umzug when applying migrations. It's often most convenient to create files using the [CLI helper](#creating-migrations---cli), but the equivalent API also exists on an umzug instance:\r\n\r\n```js\r\nawait umzug.create({ name: 'my-new-migration.js' })\r\n```\r\n\r\nUmzug ships with a barebones default template for js, ts and sql migration files, but you can specify the template for your project when constructing an umzug instance. The `template` property should be a function which receives a filepath string, and returns an array of `[filepath, content]` pairs. Usually, just one pair is needed, but a second could be used to include a \"down\" migration in a separate file:\r\n\r\n```js\r\nconst umzug = new Umzug({\r\n  migrations: ...,\r\n  template: filepath => [\r\n    [\r\n      filepath,\r\n      dedent`\r\n        import { Migration } from '@my-team/migration-type'\r\n        import { logger } from '@my-team/custom-logger'\r\n\r\n        export const up: Migration = params => {\r\n          logger.info('running migration', params.name)\r\n        }\r\n\r\n        export const down: Migration = params => {\r\n          logger.info('reverting migration', params.name)\r\n        }\r\n      `\r\n    ],\r\n  ]\r\n})\r\n```\r\n\r\nTo create blank migration files, return an empty array:\r\n\r\n```js\r\nconst umzug = new Umzug({\r\n  migrations: ...,\r\n  template: () => [],\r\n})\r\n```\r\n\r\n### Events\r\n\r\nUmzug is an [EventEmitter](https://nodejs.org/docs/latest-v10.x/api/events.html#events_class_eventemitter). Each of the following events will be called with `name` and `migration` as arguments. Events are a convenient place to implement application-specific logic that must run around each migration:\r\n\r\n* `migrating` - A migration is about to be executed.\r\n* `migrated` - A migration has successfully been executed.\r\n* `reverting` - A migration is about to be reverted.\r\n* `reverted` - A migration has successfully been reverted.\r\n\r\n### CLI\r\n\r\nUmzug has an optional built-in CLI helper. To use it, call the `.runAsCLI()` method from an `Umzug` instance:\r\n\r\n```js\r\n// my-umzug-migrator.js\r\nconst { Umzug } = require('umzug')\r\n\r\nexports.umzug = new Umzug({ ... })\r\n\r\nif (require.main === module) {\r\n  umzug.runAsCLI()\r\n}\r\n```\r\n\r\nThis script is now a runnable CLI program, complete with help text. You can run `node my-umzug-migrator.js --help` to see how to use it. It'll print something like\r\n\r\n<!-- codegen:start {preset: custom, source: ./codegen.js, export: cliHelp} -->\r\n```\r\nusage: <script> [-h] <command> ...\r\n\r\nUmzug migrator\r\n\r\nPositional arguments:\r\n  <command>\r\n    up        Applies pending migrations\r\n    down      Revert migrations\r\n    pending   Lists pending migrations\r\n    executed  Lists executed migrations\r\n    create    Create a migration file\r\n\r\nOptional arguments:\r\n  -h, --help  Show this help message and exit.\r\n\r\nFor detailed help about a specific command, use: <script> <command> -h\r\n```\r\n<!-- codegen:end -->\r\n\r\n#### Running migrations\r\n\r\n`node my-umzug-migrator up` and `node my-umzug-migrator down` apply and revert migrations respectively. They're the equivalent of the `.up()` and `.down()` methods.\r\n\r\nUse `node my-umzug-migrator up --help` and `node my-umzug-migrator down --help` for options (running \"to\" a specific migration, passing migration names to be run explicitly, and specifying the rerun behavior):\r\n\r\nUp:\r\n<!-- codegen:start {preset: custom, source: ./codegen.js, export: cliHelp, action: up} -->\r\n```\r\nusage: <script> up [-h] [--to NAME] [--step COUNT] [--migration NAME]\r\n                   [--rerun {THROW,SKIP,ALLOW}]\r\n                   \r\n\r\nPerforms all migrations. See --help for more options\r\n\r\nOptional arguments:\r\n  -h, --help            Show this help message and exit.\r\n  --to NAME             All migrations up to and including this one should be \r\n                        applied.\r\n  --step COUNT          Run this many migrations. If not specified, all will \r\n                        be applied.\r\n  --migration NAME      List of migrations to be applied\r\n  --rerun {THROW,SKIP,ALLOW}\r\n                        Specify what action should be taken when a migration \r\n                        that has already been applied is passed. The default \r\n                        value is \"THROW\".\r\n```\r\n<!-- codegen:end -->\r\n\r\nDown:\r\n<!-- codegen:start {preset: custom, source: ./codegen.js, export: cliHelp, action: down} -->\r\n```\r\nusage: <script> down [-h] [--to NAME] [--step COUNT] [--migration NAME]\r\n                     [--rerun {THROW,SKIP,ALLOW}]\r\n                     \r\n\r\nUndoes previously-applied migrations. By default, undoes the most recent \r\nmigration only. Use --help for more options. Useful in development to start \r\nfrom a clean slate. Use with care in production!\r\n\r\nOptional arguments:\r\n  -h, --help            Show this help message and exit.\r\n  --to NAME             All migrations up to and including this one should be \r\n                        reverted. Pass \"0\" to revert all.\r\n  --step COUNT          Run this many migrations. If not specified, one will \r\n                        be reverted.\r\n  --migration NAME      List of migrations to be reverted\r\n  --rerun {THROW,SKIP,ALLOW}\r\n                        Specify what action should be taken when a migration \r\n                        that has already been reverted is passed. The default \r\n                        value is \"THROW\".\r\n```\r\n<!-- codegen:end -->\r\n\r\n\r\n#### Listing migrations\r\n\r\n```bash\r\nnode my-umzug-migrator pending # list migrations yet to be run\r\nnode my-umzug-migrator executed # list migrations that have already run\r\n\r\nnode my-umzug-migrator pending --json # list pending migrations including names and paths, in a json array format\r\nnode my-umzug-migrator executed --json # list executed migrations including names and paths, in a json array format\r\n\r\nnode my-umzug-migrator pending --help # show help/options\r\nnode my-umzug-migrator executed --help # show help/options\r\n```\r\n\r\n<!-- codegen:start {preset: custom, source: ./codegen.js, export: cliHelp, action: pending} -->\r\n```\r\nusage: <script> pending [-h] [--json]\r\n\r\nPrints migrations returned by `umzug.pending()`. By default, prints migration \r\nnames one per line.\r\n\r\nOptional arguments:\r\n  -h, --help  Show this help message and exit.\r\n  --json      Print pending migrations in a json format including names and \r\n              paths. This allows piping output to tools like jq. Without this \r\n              flag, the migration names will be printed one per line.\r\n```\r\n<!-- codegen:end -->\r\n\r\n<!-- codegen:start {preset: custom, source: ./codegen.js, export: cliHelp, action: executed} -->\r\n```\r\nusage: <script> executed [-h] [--json]\r\n\r\nPrints migrations returned by `umzug.executed()`. By default, prints \r\nmigration names one per line.\r\n\r\nOptional arguments:\r\n  -h, --help  Show this help message and exit.\r\n  --json      Print executed migrations in a json format including names and \r\n              paths. This allows piping output to tools like jq. Without this \r\n              flag, the migration names will be printed one per line.\r\n```\r\n<!-- codegen:end -->\r\n\r\n\r\n\r\n#### Creating migrations - CLI\r\n\r\nUsually, migrations correspond to files on the filesystem. The CLI exposes a way to create migration files easily:\r\n\r\n```bash\r\nnode my-umzug-migrator create --name my-migration.js\r\n```\r\n\r\nThis will create a file with a name like `2000.12.25T12.34.56.my-migration.js` in the same directory as the most recent migration file. If it's the very first migration file, you need to specify the folder explicitly:\r\n\r\n```bash\r\nnode my-umzug-migrator create --name my-migration.js --folder path/to/directory\r\n```\r\n\r\nThe timestamp prefix can be customized to be date-only or omitted, but be aware that it's strongly recommended to ensure your migrations are lexicographically sortable so it's easy for humans and tools to determine what order they should run in - so the default prefix is recommended.\r\n\r\nBy default, placeholder content is included for `.js`, `.ts` and `.sql` migration files. You can override the template content or provide a template for other file types by creating a template module to generate code according to your project's convention. The default export should be a function which receives a filepath and returns an array of `[filepath, content]` pairs. Example:\r\n\r\n```javascript\r\n// my-template.js\r\nexports.default = filepath => [\r\n  [filepath, `exports.up = () => console.log('running up migration!');`]\r\n]\r\n```\r\n\r\nUse the template by passing it as a cli parameter:\r\n\r\n```\r\nnode my-umzug-migrator create --name my-migration.js --template path/to/my-template.js\r\n```\r\n\r\nThis parameter may alternatively be specified via the `UMZUG_MIGRATION_TEMPLATE` environment variable, to avoid having to pass the path explicitly every time.\r\n\r\nUse `node my-umzug-migrator create --help` for more options:\r\n\r\n<!-- codegen:start {preset: custom, source: ./codegen.js, export: cliHelp, action: create} -->\r\n```\r\nusage: <script> create [-h] --name NAME [--prefix {TIMESTAMP,DATE,NONE}]\r\n                       [--folder PATH] [--allow-extension EXTENSION]\r\n                       [--skip-verify] [--allow-confusing-ordering]\r\n                       \r\n\r\nGenerates a placeholder migration file using a timestamp as a prefix. By \r\ndefault, mimics the last existing migration, or guesses where to generate the \r\nfile if no migration exists yet.\r\n\r\nOptional arguments:\r\n  -h, --help            Show this help message and exit.\r\n  --name NAME           The name of the migration file. e.g. my-migration.js, \r\n                        my-migration.ts or my-migration.sql. Note - a prefix \r\n                        will be added to this name, usually based on a \r\n                        timestamp. See --prefix\r\n  --prefix {TIMESTAMP,DATE,NONE}\r\n                        The prefix format for generated files. TIMESTAMP uses \r\n                        a second-resolution timestamp, DATE uses a \r\n                        day-resolution timestamp, and NONE removes the prefix \r\n                        completely. The default value is \"TIMESTAMP\".\r\n  --folder PATH         Path on the filesystem where the file should be \r\n                        created. The new migration will be created as a \r\n                        sibling of the last existing one if this is omitted.\r\n  --allow-extension EXTENSION\r\n                        Allowable extension for created files. By default .js,\r\n                         .ts and .sql files can be created. To create txt \r\n                        file migrations, for example, you could use '--name \r\n                        my-migration.txt --allow-extension .txt' This \r\n                        parameter may alternatively be specified via the \r\n                        UMZUG_ALLOW_EXTENSION environment variable.\r\n  --skip-verify         By default, the generated file will be checked after \r\n                        creation to make sure it is detected as a pending \r\n                        migration. This catches problems like creation in the \r\n                        wrong folder, or invalid naming conventions. This \r\n                        flag bypasses that verification step.\r\n  --allow-confusing-ordering\r\n                        By default, an error will be thrown if you try to \r\n                        create a migration that will run before a migration \r\n                        that already exists. This catches errors which can \r\n                        cause problems if you change file naming conventions. \r\n                        If you use a custom ordering system, you can disable \r\n                        this behavior, but it's strongly recommended that you \r\n                        don't! If you're unsure, just ignore this option.\r\n```\r\n<!-- codegen:end -->\r\n\r\n## License\r\n\r\nSee the [LICENSE file](./LICENSE)\r\n","readmeFilename":"README.md","gitHead":"560ebb3bba3b11358235f6735c424ad945ab71b9","_id":"umzug@3.0.0-beta-cli.9","_nodeVersion":"12.18.0","_npmVersion":"6.14.8","dist":{"integrity":"sha512-njaVMKeJvwarJz1F5DyCKrQ//tcfLpSu4+AyegI1q/Jd8bxSZjaWlYK8AgeMRBHFwhQ2JMle5EHQyUGNF1tZAQ==","shasum":"699714c4e96a75514c314da44378ba34d70dffb8","tarball":"https://registry.npmjs.org/umzug/-/umzug-3.0.0-beta-cli.9.tgz","fileCount":34,"unpackedSize":114194,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJfttN5CRA9TVsSAnZWagAAuFgP/iv74eXePOSVZhRLUE88\nF4Lp86T9eRpzi8J2gZg2LOZXALbty+a6c4pK+x6ZhqYxsaBAkJt+VNHtZsHh\n54M73eUn0CyheeuuRRunIdzWyZZkXFTccwaeZ0jgfx1tRfmL/DHygFvdwfJE\nZAXHuGCp3S+5Vs1XHtuJz531i39OeTvhz0mFuL6oOSbie4TthHcWrvnMwFCk\nqCN7oOWJ2ssIsZBffiOguh7X/w2ZIZ14gs6uXGpoKWaTyAeMq6mYicggOESb\nbSs+gAI0LbdtbNgiLrw9rQyP947s7Ph8IDGMSo6gjqcBfCx2qdOBAtmOuTSM\nPF99N2+gAp5/saG6ZOMqdPyDmDsqSELD6c6eRoXefl9cCEcGZ/adGQUx/6qN\n9IE50m4ql4Q8bzuXYrO3u+K0ICX6WMZF1SqrB7+pq5tsxsnRzRw4BrZWJljN\nW/N1VSLKcOLYdm3qmmjcHbJvqnB2RR40JaGChZI7x0FhiS9Mch4aSNCq/UfW\ncPI5yWndFr9zcomIW1HJzsrT0zFPGGiTXaSNIPE5KpOD0NWbSnQuMpAfy0o2\nkVdcxUgoyub+49ZWjscjghNJnG9eD/zQcRj76vU0ih8GHXRXa9ThRN0Sr5ZP\nzCvaDhdZWhXdtkSmivPQRGuImh0TNXuCFj+avK6Qc9wp0gr8vDXzj7dZgKGQ\nuApI\r\n=rYoT\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIEY2iBG4KWmdDSQgMcw5EtYzm2z5xGYOC9/sYrpu79wMAiEA/+DiT8f4lXQNSkiJ+SvEXCgihgn6Qo+RQXuQUV00buo="}]},"_npmUser":{"name":"mmkale","email":"mmkal1@outlook.com"},"directories":{},"maintainers":[{"name":"pascal.pflaum","email":"mail@pascalpflaum.de"},{"name":"sdepold","email":"sascha@depold.com"},{"name":"sushantdhiman","email":"sushantdhiman@outlook.com"},{"name":"papb","email":"papb1996@gmail.com"},{"name":"mmkale","email":"mmkal1@outlook.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/umzug_3.0.0-beta-cli.9_1605817209460_0.14984444216353587"},"_hasShrinkwrap":false},"3.0.0-beta-cli.10":{"name":"umzug","version":"3.0.0-beta-cli.10","description":"Framework-agnostic migration tool for Node","keywords":["migrate","migration","migrations","sequelize","database"],"main":"lib/index.js","dependencies":{"@rushstack/ts-command-line":"^4.7.7","fs-jetpack":"^4.0.0","glob":"^7.1.6","type-fest":"^0.19.0"},"devDependencies":{"@types/jest":"26.0.15","@types/uuid":"8.3.0","@typescript-eslint/eslint-plugin":"4.8.1","@typescript-eslint/parser":"4.8.1","del-cli":"3.0.1","eslint":"7.13.0","eslint-config-xo":"0.33.1","eslint-config-xo-typescript":"0.35.0","eslint-plugin-codegen":"0.14.0","eslint-plugin-import":"2.22.1","eslint-plugin-jest":"24.1.3","eslint-plugin-mocha":"8.0.0","eslint-plugin-prettier":"3.1.4","eslint-plugin-unicorn":"23.0.0","expect-type":"0.9.0","fs-syncer":"0.3.0","jest":"26.6.3","lodash":"4.17.20","np":"7.0.0","prettier":"2.1.2","sequelize":"5.22.3","sinon":"9.2.1","source-map-support":"0.5.19","sqlite3":"5.0.0","ts-jest":"26.4.4","typescript":"4.0.5","uuid":"8.3.1"},"scripts":{"build":"del-cli lib && tsc","lint":"eslint --ext .js,.ts,.md . --max-warnings 0","prepare":"npm run build","release":"np --no-yarn --no-2fa","pretest":"del-cli test/generated","test":"jest"},"repository":{"type":"git","url":"git+https://github.com/sequelize/umzug.git"},"author":{"name":"Sascha Depold","email":"sascha@depold.com"},"contributors":[{"name":"Jukka Hyytiälä","email":"hyytiala.jukka@gmail.com"},{"name":"Pascal Pflaum","email":"mail@pascalpflaum.de"},{"name":"Pedro Augusto de Paula Barbosa","email":"papb1996@gmail.com"}],"license":"MIT","bugs":{"url":"https://github.com/sequelize/umzug/issues"},"homepage":"https://github.com/sequelize/umzug","engines":{"node":">=10.0.0"},"jest":{"preset":"ts-jest","globals":{"ts-jest":{"diagnostics":false}},"testEnvironment":"node","testMatch":["**/*test.ts"],"collectCoverageFrom":["src/**"]},"readme":"# Umzug\r\n\r\n[![Build Status](https://badgen.net/github/checks/sequelize/umzug/master)](https://github.com/sequelize/umzug/actions?query=workflow%3ACI)\r\n[![npm (stable)](https://badgen.net/npm/v/umzug)](https://www.npmjs.com/package/umzug)\r\n[![npm (beta)](https://badgen.net/npm/v/umzug/beta)](https://www.npmjs.com/package/umzug/v/beta)\r\n[![npm (downloads)](https://badgen.net/npm/dm/umzug)](https://npmjs.com/package/umzug)\r\n\r\nUmzug is a framework-agnostic migration tool for Node. It provides a clean API for running and rolling back tasks.\r\n\r\n_Note: master represents the next major version of umzug - v3 - which is currently in beta. For the stable version, please refer to the [v2.x branch](https://github.com/sequelize/umzug/tree/v2.x)._\r\n\r\nTo install the v3-beta package:\r\n\r\n```\r\nnpm install umzug@beta\r\n```\r\n\r\nTo install the stable package (v2.x):\r\n\r\n```\r\nnpm install umzug\r\n```\r\n\r\n## Highlights\r\n\r\n* Written in TypeScript\r\n\t* Built-in typings\r\n\t* Auto-completion right in your IDE\r\n\t* Documentation right in your IDE\r\n* Programmatic API for migrations\r\n* Built in [CLI](#cli)\r\n* Database agnostic\r\n* Supports logging of migration process\r\n* Supports multiple storages for migration data\r\n\r\n## Documentation\r\n\r\n### Minimal Example\r\n\r\nThe following example uses a Sqlite database through sequelize and persists the migration data in the database itself through the sequelize storage.\r\n\r\n```js\r\n// index.js\r\nconst { Sequelize } = require('sequelize');\r\nconst { Umzug, SequelizeStorage } = require('umzug');\r\n\r\nconst sequelize = new Sequelize({ dialect: 'sqlite', storage: './db.sqlite' });\r\n\r\nconst umzug = new Umzug({\r\n  migrations: { glob: 'migrations/*.js' },\r\n  context: sequelize.getQueryInterface(),\r\n  storage: new SequelizeStorage({ sequelize }),\r\n  logger: console,\r\n});\r\n\r\n(async () => {\r\n  // Checks migrations and run them if they are not already applied. To keep\r\n  // track of the executed migrations, a table (and sequelize model) called SequelizeMeta\r\n  // will be automatically created (if it doesn't exist already) and parsed.\r\n  await umzug.up();\r\n})();\r\n```\r\n\r\n```js\r\n// migrations/00_initial.js\r\n\r\nconst { Sequelize } = require('sequelize');\r\n\r\nasync function up({ context: queryInterface }) {\r\n\tawait queryInterface.createTable('users', {\r\n\t\tid: {\r\n\t\t\ttype: Sequelize.INTEGER,\r\n\t\t\tallowNull: false,\r\n\t\t\tprimaryKey: true\r\n\t\t},\r\n\t\tname: {\r\n\t\t\ttype: Sequelize.STRING,\r\n\t\t\tallowNull: false\r\n\t\t},\r\n\t\tcreatedAt: {\r\n\t\t\ttype: Sequelize.DATE,\r\n\t\t\tallowNull: false\r\n\t\t},\r\n\t\tupdatedAt: {\r\n\t\t\ttype: Sequelize.DATE,\r\n\t\t\tallowNull: false\r\n\t\t}\r\n\t});\r\n}\r\n\r\nasync function down({ context: queryInterface }) {\r\n\tawait queryInterface.dropTable('users');\r\n}\r\n\r\nmodule.exports = { up, down };\r\n```\r\n\r\nNote that we renamed the `context` argument to `queryInterface` for clarity. The `context` is whatever we specified when creating the Umzug instance in `index.js`.\r\n\r\n<details>\r\n<summary>You can also write your migrations in typescript by using `ts-node` in the entrypoint:</summary>\r\n\r\n```typescript\r\n// index.ts\r\nrequire('ts-node/register')\r\n\r\nimport { Sequelize } from 'sequelize';\r\nimport { Umzug, SequelizeStorage } from 'umzug';\r\n\r\nconst sequelize = new Sequelize({ dialect: 'sqlite', storage: './db.sqlite' });\r\n\r\nconst umzug = new Umzug({\r\n  migrations: { glob: 'migrations/*.ts' },\r\n  context: sequelize.getQueryInterface(),\r\n  storage: new SequelizeStorage({ sequelize }),\r\n  logger: console,\r\n});\r\n\r\n// export the type helper exposed by umzug, which will have the `context` argument typed correctly\r\nexport type Migration = typeof umzug._types.migration;\r\n\r\n(async () => {\r\n  await umzug.up();\r\n})();\r\n```\r\n\r\n```typescript\r\n// migrations/00_initial.ts\r\nimport type { Migration } from '..';\r\n\r\n// types will now be available for `queryInterface`\r\nexport const up: Migration = ({ context: queryInterface }) => queryInterface.createTable(...)\r\nexport const down: Migration = ({ context: queryInterface }) => queryInterface.dropTable(...)\r\n```\r\n</details>\r\n\r\nSee [these tests](./test/umzug.test.ts) for more examples of Umzug usage, including:\r\n\r\n- passing `ignore` and `cwd` parameters to the glob instructions\r\n- customising migrations ordering\r\n- finding migrations from multiple different directories\r\n- using non-js file extensions via a custom resolver, e.g. `.sql`\r\n\r\n### Usage\r\n\r\n#### Installation\r\n\r\nThe beta version of Umzug is available on npm by specifying the correct tag:\r\n\r\n```bash\r\nnpm install umzug@beta\r\n```\r\n\r\n#### Umzug instance\r\n\r\nIt is possible to configure an Umzug instance by passing an object to the constructor.\r\n\r\n```js\r\nconst { Umzug } = require('umzug');\r\nconst umzug = new Umzug({ /* ... options ... */ });\r\n```\r\n\r\nDetailed documentation for these options are in the `UmzugConstructorOptions` TypeScript interface, which can be found in [src/types.ts](./src/types.ts).\r\n\r\n#### Getting all pending migrations\r\n\r\nYou can get a list of pending (i.e. not yet executed) migrations with the `pending()` method:\r\n\r\n```js\r\nconst migrations = await umzug.pending();\r\n// returns an array of all pending migrations.\r\n```\r\n\r\n#### Getting all executed migrations\r\n\r\nYou can get a list of already executed migrations with the `executed()` method:\r\n\r\n```js\r\nconst migrations = await umzug.executed();\r\n// returns an array of all already executed migrations\r\n```\r\n\r\n#### Executing pending migrations\r\n\r\nThe `up` method can be used to execute all pending migrations.\r\n\r\n```js\r\nconst migrations = await umzug.up();\r\n// returns an array of all executed migrations\r\n```\r\n\r\nIt is also possible to pass the name of a migration in order to just run the migrations from the current state to the passed migration name (inclusive).\r\n\r\n```js\r\nawait umzug.up({ to: '20141101203500-task' });\r\n```\r\n\r\nTo limit the number of migrations that are run, `step` can be used:\r\n\r\n```js\r\nawait umzug.up({ step: 2 })\r\n```\r\n\r\nRunning specific migrations while ignoring the right order, can be done like this:\r\n\r\n```js\r\nawait umzug.up({ migrations: ['20141101203500-task', '20141101203501-task-2'] });\r\n```\r\n\r\n#### Reverting executed migration\r\n\r\nThe `down` method can be used to revert the last executed migration.\r\n\r\n```js\r\nconst migration = await umzug.down();\r\n// reverts the last migration and returns it.\r\n```\r\n\r\nTo revert more than one migration, you can use `step`:\r\n\r\n```js\r\nawait umzug.down({ step: 2 });\r\n```\r\n\r\nIt is possible to pass the name of a migration until which (inclusive) the migrations should be reverted. This allows the reverting of multiple migrations at once.\r\n\r\n```js\r\nconst migrations = await umzug.down({ to: '20141031080000-task' });\r\n// returns an array of all reverted migrations.\r\n```\r\n\r\nTo revert all migrations, you can pass 0 as the `to` parameter:\r\n\r\n```js\r\nawait umzug.down({ to: 0 });\r\n```\r\n\r\nReverting specific migrations while ignoring the right order, can be done like this:\r\n\r\n```js\r\nawait umzug.down({ migrations: ['20141101203500-task', '20141101203501-task-2'] });\r\n```\r\n\r\n### Migrations\r\n\r\nThere are two ways to specify migrations: via files or directly via an array of migrations.\r\n\r\n#### Migration files\r\n\r\nA migration file ideally exposes an `up` and a `down` async functions. They will perform the task of upgrading or downgrading the database.\r\n\r\n```js\r\nmodule.exports = {\r\n  async up() {\r\n    /* ... */\r\n  },\r\n  async down() {\r\n    /* ... */\r\n  }\r\n};\r\n```\r\n\r\nMigration files can be located anywhere - they will typically be loaded according to a glob pattern provided to the `Umzug` constructor.\r\n\r\n#### Direct migrations list\r\n\r\nYou can also specify directly a list of migrations to the `Umzug` constructor:\r\n\r\n```js\r\nconst { Umzug } = require('umzug');\r\n\r\nconst umzug = new Umzug({\r\n  migrations: [\r\n    {\r\n      // the name of the migration is mandatory\r\n      name: '00-first-migration',\r\n      async up({ context }) { /* ... */ },\r\n      async down({ context }) { /* ... */ }\r\n    },\r\n    {\r\n      name: '01-foo-bar-migration',\r\n      async up({ context }) { /* ... */ },\r\n      async down({ context }) { /* ... */ }\r\n    }\r\n  ],\r\n  context: sequelize.getQueryInterface(),\r\n  logger: console,\r\n});\r\n```\r\n\r\nTo load migrations in another format, you can use the `resolve` function:\r\n\r\n```js\r\nconst { Umzug } = require('umzug')\r\nconst { Sequelize } = require('sequelize')\r\nconst fs = require('fs')\r\n\r\nconst umzug = new Umzug({\r\n  migrations: {\r\n    glob: 'migrations/*.up.sql',\r\n    resolve: ({ name, path, context: sequelize }) => ({\r\n      name,\r\n      up: async () => {\r\n        const sql = fs.readFileSync(path).toString()\r\n        return sequelize.query(sql)\r\n      },\r\n      down: async () => {\r\n        // Get the corresponding `.down.sql` file to undo this migration\r\n        const sql = fs.readFileSync(path.replace('.up.sql', '.down.sql')).toString()\r\n        return sequelize.query(sql)\r\n      }\r\n    })\r\n  },\r\n  context: new Sequelize(...),\r\n  logger: console,\r\n});\r\n```\r\n\r\nYou can support mixed migration file types, and use umzug's default resolver for javascript/typescript:\r\n\r\n```js\r\nconst { Umzug } = require('umzug')\r\nconst { Sequelize } = require('sequelize')\r\nconst fs = require('fs')\r\n\r\nconst umzug = new Umzug({\r\n  migrations: {\r\n    glob: 'migrations/*.{js,ts,up.sql}',\r\n    resolve: (params) => {\r\n      if (!params.path.endsWith('.sql')) {\r\n        return Umzug.defaultResolver(params)\r\n      }\r\n      const { context: sequelize } = params\r\n      return {\r\n        name: params.name,\r\n        up: async () => {\r\n          const sql = fs.readFileSync(params.path).toString()\r\n          return sequelize.query(sql)\r\n        },\r\n        down: async () => {\r\n          // Get the corresponding `.down.sql` file to undo this migration\r\n          const sql = fs.readFileSync(params.path.replace('.up.sql', '.down.sql')).toString()\r\n          return sequelize.query(sql)\r\n        }\r\n      }\r\n    },\r\n  },\r\n  logger: console,\r\n  context: new Sequelize(...),\r\n});\r\n```\r\n\r\nThe glob syntax allows loading migrations from multiple locations:\r\n\r\n```js\r\nconst { Umzug } = require('umzug')\r\nconst { Sequelize } = require('sequelize')\r\n\r\nconst umzug = new Umzug({\r\n  migrations: {\r\n    glob: '{first-folder/*.js,second-folder-with-different-naming-convention/*.js}',\r\n  },\r\n  context: new Sequelize(...),\r\n  logger: console,\r\n});\r\n```\r\n\r\nNote on migration file sorting:\r\n\r\n- file matches, found using [glob](https://npmjs.com/package/glob), will be lexicographically sorted based on their paths\r\n  - so if your migrations are `one/m1.js`, `two/m2.js`, `three/m3.js`, the resultant order will be `one/m1.js`, `three/m3.js`, `two/m2.js`\r\n  - similarly, if your migrations are called `m1.js`, `m2.js`, ... `m10.js`, `m11.js`, the resultant ordering will be `m1.js`, `m10.js`, `m11.js`, ... `m2.js`\r\n- The easiest way to deal with this is to ensure your migrations appear in a single folder, and their paths match lexicographically with the order they should run in\r\n- If this isn't possible, the ordering can be customised using `.extend(...)` (see below)\r\n\r\n### Upgrading from v2.x\r\n\r\nThe Umzug class should be imported as a named import, i.e. `import { Umzug } from 'umzug'`.\r\n\r\nThe `MigrationMeta` type, which is returned by `umzug.executed()` and `umzug.pending()`, no longer has a `file` property - it has a `name` and *optional* `path` - since migrations are not necessarily bound to files on the file system.\r\n\r\nThe `migrations.glob` parameter replaces `path`, `pattern` and `traverseDirectories`. It can be used, in combination with `cwd` and `ignore` to do much more flexible file lookups. See https://npmjs.com/package/glob for more information on the syntax.\r\n\r\nThe `migrations.resolve` parameter replaces `customResolver`. Explicit support for `wrap` and `nameFormatter` has been removed - these can be easily implemented in a `resolve` function.\r\n\r\nThe constructor option `logging` is replaced by `logger` to allow for `warn` and `error` messages in future. NodeJS's global `console` object can be passed to this. To disable logging, replace `logging: false` with `logger: undefined`.\r\n\r\nThe `Umzug#execute` method is removed. Use `Umzug#up` or `Umzug#down`.\r\n\r\nThe options for `Umguz#up` and `Umzug#down` have changed:\r\n- `umzug.up({ to: 'some-name' })` and `umzug.down({ to: 'some-name' })` are still valid.\r\n- `umzug.up({ from: '...' })` and `umzug.down({ from: '...' })` are no longer supported. To run migrations out-of-order (which is not generally recommended), you can explicitly use `umzug.up({ migrations: ['...'] })` and `umzug.down({ migrations: ['...'] })`.\r\n- name matches must be exact. `umzug.up({ to: 'some-n' })` will no longer match a migration called `some-name`.\r\n- `umzug.down({ to: 0 })` is still valid but `umzug.up({ to: 0 })` is not.\r\n- `umzug.up({ migrations: ['m1', 'm2'] })` is still valid but the shorthand `umzug.up(['m1', 'm2'])` has been removed.\r\n- `umzug.down({ migrations: ['m1', 'm2'] })` is still valid but the shorthand `umzug.down(['m1', 'm2'])` has been removed.\r\n- `umzug.up({ migrations: ['m1', 'already-run'] })` will throw an error, if `already-run` is not found in the list of pending migrations.\r\n- `umzug.down({ migrations: ['m1', 'has-not-been-run'] })` will throw an error, if `has-not-been-run` is not found in the list of executed migrations.\r\n- `umzug.up({ migrations: ['m1', 'm2'], rerun: 'ALLOW' })` will re-apply migrations `m1` and `m2` even if they've already been run.\r\n- `umzug.up({ migrations: ['m1', 'm2'], rerun: 'SKIP' })` will skip migrations `m1` and `m2` if they've already been run.\r\n- `umzug.down({ migrations: ['m1', 'm2'], rerun: 'ALLOW' })` will \"revert\" migrations `m1` and `m2` even if they've never been run.\r\n- `umzug.down({ migrations: ['m1', 'm2'], rerun: 'SKIP' })` will skip reverting migrations `m1` and `m2` if they haven't been run or are already reverted.\r\n- `umzug.up({ migrations: ['m1', 'does-not-exist', 'm2'] })` will throw an error if the migration name is not found. Note that the error will be thrown and no migrations run unless _all_ migration names are found - whether or not `rerun: 'ALLOW'` is added.\r\n\r\nThe `context` parameter replaces `params`, and is passed in as a property to migration functions as an options object, alongs side `name` and `path`. This means the signature for migrations, which in v2 was `(context) => Promise<void>`, has changed slightly in v3, to `({ name, path, context }) => Promise<void>`. The `resolve` function can also be used to upgrade your umzug version to v3 when you have existing v2-compatible migrations:\r\n\r\n```js\r\nconst { Umzug } = require('umzug');\r\n\r\nconst umzug = new Umzug({\r\n  migrations: {\r\n    glob: 'migrations/umzug-v2-format/*.js',\r\n    resolve: ({name, path, context}) => {\r\n      // Adjust the migration from the new signature to the v2 signature, making easier to upgrade to v3\r\n      const migration = require(path)\r\n      return { name, up: async () => migration.up(context), down: async () => migration.down(context) }\r\n    }\r\n  },\r\n  context: sequelize.getQueryInterface(),\r\n  logger: console,\r\n});\r\n```\r\n\r\nSimilarly, you no longer need `migrationSorting`, you can use `Umzug#extend` to manipulate migration lists directly:\r\n\r\n```js\r\nconst { Umzug } = require('umzug');\r\n\r\nconst umzug =\r\n  new Umzug({\r\n    migrations: { glob: 'migrations/**/*.js' },\r\n    context: sequelize.getQueryInterface(),\r\n  })\r\n  .extend(migrations => migrations.sort((a, b) => b.path.localeCompare(a.path)));\r\n```\r\n\r\n### Storages\r\n\r\nStorages define where the migration data is stored.\r\n\r\n#### JSON Storage\r\n\r\nUsing `JSONStorage` will create a JSON file which will contain an array with all the executed migrations. You can specify the path to the file. The default for that is `umzug.json` in the working directory of the process.\r\n\r\nDetailed documentation for the options it can take are in the `JSONStorageConstructorOptions` TypeScript interface, which can be found in [src/storage/json.ts](./src/storage/json.ts).\r\n\r\n#### Memory Storage\r\n\r\nUsing `memoryStorage` will store migrations with an in-memory array. This can be useful for proof-of-concepts or tests, since it doesn't interact with databases or filesystems.\r\n\r\nIt doesn't take any options, just import the `memoryStorage` function and call it to return a storage instance:\r\n\r\n```typescript\r\nimport { Umzug, memoryStorage } from 'umzug'\r\n\r\nconst umzug = new Umzug({\r\n  migrations: ...,\r\n  storage: memoryStorage(),\r\n  logger: console,\r\n})\r\n```\r\n\r\n#### Sequelize Storage\r\n\r\nUsing `SequelizeStorage` will create a table in your SQL database called `SequelizeMeta` containing an entry for each executed migration. You will have to pass a configured instance of Sequelize or an existing Sequelize model. Optionally you can specify the model name, table name, or column name. All major Sequelize versions are supported.\r\n\r\nDetailed documentation for the options it can take are in the `_SequelizeStorageConstructorOptions` TypeScript interface, which can be found in [src/storage/sequelize.ts](./src/storage/sequelize.ts).\r\n\r\n#### MongoDB Storage\r\n\r\nUsing `MongoDBStorage` will create a collection in your MongoDB database called `migrations` containing an entry for each executed migration. You will have either to pass a MongoDB Driver Collection as `collection` property. Alternatively you can pass a established MongoDB Driver connection and a collection name.\r\n\r\nDetailed documentation for the options it can take are in the `MongoDBStorageConstructorOptions` TypeScript interface, which can be found in [src/storage/mongodb.ts](./src/storage/mongodb.ts).\r\n\r\n#### Custom\r\n\r\nIn order to use a custom storage, you can pass your storage instance to Umzug constructor.\r\n\r\n```js\r\nclass CustomStorage {\r\n  constructor(...) {...}\r\n  logMigration(...) {...}\r\n  unlogMigration(...) {...}\r\n  executed(...) {...}\r\n}\r\n\r\nconst umzug = new Umzug({ storage: new CustomStorage(...), logger: console })\r\n```\r\n\r\nYour instance must adhere to the [UmzugStorage](./src/storage/contract.ts) interface. If you're using TypeScript you can ensure this at compile time, and get IDE type hints by importing it:\r\n\r\n```typescript\r\nimport { UmzugStorage } from 'umzug'\r\n\r\nclass CustomStorage implements UmzugStorage {\r\n  /* ... */\r\n}\r\n```\r\n\r\n### Creating migrations - API\r\n\r\nUmzug includes an optional helper for generating migration files. This will, by default, include a timestamp-based prefix and generate a file in the same folder as the most recent existing migration. It also includes some safety checks to make sure migrations aren't created with ambiguous ordering, and that they will be picked up by umzug when applying migrations. It's often most convenient to create files using the [CLI helper](#creating-migrations---cli), but the equivalent API also exists on an umzug instance:\r\n\r\n```js\r\nawait umzug.create({ name: 'my-new-migration.js' })\r\n```\r\n\r\nUmzug ships with a barebones default template for js, ts and sql migration files, but you can specify the template for your project when constructing an umzug instance. The `template` property should be a function which receives a filepath string, and returns an array of `[filepath, content]` pairs. Usually, just one pair is needed, but a second could be used to include a \"down\" migration in a separate file:\r\n\r\n```js\r\nconst umzug = new Umzug({\r\n  migrations: ...,\r\n  template: filepath => [\r\n    [\r\n      filepath,\r\n      dedent`\r\n        import { Migration } from '@my-team/migration-type'\r\n        import { logger } from '@my-team/custom-logger'\r\n\r\n        export const up: Migration = params => {\r\n          logger.info('running migration', params.name)\r\n        }\r\n\r\n        export const down: Migration = params => {\r\n          logger.info('reverting migration', params.name)\r\n        }\r\n      `\r\n    ],\r\n  ]\r\n})\r\n```\r\n\r\nTo create blank migration files, return an empty array:\r\n\r\n```js\r\nconst umzug = new Umzug({\r\n  migrations: ...,\r\n  template: () => [],\r\n})\r\n```\r\n\r\n### Events\r\n\r\nUmzug is an [EventEmitter](https://nodejs.org/docs/latest-v10.x/api/events.html#events_class_eventemitter). Each of the following events will be called with `name` and `migration` as arguments. Events are a convenient place to implement application-specific logic that must run around each migration:\r\n\r\n* `migrating` - A migration is about to be executed.\r\n* `migrated` - A migration has successfully been executed.\r\n* `reverting` - A migration is about to be reverted.\r\n* `reverted` - A migration has successfully been reverted.\r\n\r\n### CLI\r\n\r\nUmzug has an optional built-in CLI helper. To use it, call the `.runAsCLI()` method from an `Umzug` instance:\r\n\r\n```js\r\n// my-umzug-migrator.js\r\nconst { Umzug } = require('umzug')\r\n\r\nexports.umzug = new Umzug({ ... })\r\n\r\nif (require.main === module) {\r\n  umzug.runAsCLI()\r\n}\r\n```\r\n\r\nThis script is now a runnable CLI program, complete with help text. You can run `node my-umzug-migrator.js --help` to see how to use it. It'll print something like\r\n\r\n<!-- codegen:start {preset: custom, source: ./codegen.js, export: cliHelp} -->\r\n```\r\nusage: <script> [-h] <command> ...\r\n\r\nUmzug migrator\r\n\r\nPositional arguments:\r\n  <command>\r\n    up        Applies pending migrations\r\n    down      Revert migrations\r\n    pending   Lists pending migrations\r\n    executed  Lists executed migrations\r\n    create    Create a migration file\r\n\r\nOptional arguments:\r\n  -h, --help  Show this help message and exit.\r\n\r\nFor detailed help about a specific command, use: <script> <command> -h\r\n```\r\n<!-- codegen:end -->\r\n\r\n#### Running migrations\r\n\r\n`node my-umzug-migrator up` and `node my-umzug-migrator down` apply and revert migrations respectively. They're the equivalent of the `.up()` and `.down()` methods.\r\n\r\nUse `node my-umzug-migrator up --help` and `node my-umzug-migrator down --help` for options (running \"to\" a specific migration, passing migration names to be run explicitly, and specifying the rerun behavior):\r\n\r\nUp:\r\n<!-- codegen:start {preset: custom, source: ./codegen.js, export: cliHelp, action: up} -->\r\n```\r\nusage: <script> up [-h] [--to NAME] [--step COUNT] [--migration NAME]\r\n                   [--rerun {THROW,SKIP,ALLOW}]\r\n                   \r\n\r\nPerforms all migrations. See --help for more options\r\n\r\nOptional arguments:\r\n  -h, --help            Show this help message and exit.\r\n  --to NAME             All migrations up to and including this one should be \r\n                        applied.\r\n  --step COUNT          Run this many migrations. If not specified, all will \r\n                        be applied.\r\n  --migration NAME      List of migrations to be applied\r\n  --rerun {THROW,SKIP,ALLOW}\r\n                        Specify what action should be taken when a migration \r\n                        that has already been applied is passed. The default \r\n                        value is \"THROW\".\r\n```\r\n<!-- codegen:end -->\r\n\r\nDown:\r\n<!-- codegen:start {preset: custom, source: ./codegen.js, export: cliHelp, action: down} -->\r\n```\r\nusage: <script> down [-h] [--to NAME] [--step COUNT] [--migration NAME]\r\n                     [--rerun {THROW,SKIP,ALLOW}]\r\n                     \r\n\r\nUndoes previously-applied migrations. By default, undoes the most recent \r\nmigration only. Use --help for more options. Useful in development to start \r\nfrom a clean slate. Use with care in production!\r\n\r\nOptional arguments:\r\n  -h, --help            Show this help message and exit.\r\n  --to NAME             All migrations up to and including this one should be \r\n                        reverted. Pass \"0\" to revert all.\r\n  --step COUNT          Run this many migrations. If not specified, one will \r\n                        be reverted.\r\n  --migration NAME      List of migrations to be reverted\r\n  --rerun {THROW,SKIP,ALLOW}\r\n                        Specify what action should be taken when a migration \r\n                        that has already been reverted is passed. The default \r\n                        value is \"THROW\".\r\n```\r\n<!-- codegen:end -->\r\n\r\n\r\n#### Listing migrations\r\n\r\n```bash\r\nnode my-umzug-migrator pending # list migrations yet to be run\r\nnode my-umzug-migrator executed # list migrations that have already run\r\n\r\nnode my-umzug-migrator pending --json # list pending migrations including names and paths, in a json array format\r\nnode my-umzug-migrator executed --json # list executed migrations including names and paths, in a json array format\r\n\r\nnode my-umzug-migrator pending --help # show help/options\r\nnode my-umzug-migrator executed --help # show help/options\r\n```\r\n\r\n<!-- codegen:start {preset: custom, source: ./codegen.js, export: cliHelp, action: pending} -->\r\n```\r\nusage: <script> pending [-h] [--json]\r\n\r\nPrints migrations returned by `umzug.pending()`. By default, prints migration \r\nnames one per line.\r\n\r\nOptional arguments:\r\n  -h, --help  Show this help message and exit.\r\n  --json      Print pending migrations in a json format including names and \r\n              paths. This allows piping output to tools like jq. Without this \r\n              flag, the migration names will be printed one per line.\r\n```\r\n<!-- codegen:end -->\r\n\r\n<!-- codegen:start {preset: custom, source: ./codegen.js, export: cliHelp, action: executed} -->\r\n```\r\nusage: <script> executed [-h] [--json]\r\n\r\nPrints migrations returned by `umzug.executed()`. By default, prints \r\nmigration names one per line.\r\n\r\nOptional arguments:\r\n  -h, --help  Show this help message and exit.\r\n  --json      Print executed migrations in a json format including names and \r\n              paths. This allows piping output to tools like jq. Without this \r\n              flag, the migration names will be printed one per line.\r\n```\r\n<!-- codegen:end -->\r\n\r\n\r\n\r\n#### Creating migrations - CLI\r\n\r\nUsually, migrations correspond to files on the filesystem. The CLI exposes a way to create migration files easily:\r\n\r\n```bash\r\nnode my-umzug-migrator create --name my-migration.js\r\n```\r\n\r\nThis will create a file with a name like `2000.12.25T12.34.56.my-migration.js` in the same directory as the most recent migration file. If it's the very first migration file, you need to specify the folder explicitly:\r\n\r\n```bash\r\nnode my-umzug-migrator create --name my-migration.js --folder path/to/directory\r\n```\r\n\r\nThe timestamp prefix can be customized to be date-only or omitted, but be aware that it's strongly recommended to ensure your migrations are lexicographically sortable so it's easy for humans and tools to determine what order they should run in - so the default prefix is recommended.\r\n\r\nUse `node my-umzug-migrator create --help` for more options:\r\n\r\n<!-- codegen:start {preset: custom, source: ./codegen.js, export: cliHelp, action: create} -->\r\n```\r\nusage: <script> create [-h] --name NAME [--prefix {TIMESTAMP,DATE,NONE}]\r\n                       [--folder PATH] [--allow-extension EXTENSION]\r\n                       [--skip-verify] [--allow-confusing-ordering]\r\n                       \r\n\r\nGenerates a placeholder migration file using a timestamp as a prefix. By \r\ndefault, mimics the last existing migration, or guesses where to generate the \r\nfile if no migration exists yet.\r\n\r\nOptional arguments:\r\n  -h, --help            Show this help message and exit.\r\n  --name NAME           The name of the migration file. e.g. my-migration.js, \r\n                        my-migration.ts or my-migration.sql. Note - a prefix \r\n                        will be added to this name, usually based on a \r\n                        timestamp. See --prefix\r\n  --prefix {TIMESTAMP,DATE,NONE}\r\n                        The prefix format for generated files. TIMESTAMP uses \r\n                        a second-resolution timestamp, DATE uses a \r\n                        day-resolution timestamp, and NONE removes the prefix \r\n                        completely. The default value is \"TIMESTAMP\".\r\n  --folder PATH         Path on the filesystem where the file should be \r\n                        created. The new migration will be created as a \r\n                        sibling of the last existing one if this is omitted.\r\n  --allow-extension EXTENSION\r\n                        Allowable extension for created files. By default .js,\r\n                         .ts and .sql files can be created. To create txt \r\n                        file migrations, for example, you could use '--name \r\n                        my-migration.txt --allow-extension .txt' This \r\n                        parameter may alternatively be specified via the \r\n                        UMZUG_ALLOW_EXTENSION environment variable.\r\n  --skip-verify         By default, the generated file will be checked after \r\n                        creation to make sure it is detected as a pending \r\n                        migration. This catches problems like creation in the \r\n                        wrong folder, or invalid naming conventions. This \r\n                        flag bypasses that verification step.\r\n  --allow-confusing-ordering\r\n                        By default, an error will be thrown if you try to \r\n                        create a migration that will run before a migration \r\n                        that already exists. This catches errors which can \r\n                        cause problems if you change file naming conventions. \r\n                        If you use a custom ordering system, you can disable \r\n                        this behavior, but it's strongly recommended that you \r\n                        don't! If you're unsure, just ignore this option.\r\n```\r\n<!-- codegen:end -->\r\n\r\n## License\r\n\r\nSee the [LICENSE file](./LICENSE)\r\n","readmeFilename":"README.md","gitHead":"13ba58bc2ffb3bc935a4128e90455f712b7fb465","_id":"umzug@3.0.0-beta-cli.10","_nodeVersion":"12.18.0","_npmVersion":"6.14.8","dist":{"integrity":"sha512-xs7OihnGx1Sq0efz44ax7wQfOS1O3/i11uzeP1PTItqPZVVdA/NjJlLquFapJbZTWv0vhxy57652Zf0TRCaPYg==","shasum":"741990717598992873cd04a935d302e3000bf720","tarball":"https://registry.npmjs.org/umzug/-/umzug-3.0.0-beta-cli.10.tgz","fileCount":34,"unpackedSize":113820,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJfuDIiCRA9TVsSAnZWagAAfD4P/1NYacgxnWaOZIWXHmwn\nMMuFtxx1mNfh673GVNWa9mZxvPwCLwCGxKB5lz+gRXQyf/rOmlMhiYSDiJB3\nBWoJoVNAGX+3eTn4VQAJXTZJJ6L72PI+c+142EOHOWWgV04J/uYDHMbRJwqT\nGtlugcgt+ErKEvy7J+S54+bDlqLR4Etb35PhgSxJsFSKcafApGng+e9JmIq6\nhZizuBYyQeY62MmxknK6ZKpoAhU05jWweahHzi+VhxJOWOrAuRWd4UX8gMzr\nYtBvPkW+RWVAkoGYSKRcC8+wrFvaU9Vxadhx2BH0lPffWo8to74mcWri1s3Y\nUUC/e8C344AkKhLlOvYCXx0eRPldu00AJnqVxcCwJ24hN+wPh/04+Mml62ab\nf/x1TUvHAKY7gJdzktGv6Xo123yQ82PDmwIESzmnTmEVH9wdxoDBgiVS7q7a\ndU58MRNds4BUE13SuATAMNSGjUxyhkgPDFBBgGIVoU/U8nsIMjZGS7FG2jAA\nQqmYypKiO9MRyQtlHSapsy73oo+oqbvZ9d8LEriKAxGW0EV455BBDn5/EAFQ\n2TdmbVc2z4wj1DU5D+5sq02JS6pvNA4yY16W/pBFIqScwAhCruZQxO3Tvm0D\nAJ0VmGcOhIUnsh1H0JunnmVAZ6MFdnoPCpoz13G3QWRL2ZLvZPR8PNFcfR9N\n8br3\r\n=LrIr\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEYCIQD0lTKEPLoPooiSttgZWVJxRO2UH+shYTRPa4JDniwZZgIhANu3ZAjWHgrJ2zusrGqFWGUiPEKIydIDNQKMd6zyNlGv"}]},"_npmUser":{"name":"mmkale","email":"mmkal1@outlook.com"},"directories":{},"maintainers":[{"name":"pascal.pflaum","email":"mail@pascalpflaum.de"},{"name":"sdepold","email":"sascha@depold.com"},{"name":"sushantdhiman","email":"sushantdhiman@outlook.com"},{"name":"papb","email":"papb1996@gmail.com"},{"name":"mmkale","email":"mmkal1@outlook.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/umzug_3.0.0-beta-cli.10_1605906977878_0.48705552244281924"},"_hasShrinkwrap":false},"3.0.0-beta-cli.11":{"name":"umzug","version":"3.0.0-beta-cli.11","description":"Framework-agnostic migration tool for Node","keywords":["migrate","migration","migrations","sequelize","database"],"main":"lib/index.js","dependencies":{"@rushstack/ts-command-line":"~4.7.7","emittery":"~0.7.2","fs-jetpack":"~4.0.0","glob":"~7.1.6","type-fest":"~0.19.0"},"devDependencies":{"@types/jest":"26.0.15","@types/uuid":"8.3.0","@typescript-eslint/eslint-plugin":"4.8.2","@typescript-eslint/parser":"4.8.2","del-cli":"3.0.1","eslint":"7.14.0","eslint-config-xo":"0.33.1","eslint-config-xo-typescript":"0.36.0","eslint-plugin-codegen":"0.14.0","eslint-plugin-import":"2.22.1","eslint-plugin-jest":"24.1.3","eslint-plugin-mocha":"8.0.0","eslint-plugin-prettier":"3.1.4","eslint-plugin-unicorn":"23.0.0","expect-type":"0.9.0","fs-syncer":"0.3.0","jest":"26.6.3","lodash":"4.17.20","np":"7.0.0","prettier":"2.2.0","sequelize":"5.22.3","sinon":"9.2.1","source-map-support":"0.5.19","sqlite3":"5.0.0","ts-jest":"26.4.4","typescript":"4.1.2","uuid":"8.3.1"},"scripts":{"build":"del-cli lib && tsc","lint":"eslint --ext .js,.ts,.md . --max-warnings 0","prepare":"npm run build","release":"np --no-yarn --no-2fa","pretest":"del-cli test/generated","test":"jest"},"repository":{"type":"git","url":"git+https://github.com/sequelize/umzug.git"},"author":{"name":"Sascha Depold","email":"sascha@depold.com"},"contributors":[{"name":"Jukka Hyytiälä","email":"hyytiala.jukka@gmail.com"},{"name":"Pascal Pflaum","email":"mail@pascalpflaum.de"},{"name":"Pedro Augusto de Paula Barbosa","email":"papb1996@gmail.com"}],"license":"MIT","bugs":{"url":"https://github.com/sequelize/umzug/issues"},"homepage":"https://github.com/sequelize/umzug","engines":{"node":">=10.0.0"},"jest":{"preset":"ts-jest","globals":{"ts-jest":{"diagnostics":false}},"testEnvironment":"node","testMatch":["**/*test.ts"],"collectCoverageFrom":["src/**"]},"readme":"# Umzug\r\n\r\n[![Build Status](https://badgen.net/github/checks/sequelize/umzug/master)](https://github.com/sequelize/umzug/actions?query=workflow%3ACI)\r\n[![npm (stable)](https://badgen.net/npm/v/umzug)](https://www.npmjs.com/package/umzug)\r\n[![npm (beta)](https://badgen.net/npm/v/umzug/beta)](https://www.npmjs.com/package/umzug/v/beta)\r\n[![npm (downloads)](https://badgen.net/npm/dm/umzug)](https://npmjs.com/package/umzug)\r\n\r\nUmzug is a framework-agnostic migration tool for Node. It provides a clean API for running and rolling back tasks.\r\n\r\n_Note: master represents the next major version of umzug - v3 - which is currently in beta. For the stable version, please refer to the [v2.x branch](https://github.com/sequelize/umzug/tree/v2.x)._\r\n\r\nTo install the v3-beta package:\r\n\r\n```\r\nnpm install umzug@beta\r\n```\r\n\r\nTo install the stable package (v2.x):\r\n\r\n```\r\nnpm install umzug\r\n```\r\n\r\n## Highlights\r\n\r\n* Written in TypeScript\r\n\t* Built-in typings\r\n\t* Auto-completion right in your IDE\r\n\t* Documentation right in your IDE\r\n* Programmatic API for migrations\r\n* Built in [CLI](#cli)\r\n* Database agnostic\r\n* Supports logging of migration process\r\n* Supports multiple storages for migration data\r\n\r\n## Documentation\r\n\r\n### Minimal Example\r\n\r\nThe following example uses a Sqlite database through sequelize and persists the migration data in the database itself through the sequelize storage.\r\n\r\n```js\r\n// index.js\r\nconst { Sequelize } = require('sequelize');\r\nconst { Umzug, SequelizeStorage } = require('umzug');\r\n\r\nconst sequelize = new Sequelize({ dialect: 'sqlite', storage: './db.sqlite' });\r\n\r\nconst umzug = new Umzug({\r\n  migrations: { glob: 'migrations/*.js' },\r\n  context: sequelize.getQueryInterface(),\r\n  storage: new SequelizeStorage({ sequelize }),\r\n  logger: console,\r\n});\r\n\r\n(async () => {\r\n  // Checks migrations and run them if they are not already applied. To keep\r\n  // track of the executed migrations, a table (and sequelize model) called SequelizeMeta\r\n  // will be automatically created (if it doesn't exist already) and parsed.\r\n  await umzug.up();\r\n})();\r\n```\r\n\r\n```js\r\n// migrations/00_initial.js\r\n\r\nconst { Sequelize } = require('sequelize');\r\n\r\nasync function up({ context: queryInterface }) {\r\n\tawait queryInterface.createTable('users', {\r\n\t\tid: {\r\n\t\t\ttype: Sequelize.INTEGER,\r\n\t\t\tallowNull: false,\r\n\t\t\tprimaryKey: true\r\n\t\t},\r\n\t\tname: {\r\n\t\t\ttype: Sequelize.STRING,\r\n\t\t\tallowNull: false\r\n\t\t},\r\n\t\tcreatedAt: {\r\n\t\t\ttype: Sequelize.DATE,\r\n\t\t\tallowNull: false\r\n\t\t},\r\n\t\tupdatedAt: {\r\n\t\t\ttype: Sequelize.DATE,\r\n\t\t\tallowNull: false\r\n\t\t}\r\n\t});\r\n}\r\n\r\nasync function down({ context: queryInterface }) {\r\n\tawait queryInterface.dropTable('users');\r\n}\r\n\r\nmodule.exports = { up, down };\r\n```\r\n\r\nNote that we renamed the `context` argument to `queryInterface` for clarity. The `context` is whatever we specified when creating the Umzug instance in `index.js`.\r\n\r\n<details>\r\n<summary>You can also write your migrations in typescript by using `ts-node` in the entrypoint:</summary>\r\n\r\n```typescript\r\n// index.ts\r\nrequire('ts-node/register')\r\n\r\nimport { Sequelize } from 'sequelize';\r\nimport { Umzug, SequelizeStorage } from 'umzug';\r\n\r\nconst sequelize = new Sequelize({ dialect: 'sqlite', storage: './db.sqlite' });\r\n\r\nconst umzug = new Umzug({\r\n  migrations: { glob: 'migrations/*.ts' },\r\n  context: sequelize.getQueryInterface(),\r\n  storage: new SequelizeStorage({ sequelize }),\r\n  logger: console,\r\n});\r\n\r\n// export the type helper exposed by umzug, which will have the `context` argument typed correctly\r\nexport type Migration = typeof umzug._types.migration;\r\n\r\n(async () => {\r\n  await umzug.up();\r\n})();\r\n```\r\n\r\n```typescript\r\n// migrations/00_initial.ts\r\nimport type { Migration } from '..';\r\n\r\n// types will now be available for `queryInterface`\r\nexport const up: Migration = ({ context: queryInterface }) => queryInterface.createTable(...)\r\nexport const down: Migration = ({ context: queryInterface }) => queryInterface.dropTable(...)\r\n```\r\n</details>\r\n\r\nSee [these tests](./test/umzug.test.ts) for more examples of Umzug usage, including:\r\n\r\n- passing `ignore` and `cwd` parameters to the glob instructions\r\n- customising migrations ordering\r\n- finding migrations from multiple different directories\r\n- using non-js file extensions via a custom resolver, e.g. `.sql`\r\n\r\n### Usage\r\n\r\n#### Installation\r\n\r\nThe beta version of Umzug is available on npm by specifying the correct tag:\r\n\r\n```bash\r\nnpm install umzug@beta\r\n```\r\n\r\n#### Umzug instance\r\n\r\nIt is possible to configure an Umzug instance by passing an object to the constructor.\r\n\r\n```js\r\nconst { Umzug } = require('umzug');\r\nconst umzug = new Umzug({ /* ... options ... */ });\r\n```\r\n\r\nDetailed documentation for these options are in the `UmzugConstructorOptions` TypeScript interface, which can be found in [src/types.ts](./src/types.ts).\r\n\r\n#### Getting all pending migrations\r\n\r\nYou can get a list of pending (i.e. not yet executed) migrations with the `pending()` method:\r\n\r\n```js\r\nconst migrations = await umzug.pending();\r\n// returns an array of all pending migrations.\r\n```\r\n\r\n#### Getting all executed migrations\r\n\r\nYou can get a list of already executed migrations with the `executed()` method:\r\n\r\n```js\r\nconst migrations = await umzug.executed();\r\n// returns an array of all already executed migrations\r\n```\r\n\r\n#### Executing pending migrations\r\n\r\nThe `up` method can be used to execute all pending migrations.\r\n\r\n```js\r\nconst migrations = await umzug.up();\r\n// returns an array of all executed migrations\r\n```\r\n\r\nIt is also possible to pass the name of a migration in order to just run the migrations from the current state to the passed migration name (inclusive).\r\n\r\n```js\r\nawait umzug.up({ to: '20141101203500-task' });\r\n```\r\n\r\nTo limit the number of migrations that are run, `step` can be used:\r\n\r\n```js\r\nawait umzug.up({ step: 2 })\r\n```\r\n\r\nRunning specific migrations while ignoring the right order, can be done like this:\r\n\r\n```js\r\nawait umzug.up({ migrations: ['20141101203500-task', '20141101203501-task-2'] });\r\n```\r\n\r\n#### Reverting executed migration\r\n\r\nThe `down` method can be used to revert the last executed migration.\r\n\r\n```js\r\nconst migration = await umzug.down();\r\n// reverts the last migration and returns it.\r\n```\r\n\r\nTo revert more than one migration, you can use `step`:\r\n\r\n```js\r\nawait umzug.down({ step: 2 });\r\n```\r\n\r\nIt is possible to pass the name of a migration until which (inclusive) the migrations should be reverted. This allows the reverting of multiple migrations at once.\r\n\r\n```js\r\nconst migrations = await umzug.down({ to: '20141031080000-task' });\r\n// returns an array of all reverted migrations.\r\n```\r\n\r\nTo revert all migrations, you can pass 0 as the `to` parameter:\r\n\r\n```js\r\nawait umzug.down({ to: 0 });\r\n```\r\n\r\nReverting specific migrations while ignoring the right order, can be done like this:\r\n\r\n```js\r\nawait umzug.down({ migrations: ['20141101203500-task', '20141101203501-task-2'] });\r\n```\r\n\r\n### Migrations\r\n\r\nThere are two ways to specify migrations: via files or directly via an array of migrations.\r\n\r\n#### Migration files\r\n\r\nA migration file ideally exposes an `up` and a `down` async functions. They will perform the task of upgrading or downgrading the database.\r\n\r\n```js\r\nmodule.exports = {\r\n  async up() {\r\n    /* ... */\r\n  },\r\n  async down() {\r\n    /* ... */\r\n  }\r\n};\r\n```\r\n\r\nMigration files can be located anywhere - they will typically be loaded according to a glob pattern provided to the `Umzug` constructor.\r\n\r\n#### Direct migrations list\r\n\r\nYou can also specify directly a list of migrations to the `Umzug` constructor:\r\n\r\n```js\r\nconst { Umzug } = require('umzug');\r\n\r\nconst umzug = new Umzug({\r\n  migrations: [\r\n    {\r\n      // the name of the migration is mandatory\r\n      name: '00-first-migration',\r\n      async up({ context }) { /* ... */ },\r\n      async down({ context }) { /* ... */ }\r\n    },\r\n    {\r\n      name: '01-foo-bar-migration',\r\n      async up({ context }) { /* ... */ },\r\n      async down({ context }) { /* ... */ }\r\n    }\r\n  ],\r\n  context: sequelize.getQueryInterface(),\r\n  logger: console,\r\n});\r\n```\r\n\r\nTo load migrations in another format, you can use the `resolve` function:\r\n\r\n```js\r\nconst { Umzug } = require('umzug')\r\nconst { Sequelize } = require('sequelize')\r\nconst fs = require('fs')\r\n\r\nconst umzug = new Umzug({\r\n  migrations: {\r\n    glob: 'migrations/*.up.sql',\r\n    resolve: ({ name, path, context: sequelize }) => ({\r\n      name,\r\n      up: async () => {\r\n        const sql = fs.readFileSync(path).toString()\r\n        return sequelize.query(sql)\r\n      },\r\n      down: async () => {\r\n        // Get the corresponding `.down.sql` file to undo this migration\r\n        const sql = fs.readFileSync(path.replace('.up.sql', '.down.sql')).toString()\r\n        return sequelize.query(sql)\r\n      }\r\n    })\r\n  },\r\n  context: new Sequelize(...),\r\n  logger: console,\r\n});\r\n```\r\n\r\nYou can support mixed migration file types, and use umzug's default resolver for javascript/typescript:\r\n\r\n```js\r\nconst { Umzug } = require('umzug')\r\nconst { Sequelize } = require('sequelize')\r\nconst fs = require('fs')\r\n\r\nconst umzug = new Umzug({\r\n  migrations: {\r\n    glob: 'migrations/*.{js,ts,up.sql}',\r\n    resolve: (params) => {\r\n      if (!params.path.endsWith('.sql')) {\r\n        return Umzug.defaultResolver(params)\r\n      }\r\n      const { context: sequelize } = params\r\n      return {\r\n        name: params.name,\r\n        up: async () => {\r\n          const sql = fs.readFileSync(params.path).toString()\r\n          return sequelize.query(sql)\r\n        },\r\n        down: async () => {\r\n          // Get the corresponding `.down.sql` file to undo this migration\r\n          const sql = fs.readFileSync(params.path.replace('.up.sql', '.down.sql')).toString()\r\n          return sequelize.query(sql)\r\n        }\r\n      }\r\n    },\r\n  },\r\n  logger: console,\r\n  context: new Sequelize(...),\r\n});\r\n```\r\n\r\nThe glob syntax allows loading migrations from multiple locations:\r\n\r\n```js\r\nconst { Umzug } = require('umzug')\r\nconst { Sequelize } = require('sequelize')\r\n\r\nconst umzug = new Umzug({\r\n  migrations: {\r\n    glob: '{first-folder/*.js,second-folder-with-different-naming-convention/*.js}',\r\n  },\r\n  context: new Sequelize(...),\r\n  logger: console,\r\n});\r\n```\r\n\r\nNote on migration file sorting:\r\n\r\n- file matches, found using [glob](https://npmjs.com/package/glob), will be lexicographically sorted based on their paths\r\n  - so if your migrations are `one/m1.js`, `two/m2.js`, `three/m3.js`, the resultant order will be `one/m1.js`, `three/m3.js`, `two/m2.js`\r\n  - similarly, if your migrations are called `m1.js`, `m2.js`, ... `m10.js`, `m11.js`, the resultant ordering will be `m1.js`, `m10.js`, `m11.js`, ... `m2.js`\r\n- The easiest way to deal with this is to ensure your migrations appear in a single folder, and their paths match lexicographically with the order they should run in\r\n- If this isn't possible, the ordering can be customised using `.extend(...)` (see below)\r\n\r\n### Upgrading from v2.x\r\n\r\nThe Umzug class should be imported as a named import, i.e. `import { Umzug } from 'umzug'`.\r\n\r\nThe `MigrationMeta` type, which is returned by `umzug.executed()` and `umzug.pending()`, no longer has a `file` property - it has a `name` and *optional* `path` - since migrations are not necessarily bound to files on the file system.\r\n\r\nThe `migrations.glob` parameter replaces `path`, `pattern` and `traverseDirectories`. It can be used, in combination with `cwd` and `ignore` to do much more flexible file lookups. See https://npmjs.com/package/glob for more information on the syntax.\r\n\r\nThe `migrations.resolve` parameter replaces `customResolver`. Explicit support for `wrap` and `nameFormatter` has been removed - these can be easily implemented in a `resolve` function.\r\n\r\nThe constructor option `logging` is replaced by `logger` to allow for `warn` and `error` messages in future. NodeJS's global `console` object can be passed to this. To disable logging, replace `logging: false` with `logger: undefined`.\r\n\r\nEvents have moved from the default nodejs `EventEmitter` to [emittery](https://www.npmjs.com/package/emittery). It has better design for async code, a less bloated API surface and strong types. But, it doesn't allow passing multiple arguments to callbacks, so listeners have to change slightly, as well as `.addListener(...)` and `.removeListener(...)` no longer being supported (`.on(...)` and `.off(...)` should now be used):\r\n\r\nBefore:\r\n\r\n```js\r\numzug.on('migrating', (name, m) => console.log({ name, path: m.path }))\r\n```\r\n\r\nAfter:\r\n\r\n```js\r\numzug.on('migrating', ev => console.log({ name: ev.name, path: ev.path }))\r\n```\r\n\r\nThe `Umzug#execute` method is removed. Use `Umzug#up` or `Umzug#down`.\r\n\r\nThe options for `Umguz#up` and `Umzug#down` have changed:\r\n- `umzug.up({ to: 'some-name' })` and `umzug.down({ to: 'some-name' })` are still valid.\r\n- `umzug.up({ from: '...' })` and `umzug.down({ from: '...' })` are no longer supported. To run migrations out-of-order (which is not generally recommended), you can explicitly use `umzug.up({ migrations: ['...'] })` and `umzug.down({ migrations: ['...'] })`.\r\n- name matches must be exact. `umzug.up({ to: 'some-n' })` will no longer match a migration called `some-name`.\r\n- `umzug.down({ to: 0 })` is still valid but `umzug.up({ to: 0 })` is not.\r\n- `umzug.up({ migrations: ['m1', 'm2'] })` is still valid but the shorthand `umzug.up(['m1', 'm2'])` has been removed.\r\n- `umzug.down({ migrations: ['m1', 'm2'] })` is still valid but the shorthand `umzug.down(['m1', 'm2'])` has been removed.\r\n- `umzug.up({ migrations: ['m1', 'already-run'] })` will throw an error, if `already-run` is not found in the list of pending migrations.\r\n- `umzug.down({ migrations: ['m1', 'has-not-been-run'] })` will throw an error, if `has-not-been-run` is not found in the list of executed migrations.\r\n- `umzug.up({ migrations: ['m1', 'm2'], rerun: 'ALLOW' })` will re-apply migrations `m1` and `m2` even if they've already been run.\r\n- `umzug.up({ migrations: ['m1', 'm2'], rerun: 'SKIP' })` will skip migrations `m1` and `m2` if they've already been run.\r\n- `umzug.down({ migrations: ['m1', 'm2'], rerun: 'ALLOW' })` will \"revert\" migrations `m1` and `m2` even if they've never been run.\r\n- `umzug.down({ migrations: ['m1', 'm2'], rerun: 'SKIP' })` will skip reverting migrations `m1` and `m2` if they haven't been run or are already reverted.\r\n- `umzug.up({ migrations: ['m1', 'does-not-exist', 'm2'] })` will throw an error if the migration name is not found. Note that the error will be thrown and no migrations run unless _all_ migration names are found - whether or not `rerun: 'ALLOW'` is added.\r\n\r\nThe `context` parameter replaces `params`, and is passed in as a property to migration functions as an options object, alongs side `name` and `path`. This means the signature for migrations, which in v2 was `(context) => Promise<void>`, has changed slightly in v3, to `({ name, path, context }) => Promise<void>`. The `resolve` function can also be used to upgrade your umzug version to v3 when you have existing v2-compatible migrations:\r\n\r\n```js\r\nconst { Umzug } = require('umzug');\r\n\r\nconst umzug = new Umzug({\r\n  migrations: {\r\n    glob: 'migrations/umzug-v2-format/*.js',\r\n    resolve: ({name, path, context}) => {\r\n      // Adjust the migration from the new signature to the v2 signature, making easier to upgrade to v3\r\n      const migration = require(path)\r\n      return { name, up: async () => migration.up(context), down: async () => migration.down(context) }\r\n    }\r\n  },\r\n  context: sequelize.getQueryInterface(),\r\n  logger: console,\r\n});\r\n```\r\n\r\nSimilarly, you no longer need `migrationSorting`, you can use `Umzug#extend` to manipulate migration lists directly:\r\n\r\n```js\r\nconst { Umzug } = require('umzug');\r\n\r\nconst umzug =\r\n  new Umzug({\r\n    migrations: { glob: 'migrations/**/*.js' },\r\n    context: sequelize.getQueryInterface(),\r\n  })\r\n  .extend(migrations => migrations.sort((a, b) => b.path.localeCompare(a.path)));\r\n```\r\n\r\n### Storages\r\n\r\nStorages define where the migration data is stored.\r\n\r\n#### JSON Storage\r\n\r\nUsing `JSONStorage` will create a JSON file which will contain an array with all the executed migrations. You can specify the path to the file. The default for that is `umzug.json` in the working directory of the process.\r\n\r\nDetailed documentation for the options it can take are in the `JSONStorageConstructorOptions` TypeScript interface, which can be found in [src/storage/json.ts](./src/storage/json.ts).\r\n\r\n#### Memory Storage\r\n\r\nUsing `memoryStorage` will store migrations with an in-memory array. This can be useful for proof-of-concepts or tests, since it doesn't interact with databases or filesystems.\r\n\r\nIt doesn't take any options, just import the `memoryStorage` function and call it to return a storage instance:\r\n\r\n```typescript\r\nimport { Umzug, memoryStorage } from 'umzug'\r\n\r\nconst umzug = new Umzug({\r\n  migrations: ...,\r\n  storage: memoryStorage(),\r\n  logger: console,\r\n})\r\n```\r\n\r\n#### Sequelize Storage\r\n\r\nUsing `SequelizeStorage` will create a table in your SQL database called `SequelizeMeta` containing an entry for each executed migration. You will have to pass a configured instance of Sequelize or an existing Sequelize model. Optionally you can specify the model name, table name, or column name. All major Sequelize versions are supported.\r\n\r\nDetailed documentation for the options it can take are in the `_SequelizeStorageConstructorOptions` TypeScript interface, which can be found in [src/storage/sequelize.ts](./src/storage/sequelize.ts).\r\n\r\n#### MongoDB Storage\r\n\r\nUsing `MongoDBStorage` will create a collection in your MongoDB database called `migrations` containing an entry for each executed migration. You will have either to pass a MongoDB Driver Collection as `collection` property. Alternatively you can pass a established MongoDB Driver connection and a collection name.\r\n\r\nDetailed documentation for the options it can take are in the `MongoDBStorageConstructorOptions` TypeScript interface, which can be found in [src/storage/mongodb.ts](./src/storage/mongodb.ts).\r\n\r\n#### Custom\r\n\r\nIn order to use a custom storage, you can pass your storage instance to Umzug constructor.\r\n\r\n```js\r\nclass CustomStorage {\r\n  constructor(...) {...}\r\n  logMigration(...) {...}\r\n  unlogMigration(...) {...}\r\n  executed(...) {...}\r\n}\r\n\r\nconst umzug = new Umzug({ storage: new CustomStorage(...), logger: console })\r\n```\r\n\r\nYour instance must adhere to the [UmzugStorage](./src/storage/contract.ts) interface. If you're using TypeScript you can ensure this at compile time, and get IDE type hints by importing it:\r\n\r\n```typescript\r\nimport { UmzugStorage } from 'umzug'\r\n\r\nclass CustomStorage implements UmzugStorage {\r\n  /* ... */\r\n}\r\n```\r\n\r\n### Creating migrations - API\r\n\r\nUmzug includes an optional helper for generating migration files. This will, by default, include a timestamp-based prefix and generate a file in the same folder as the most recent existing migration. It also includes some safety checks to make sure migrations aren't created with ambiguous ordering, and that they will be picked up by umzug when applying migrations. It's often most convenient to create files using the [CLI helper](#creating-migrations---cli), but the equivalent API also exists on an umzug instance:\r\n\r\n```js\r\nawait umzug.create({ name: 'my-new-migration.js' })\r\n```\r\n\r\nUmzug ships with a barebones default template for js, ts and sql migration files, but you can specify the template for your project when constructing an umzug instance. The `template` property should be a function which receives a filepath string, and returns an array of `[filepath, content]` pairs. Usually, just one pair is needed, but a second could be used to include a \"down\" migration in a separate file:\r\n\r\n```js\r\nconst umzug = new Umzug({\r\n  migrations: ...,\r\n  template: filepath => [\r\n    [\r\n      filepath,\r\n      dedent`\r\n        import { Migration } from '@my-team/migration-type'\r\n        import { logger } from '@my-team/custom-logger'\r\n\r\n        export const up: Migration = params => {\r\n          logger.info('running migration', params.name)\r\n        }\r\n\r\n        export const down: Migration = params => {\r\n          logger.info('reverting migration', params.name)\r\n        }\r\n      `\r\n    ],\r\n  ]\r\n})\r\n```\r\n\r\nTo create blank migration files, return an empty array:\r\n\r\n```js\r\nconst umzug = new Umzug({\r\n  migrations: ...,\r\n  template: () => [],\r\n})\r\n```\r\n\r\n### Events\r\n\r\nUmzug is an [emittery event emitter](https://www.npmjs.com/package/emittery). Each of the following events will be called with migration parameters as its payload (with `context`, `name`, and nullable `path` properties). Events are a convenient place to implement application-specific logic that must run around each migration:\r\n\r\n* `migrating` - A migration is about to be executed.\r\n* `migrated` - A migration has successfully been executed.\r\n* `reverting` - A migration is about to be reverted.\r\n* `reverted` - A migration has successfully been reverted.\r\n\r\nThese events run at the beginning and end of `up` and `down` calls. They'll receive an object containing a `context` property:\r\n\r\n- `beforeAll` - Before any of the migrations are run.\r\n- `afterAll` - After all the migrations have been executed. Note: this will always run, even if migrations throw an error.\r\n\r\nThe [`FileLocker` class](./src/file-locker.ts) uses `beforeAll` and `afterAll` to implement a simple filesystem-based locking mechanism.\r\n\r\nAll events are type-safe, so IDEs will prevent typos and supply strong types for the event payloads.\r\n\r\n### CLI\r\n\r\nUmzug has an optional built-in CLI helper. To use it, call the `.runAsCLI()` method from an `Umzug` instance:\r\n\r\n```js\r\n// migrator.js\r\nconst { Umzug } = require('umzug')\r\n\r\nexports.umzug = new Umzug({ ... })\r\n\r\nif (require.main === module) {\r\n  umzug.runAsCLI()\r\n}\r\n```\r\n\r\n#### CLI Usage\r\n\r\nThis script is now a runnable CLI program, complete with help text. You can run `node migrator.js --help` to see how to use it. It'll print something like\r\n\r\n<!-- codegen:start {preset: custom, source: ./codegen.js, export: cliHelp} -->\r\n```\r\nusage: <script> [-h] <command> ...\r\n\r\nUmzug migrator\r\n\r\nPositional arguments:\r\n  <command>\r\n    up        Applies pending migrations\r\n    down      Revert migrations\r\n    pending   Lists pending migrations\r\n    executed  Lists executed migrations\r\n    create    Create a migration file\r\n\r\nOptional arguments:\r\n  -h, --help  Show this help message and exit.\r\n\r\nFor detailed help about a specific command, use: <script> <command> -h\r\n```\r\n<!-- codegen:end -->\r\n\r\n#### Running migrations\r\n\r\n`node migrator up` and `node migrator down` apply and revert migrations respectively. They're the equivalent of the `.up()` and `.down()` methods.\r\n\r\nUse `node migrator up --help` and `node migrator down --help` for options (running \"to\" a specific migration, passing migration names to be run explicitly, and specifying the rerun behavior):\r\n\r\nUp:\r\n<!-- codegen:start {preset: custom, source: ./codegen.js, export: cliHelp, action: up} -->\r\n```\r\nusage: <script> up [-h] [--to NAME] [--step COUNT] [--migration NAME]\r\n                   [--rerun {THROW,SKIP,ALLOW}]\r\n                   \r\n\r\nPerforms all migrations. See --help for more options\r\n\r\nOptional arguments:\r\n  -h, --help            Show this help message and exit.\r\n  --to NAME             All migrations up to and including this one should be \r\n                        applied.\r\n  --step COUNT          Run this many migrations. If not specified, all will \r\n                        be applied.\r\n  --migration NAME      List of migrations to be applied\r\n  --rerun {THROW,SKIP,ALLOW}\r\n                        Specify what action should be taken when a migration \r\n                        that has already been applied is passed. The default \r\n                        value is \"THROW\".\r\n```\r\n<!-- codegen:end -->\r\n\r\nDown:\r\n<!-- codegen:start {preset: custom, source: ./codegen.js, export: cliHelp, action: down} -->\r\n```\r\nusage: <script> down [-h] [--to NAME] [--step COUNT] [--migration NAME]\r\n                     [--rerun {THROW,SKIP,ALLOW}]\r\n                     \r\n\r\nUndoes previously-applied migrations. By default, undoes the most recent \r\nmigration only. Use --help for more options. Useful in development to start \r\nfrom a clean slate. Use with care in production!\r\n\r\nOptional arguments:\r\n  -h, --help            Show this help message and exit.\r\n  --to NAME             All migrations up to and including this one should be \r\n                        reverted. Pass \"0\" to revert all.\r\n  --step COUNT          Run this many migrations. If not specified, one will \r\n                        be reverted.\r\n  --migration NAME      List of migrations to be reverted\r\n  --rerun {THROW,SKIP,ALLOW}\r\n                        Specify what action should be taken when a migration \r\n                        that has already been reverted is passed. The default \r\n                        value is \"THROW\".\r\n```\r\n<!-- codegen:end -->\r\n\r\n\r\n#### Listing migrations\r\n\r\n```bash\r\nnode migrator pending # list migrations yet to be run\r\nnode migrator executed # list migrations that have already run\r\n\r\nnode migrator pending --json # list pending migrations including names and paths, in a json array format\r\nnode migrator executed --json # list executed migrations including names and paths, in a json array format\r\n\r\nnode migrator pending --help # show help/options\r\nnode migrator executed --help # show help/options\r\n```\r\n\r\n<!-- codegen:start {preset: custom, source: ./codegen.js, export: cliHelp, action: pending} -->\r\n```\r\nusage: <script> pending [-h] [--json]\r\n\r\nPrints migrations returned by `umzug.pending()`. By default, prints migration \r\nnames one per line.\r\n\r\nOptional arguments:\r\n  -h, --help  Show this help message and exit.\r\n  --json      Print pending migrations in a json format including names and \r\n              paths. This allows piping output to tools like jq. Without this \r\n              flag, the migration names will be printed one per line.\r\n```\r\n<!-- codegen:end -->\r\n\r\n<!-- codegen:start {preset: custom, source: ./codegen.js, export: cliHelp, action: executed} -->\r\n```\r\nusage: <script> executed [-h] [--json]\r\n\r\nPrints migrations returned by `umzug.executed()`. By default, prints \r\nmigration names one per line.\r\n\r\nOptional arguments:\r\n  -h, --help  Show this help message and exit.\r\n  --json      Print executed migrations in a json format including names and \r\n              paths. This allows piping output to tools like jq. Without this \r\n              flag, the migration names will be printed one per line.\r\n```\r\n<!-- codegen:end -->\r\n\r\n#### Creating migrations - CLI\r\n\r\nUsually, migrations correspond to files on the filesystem. The CLI exposes a way to create migration files easily:\r\n\r\n```bash\r\nnode migrator create --name my-migration.js\r\n```\r\n\r\nThis will create a file with a name like `2000.12.25T12.34.56.my-migration.js` in the same directory as the most recent migration file. If it's the very first migration file, you need to specify the folder explicitly:\r\n\r\n```bash\r\nnode migrator create --name my-migration.js --folder path/to/directory\r\n```\r\n\r\nThe timestamp prefix can be customized to be date-only or omitted, but be aware that it's strongly recommended to ensure your migrations are lexicographically sortable so it's easy for humans and tools to determine what order they should run in - so the default prefix is recommended.\r\n\r\nUse `node migrator create --help` for more options:\r\n\r\n<!-- codegen:start {preset: custom, source: ./codegen.js, export: cliHelp, action: create} -->\r\n```\r\nusage: <script> create [-h] --name NAME [--prefix {TIMESTAMP,DATE,NONE}]\r\n                       [--folder PATH] [--allow-extension EXTENSION]\r\n                       [--skip-verify] [--allow-confusing-ordering]\r\n                       \r\n\r\nGenerates a placeholder migration file using a timestamp as a prefix. By \r\ndefault, mimics the last existing migration, or guesses where to generate the \r\nfile if no migration exists yet.\r\n\r\nOptional arguments:\r\n  -h, --help            Show this help message and exit.\r\n  --name NAME           The name of the migration file. e.g. my-migration.js, \r\n                        my-migration.ts or my-migration.sql. Note - a prefix \r\n                        will be added to this name, usually based on a \r\n                        timestamp. See --prefix\r\n  --prefix {TIMESTAMP,DATE,NONE}\r\n                        The prefix format for generated files. TIMESTAMP uses \r\n                        a second-resolution timestamp, DATE uses a \r\n                        day-resolution timestamp, and NONE removes the prefix \r\n                        completely. The default value is \"TIMESTAMP\".\r\n  --folder PATH         Path on the filesystem where the file should be \r\n                        created. The new migration will be created as a \r\n                        sibling of the last existing one if this is omitted.\r\n  --allow-extension EXTENSION\r\n                        Allowable extension for created files. By default .js,\r\n                         .ts and .sql files can be created. To create txt \r\n                        file migrations, for example, you could use '--name \r\n                        my-migration.txt --allow-extension .txt' This \r\n                        parameter may alternatively be specified via the \r\n                        UMZUG_ALLOW_EXTENSION environment variable.\r\n  --skip-verify         By default, the generated file will be checked after \r\n                        creation to make sure it is detected as a pending \r\n                        migration. This catches problems like creation in the \r\n                        wrong folder, or invalid naming conventions. This \r\n                        flag bypasses that verification step.\r\n  --allow-confusing-ordering\r\n                        By default, an error will be thrown if you try to \r\n                        create a migration that will run before a migration \r\n                        that already exists. This catches errors which can \r\n                        cause problems if you change file naming conventions. \r\n                        If you use a custom ordering system, you can disable \r\n                        this behavior, but it's strongly recommended that you \r\n                        don't! If you're unsure, just ignore this option.\r\n```\r\n<!-- codegen:end -->\r\n\r\n## License\r\n\r\nSee the [LICENSE file](./LICENSE)\r\n","readmeFilename":"README.md","gitHead":"3230f0001ffc5b396913d87e643000a5c1cbf093","_id":"umzug@3.0.0-beta-cli.11","_nodeVersion":"12.18.0","_npmVersion":"6.14.8","dist":{"integrity":"sha512-st6IPJIpMAxqAVOqubSJ/ES8l7m6Kzjf5s1MMlQM7zL/w6lvlLtzh8yLOVJiGe6zCfLEJLqHrIiEo5cm6pDdyQ==","shasum":"4f9bcb9053160903aae9a11d2799bde6b3fc396a","tarball":"https://registry.npmjs.org/umzug/-/umzug-3.0.0-beta-cli.11.tgz","fileCount":37,"unpackedSize":123472,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJfvR8HCRA9TVsSAnZWagAA7pwQAJytUQkAKme1edQyxpGg\nHeTYelZbVlu6gyW+/7225UdEvNHmIqHXV5XKze2cGorSxPYfzqorImCwKN5N\nDJuJy4Ly4Qrtk9Tco+PR6pTl6Osf0jNcKiujcdrZ8O+dz2dOPPSCyk5XS3Ig\nlL1KjePw62i7GCPlvLm/+l4O8bjH3JnAzKDUn85B/sEvkCRdwNWBVH5covr9\n+ypgJrjzY1jpVpLU5es18nTehSZ7L5buHghu+H3rHtMkNq8u99pES7IoKfb2\n2v3+E3HPkxe27QaX7roW5dJtQx0hANmnMz4yTt42YtuzBo4xi/dQ5R2+cK9k\nvxawBMVhVpxt0n7VIlFHLU+ah+lElR71IMXwRKgpMZvUOmSRz0SOCc6bY9Ly\n7QLbfRJsZHXFok5l8DHFpUWtPMoBUEEnCbSVk6DSbwr0Wf07qlQki6ozdXM1\nikEMIr2IkWERDHrWOEKxL5gqRKoLCHD34S61dj4tqBpS8gQ6VB4bndawo2k2\nHOhI7SjT03gYSf2q0g5hnwjgvzpNkx16oUcTCHGkgYXA9bByuxLPWLFtsMhn\nM2ZI7TkIQc2uCfYtaYpMJ3ZGYJZt7az4loCJpBT6AyAlLjH6CqAFX6VeSAaG\npqGisjVqqNBSiVOZ9vBRuZTAsfxpnE31XTPFszVZuDWvobDrEFgb6Ei/vURV\n2HuK\r\n=F1ud\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEQCIGBALHioGFQPMXR2Tz0UVyfkv4tNbWn+i30wLXKTkEg+AiBkmpEz2k4L+0e9EWJPF7Lyxwq/8VU2udcpViYmAN4X0w=="}]},"_npmUser":{"name":"mmkale","email":"mmkal1@outlook.com"},"directories":{},"maintainers":[{"name":"pascal.pflaum","email":"mail@pascalpflaum.de"},{"name":"sdepold","email":"sascha@depold.com"},{"name":"sushantdhiman","email":"sushantdhiman@outlook.com"},{"name":"papb","email":"papb1996@gmail.com"},{"name":"mmkale","email":"mmkal1@outlook.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/umzug_3.0.0-beta-cli.11_1606229766923_0.22085510413510678"},"_hasShrinkwrap":false},"3.0.0-beta-cli.12":{"name":"umzug","version":"3.0.0-beta-cli.12","description":"Framework-agnostic migration tool for Node","keywords":["migrate","migration","migrations","sequelize","database"],"main":"lib/index.js","dependencies":{"@rushstack/ts-command-line":"~4.7.7","emittery":"~0.7.2","fs-jetpack":"~4.0.0","glob":"~7.1.6","type-fest":"~0.19.0"},"devDependencies":{"@types/jest":"26.0.15","@types/uuid":"8.3.0","@typescript-eslint/eslint-plugin":"4.8.2","@typescript-eslint/parser":"4.8.2","del-cli":"3.0.1","eslint":"7.14.0","eslint-config-xo":"0.33.1","eslint-config-xo-typescript":"0.36.0","eslint-plugin-codegen":"0.14.0","eslint-plugin-import":"2.22.1","eslint-plugin-jest":"24.1.3","eslint-plugin-mocha":"8.0.0","eslint-plugin-prettier":"3.1.4","eslint-plugin-unicorn":"23.0.0","expect-type":"0.9.0","fs-syncer":"0.3.0","jest":"26.6.3","lodash":"4.17.20","np":"7.0.0","prettier":"2.2.0","sequelize":"5.22.3","sinon":"9.2.1","source-map-support":"0.5.19","sqlite3":"5.0.0","ts-jest":"26.4.4","typescript":"4.1.2","uuid":"8.3.1"},"scripts":{"build":"del-cli lib && tsc","lint":"eslint --ext .js,.ts,.md . --max-warnings 0","prepare":"npm run build","release":"np --no-yarn --no-2fa","pretest":"del-cli test/generated","test":"jest"},"repository":{"type":"git","url":"git+https://github.com/sequelize/umzug.git"},"author":{"name":"Sascha Depold","email":"sascha@depold.com"},"contributors":[{"name":"Jukka Hyytiälä","email":"hyytiala.jukka@gmail.com"},{"name":"Pascal Pflaum","email":"mail@pascalpflaum.de"},{"name":"Pedro Augusto de Paula Barbosa","email":"papb1996@gmail.com"}],"license":"MIT","bugs":{"url":"https://github.com/sequelize/umzug/issues"},"homepage":"https://github.com/sequelize/umzug","engines":{"node":">=10.0.0"},"jest":{"preset":"ts-jest","globals":{"ts-jest":{"diagnostics":false}},"testEnvironment":"node","testMatch":["**/*test.ts"],"collectCoverageFrom":["src/**"]},"readme":"# Umzug\r\n\r\n[![Build Status](https://badgen.net/github/checks/sequelize/umzug/master)](https://github.com/sequelize/umzug/actions?query=workflow%3ACI)\r\n[![npm (stable)](https://badgen.net/npm/v/umzug)](https://www.npmjs.com/package/umzug)\r\n[![npm (beta)](https://badgen.net/npm/v/umzug/beta)](https://www.npmjs.com/package/umzug/v/beta)\r\n[![npm (downloads)](https://badgen.net/npm/dm/umzug)](https://npmjs.com/package/umzug)\r\n\r\nUmzug is a framework-agnostic migration tool for Node. It provides a clean API for running and rolling back tasks.\r\n\r\n_Note: master represents the next major version of umzug - v3 - which is currently in beta. For the stable version, please refer to the [v2.x branch](https://github.com/sequelize/umzug/tree/v2.x)._\r\n\r\nTo install the v3-beta package:\r\n\r\n```\r\nnpm install umzug@beta\r\n```\r\n\r\nTo install the stable package (v2.x):\r\n\r\n```\r\nnpm install umzug\r\n```\r\n\r\n## Highlights\r\n\r\n* Written in TypeScript\r\n\t* Built-in typings\r\n\t* Auto-completion right in your IDE\r\n\t* Documentation right in your IDE\r\n* Programmatic API for migrations\r\n* Built in [CLI](#cli)\r\n* Database agnostic\r\n* Supports logging of migration process\r\n* Supports multiple storages for migration data\r\n\r\n## Documentation\r\n\r\n### Minimal Example\r\n\r\nThe following example uses a Sqlite database through sequelize and persists the migration data in the database itself through the sequelize storage.\r\n\r\n```js\r\n// index.js\r\nconst { Sequelize } = require('sequelize');\r\nconst { Umzug, SequelizeStorage } = require('umzug');\r\n\r\nconst sequelize = new Sequelize({ dialect: 'sqlite', storage: './db.sqlite' });\r\n\r\nconst umzug = new Umzug({\r\n  migrations: { glob: 'migrations/*.js' },\r\n  context: sequelize.getQueryInterface(),\r\n  storage: new SequelizeStorage({ sequelize }),\r\n  logger: console,\r\n});\r\n\r\n(async () => {\r\n  // Checks migrations and run them if they are not already applied. To keep\r\n  // track of the executed migrations, a table (and sequelize model) called SequelizeMeta\r\n  // will be automatically created (if it doesn't exist already) and parsed.\r\n  await umzug.up();\r\n})();\r\n```\r\n\r\n```js\r\n// migrations/00_initial.js\r\n\r\nconst { Sequelize } = require('sequelize');\r\n\r\nasync function up({ context: queryInterface }) {\r\n\tawait queryInterface.createTable('users', {\r\n\t\tid: {\r\n\t\t\ttype: Sequelize.INTEGER,\r\n\t\t\tallowNull: false,\r\n\t\t\tprimaryKey: true\r\n\t\t},\r\n\t\tname: {\r\n\t\t\ttype: Sequelize.STRING,\r\n\t\t\tallowNull: false\r\n\t\t},\r\n\t\tcreatedAt: {\r\n\t\t\ttype: Sequelize.DATE,\r\n\t\t\tallowNull: false\r\n\t\t},\r\n\t\tupdatedAt: {\r\n\t\t\ttype: Sequelize.DATE,\r\n\t\t\tallowNull: false\r\n\t\t}\r\n\t});\r\n}\r\n\r\nasync function down({ context: queryInterface }) {\r\n\tawait queryInterface.dropTable('users');\r\n}\r\n\r\nmodule.exports = { up, down };\r\n```\r\n\r\nNote that we renamed the `context` argument to `queryInterface` for clarity. The `context` is whatever we specified when creating the Umzug instance in `index.js`.\r\n\r\n<details>\r\n<summary>You can also write your migrations in typescript by using `ts-node` in the entrypoint:</summary>\r\n\r\n```typescript\r\n// index.ts\r\nrequire('ts-node/register')\r\n\r\nimport { Sequelize } from 'sequelize';\r\nimport { Umzug, SequelizeStorage } from 'umzug';\r\n\r\nconst sequelize = new Sequelize({ dialect: 'sqlite', storage: './db.sqlite' });\r\n\r\nconst umzug = new Umzug({\r\n  migrations: { glob: 'migrations/*.ts' },\r\n  context: sequelize.getQueryInterface(),\r\n  storage: new SequelizeStorage({ sequelize }),\r\n  logger: console,\r\n});\r\n\r\n// export the type helper exposed by umzug, which will have the `context` argument typed correctly\r\nexport type Migration = typeof umzug._types.migration;\r\n\r\n(async () => {\r\n  await umzug.up();\r\n})();\r\n```\r\n\r\n```typescript\r\n// migrations/00_initial.ts\r\nimport type { Migration } from '..';\r\n\r\n// types will now be available for `queryInterface`\r\nexport const up: Migration = ({ context: queryInterface }) => queryInterface.createTable(...)\r\nexport const down: Migration = ({ context: queryInterface }) => queryInterface.dropTable(...)\r\n```\r\n</details>\r\n\r\nSee [these tests](./test/umzug.test.ts) for more examples of Umzug usage, including:\r\n\r\n- passing `ignore` and `cwd` parameters to the glob instructions\r\n- customising migrations ordering\r\n- finding migrations from multiple different directories\r\n- using non-js file extensions via a custom resolver, e.g. `.sql`\r\n\r\n### Usage\r\n\r\n#### Installation\r\n\r\nThe beta version of Umzug is available on npm by specifying the correct tag:\r\n\r\n```bash\r\nnpm install umzug@beta\r\n```\r\n\r\n#### Umzug instance\r\n\r\nIt is possible to configure an Umzug instance by passing an object to the constructor.\r\n\r\n```js\r\nconst { Umzug } = require('umzug');\r\nconst umzug = new Umzug({ /* ... options ... */ });\r\n```\r\n\r\nDetailed documentation for these options are in the `UmzugConstructorOptions` TypeScript interface, which can be found in [src/types.ts](./src/types.ts).\r\n\r\n#### Getting all pending migrations\r\n\r\nYou can get a list of pending (i.e. not yet executed) migrations with the `pending()` method:\r\n\r\n```js\r\nconst migrations = await umzug.pending();\r\n// returns an array of all pending migrations.\r\n```\r\n\r\n#### Getting all executed migrations\r\n\r\nYou can get a list of already executed migrations with the `executed()` method:\r\n\r\n```js\r\nconst migrations = await umzug.executed();\r\n// returns an array of all already executed migrations\r\n```\r\n\r\n#### Executing pending migrations\r\n\r\nThe `up` method can be used to execute all pending migrations.\r\n\r\n```js\r\nconst migrations = await umzug.up();\r\n// returns an array of all executed migrations\r\n```\r\n\r\nIt is also possible to pass the name of a migration in order to just run the migrations from the current state to the passed migration name (inclusive).\r\n\r\n```js\r\nawait umzug.up({ to: '20141101203500-task' });\r\n```\r\n\r\nTo limit the number of migrations that are run, `step` can be used:\r\n\r\n```js\r\nawait umzug.up({ step: 2 })\r\n```\r\n\r\nRunning specific migrations while ignoring the right order, can be done like this:\r\n\r\n```js\r\nawait umzug.up({ migrations: ['20141101203500-task', '20141101203501-task-2'] });\r\n```\r\n\r\n#### Reverting executed migration\r\n\r\nThe `down` method can be used to revert the last executed migration.\r\n\r\n```js\r\nconst migration = await umzug.down();\r\n// reverts the last migration and returns it.\r\n```\r\n\r\nTo revert more than one migration, you can use `step`:\r\n\r\n```js\r\nawait umzug.down({ step: 2 });\r\n```\r\n\r\nIt is possible to pass the name of a migration until which (inclusive) the migrations should be reverted. This allows the reverting of multiple migrations at once.\r\n\r\n```js\r\nconst migrations = await umzug.down({ to: '20141031080000-task' });\r\n// returns an array of all reverted migrations.\r\n```\r\n\r\nTo revert all migrations, you can pass 0 as the `to` parameter:\r\n\r\n```js\r\nawait umzug.down({ to: 0 });\r\n```\r\n\r\nReverting specific migrations while ignoring the right order, can be done like this:\r\n\r\n```js\r\nawait umzug.down({ migrations: ['20141101203500-task', '20141101203501-task-2'] });\r\n```\r\n\r\n### Migrations\r\n\r\nThere are two ways to specify migrations: via files or directly via an array of migrations.\r\n\r\n#### Migration files\r\n\r\nA migration file ideally exposes an `up` and a `down` async functions. They will perform the task of upgrading or downgrading the database.\r\n\r\n```js\r\nmodule.exports = {\r\n  async up() {\r\n    /* ... */\r\n  },\r\n  async down() {\r\n    /* ... */\r\n  }\r\n};\r\n```\r\n\r\nMigration files can be located anywhere - they will typically be loaded according to a glob pattern provided to the `Umzug` constructor.\r\n\r\n#### Direct migrations list\r\n\r\nYou can also specify directly a list of migrations to the `Umzug` constructor:\r\n\r\n```js\r\nconst { Umzug } = require('umzug');\r\n\r\nconst umzug = new Umzug({\r\n  migrations: [\r\n    {\r\n      // the name of the migration is mandatory\r\n      name: '00-first-migration',\r\n      async up({ context }) { /* ... */ },\r\n      async down({ context }) { /* ... */ }\r\n    },\r\n    {\r\n      name: '01-foo-bar-migration',\r\n      async up({ context }) { /* ... */ },\r\n      async down({ context }) { /* ... */ }\r\n    }\r\n  ],\r\n  context: sequelize.getQueryInterface(),\r\n  logger: console,\r\n});\r\n```\r\n\r\nTo load migrations in another format, you can use the `resolve` function:\r\n\r\n```js\r\nconst { Umzug } = require('umzug')\r\nconst { Sequelize } = require('sequelize')\r\nconst fs = require('fs')\r\n\r\nconst umzug = new Umzug({\r\n  migrations: {\r\n    glob: 'migrations/*.up.sql',\r\n    resolve: ({ name, path, context: sequelize }) => ({\r\n      name,\r\n      up: async () => {\r\n        const sql = fs.readFileSync(path).toString()\r\n        return sequelize.query(sql)\r\n      },\r\n      down: async () => {\r\n        // Get the corresponding `.down.sql` file to undo this migration\r\n        const sql = fs.readFileSync(path.replace('.up.sql', '.down.sql')).toString()\r\n        return sequelize.query(sql)\r\n      }\r\n    })\r\n  },\r\n  context: new Sequelize(...),\r\n  logger: console,\r\n});\r\n```\r\n\r\nYou can support mixed migration file types, and use umzug's default resolver for javascript/typescript:\r\n\r\n```js\r\nconst { Umzug } = require('umzug')\r\nconst { Sequelize } = require('sequelize')\r\nconst fs = require('fs')\r\n\r\nconst umzug = new Umzug({\r\n  migrations: {\r\n    glob: 'migrations/*.{js,ts,up.sql}',\r\n    resolve: (params) => {\r\n      if (!params.path.endsWith('.sql')) {\r\n        return Umzug.defaultResolver(params)\r\n      }\r\n      const { context: sequelize } = params\r\n      return {\r\n        name: params.name,\r\n        up: async () => {\r\n          const sql = fs.readFileSync(params.path).toString()\r\n          return sequelize.query(sql)\r\n        },\r\n        down: async () => {\r\n          // Get the corresponding `.down.sql` file to undo this migration\r\n          const sql = fs.readFileSync(params.path.replace('.up.sql', '.down.sql')).toString()\r\n          return sequelize.query(sql)\r\n        }\r\n      }\r\n    },\r\n  },\r\n  logger: console,\r\n  context: new Sequelize(...),\r\n});\r\n```\r\n\r\nThe glob syntax allows loading migrations from multiple locations:\r\n\r\n```js\r\nconst { Umzug } = require('umzug')\r\nconst { Sequelize } = require('sequelize')\r\n\r\nconst umzug = new Umzug({\r\n  migrations: {\r\n    glob: '{first-folder/*.js,second-folder-with-different-naming-convention/*.js}',\r\n  },\r\n  context: new Sequelize(...),\r\n  logger: console,\r\n});\r\n```\r\n\r\nNote on migration file sorting:\r\n\r\n- file matches, found using [glob](https://npmjs.com/package/glob), will be lexicographically sorted based on their paths\r\n  - so if your migrations are `one/m1.js`, `two/m2.js`, `three/m3.js`, the resultant order will be `one/m1.js`, `three/m3.js`, `two/m2.js`\r\n  - similarly, if your migrations are called `m1.js`, `m2.js`, ... `m10.js`, `m11.js`, the resultant ordering will be `m1.js`, `m10.js`, `m11.js`, ... `m2.js`\r\n- The easiest way to deal with this is to ensure your migrations appear in a single folder, and their paths match lexicographically with the order they should run in\r\n- If this isn't possible, the ordering can be customised using `.extend(...)` (see below)\r\n\r\n### Upgrading from v2.x\r\n\r\nThe Umzug class should be imported as a named import, i.e. `import { Umzug } from 'umzug'`.\r\n\r\nThe `MigrationMeta` type, which is returned by `umzug.executed()` and `umzug.pending()`, no longer has a `file` property - it has a `name` and *optional* `path` - since migrations are not necessarily bound to files on the file system.\r\n\r\nThe `migrations.glob` parameter replaces `path`, `pattern` and `traverseDirectories`. It can be used, in combination with `cwd` and `ignore` to do much more flexible file lookups. See https://npmjs.com/package/glob for more information on the syntax.\r\n\r\nThe `migrations.resolve` parameter replaces `customResolver`. Explicit support for `wrap` and `nameFormatter` has been removed - these can be easily implemented in a `resolve` function.\r\n\r\nThe constructor option `logging` is replaced by `logger` to allow for `warn` and `error` messages in future. NodeJS's global `console` object can be passed to this. To disable logging, replace `logging: false` with `logger: undefined`.\r\n\r\nEvents have moved from the default nodejs `EventEmitter` to [emittery](https://www.npmjs.com/package/emittery). It has better design for async code, a less bloated API surface and strong types. But, it doesn't allow passing multiple arguments to callbacks, so listeners have to change slightly, as well as `.addListener(...)` and `.removeListener(...)` no longer being supported (`.on(...)` and `.off(...)` should now be used):\r\n\r\nBefore:\r\n\r\n```js\r\numzug.on('migrating', (name, m) => console.log({ name, path: m.path }))\r\n```\r\n\r\nAfter:\r\n\r\n```js\r\numzug.on('migrating', ev => console.log({ name: ev.name, path: ev.path }))\r\n```\r\n\r\nThe `Umzug#execute` method is removed. Use `Umzug#up` or `Umzug#down`.\r\n\r\nThe options for `Umguz#up` and `Umzug#down` have changed:\r\n- `umzug.up({ to: 'some-name' })` and `umzug.down({ to: 'some-name' })` are still valid.\r\n- `umzug.up({ from: '...' })` and `umzug.down({ from: '...' })` are no longer supported. To run migrations out-of-order (which is not generally recommended), you can explicitly use `umzug.up({ migrations: ['...'] })` and `umzug.down({ migrations: ['...'] })`.\r\n- name matches must be exact. `umzug.up({ to: 'some-n' })` will no longer match a migration called `some-name`.\r\n- `umzug.down({ to: 0 })` is still valid but `umzug.up({ to: 0 })` is not.\r\n- `umzug.up({ migrations: ['m1', 'm2'] })` is still valid but the shorthand `umzug.up(['m1', 'm2'])` has been removed.\r\n- `umzug.down({ migrations: ['m1', 'm2'] })` is still valid but the shorthand `umzug.down(['m1', 'm2'])` has been removed.\r\n- `umzug.up({ migrations: ['m1', 'already-run'] })` will throw an error, if `already-run` is not found in the list of pending migrations.\r\n- `umzug.down({ migrations: ['m1', 'has-not-been-run'] })` will throw an error, if `has-not-been-run` is not found in the list of executed migrations.\r\n- `umzug.up({ migrations: ['m1', 'm2'], rerun: 'ALLOW' })` will re-apply migrations `m1` and `m2` even if they've already been run.\r\n- `umzug.up({ migrations: ['m1', 'm2'], rerun: 'SKIP' })` will skip migrations `m1` and `m2` if they've already been run.\r\n- `umzug.down({ migrations: ['m1', 'm2'], rerun: 'ALLOW' })` will \"revert\" migrations `m1` and `m2` even if they've never been run.\r\n- `umzug.down({ migrations: ['m1', 'm2'], rerun: 'SKIP' })` will skip reverting migrations `m1` and `m2` if they haven't been run or are already reverted.\r\n- `umzug.up({ migrations: ['m1', 'does-not-exist', 'm2'] })` will throw an error if the migration name is not found. Note that the error will be thrown and no migrations run unless _all_ migration names are found - whether or not `rerun: 'ALLOW'` is added.\r\n\r\nThe `context` parameter replaces `params`, and is passed in as a property to migration functions as an options object, alongs side `name` and `path`. This means the signature for migrations, which in v2 was `(context) => Promise<void>`, has changed slightly in v3, to `({ name, path, context }) => Promise<void>`. The `resolve` function can also be used to upgrade your umzug version to v3 when you have existing v2-compatible migrations:\r\n\r\n```js\r\nconst { Umzug } = require('umzug');\r\n\r\nconst umzug = new Umzug({\r\n  migrations: {\r\n    glob: 'migrations/umzug-v2-format/*.js',\r\n    resolve: ({name, path, context}) => {\r\n      // Adjust the migration from the new signature to the v2 signature, making easier to upgrade to v3\r\n      const migration = require(path)\r\n      return { name, up: async () => migration.up(context), down: async () => migration.down(context) }\r\n    }\r\n  },\r\n  context: sequelize.getQueryInterface(),\r\n  logger: console,\r\n});\r\n```\r\n\r\nSimilarly, you no longer need `migrationSorting`, you can use `Umzug#extend` to manipulate migration lists directly:\r\n\r\n```js\r\nconst { Umzug } = require('umzug');\r\n\r\nconst umzug =\r\n  new Umzug({\r\n    migrations: { glob: 'migrations/**/*.js' },\r\n    context: sequelize.getQueryInterface(),\r\n  })\r\n  .extend(migrations => migrations.sort((a, b) => b.path.localeCompare(a.path)));\r\n```\r\n\r\n### Storages\r\n\r\nStorages define where the migration data is stored.\r\n\r\n#### JSON Storage\r\n\r\nUsing `JSONStorage` will create a JSON file which will contain an array with all the executed migrations. You can specify the path to the file. The default for that is `umzug.json` in the working directory of the process.\r\n\r\nDetailed documentation for the options it can take are in the `JSONStorageConstructorOptions` TypeScript interface, which can be found in [src/storage/json.ts](./src/storage/json.ts).\r\n\r\n#### Memory Storage\r\n\r\nUsing `memoryStorage` will store migrations with an in-memory array. This can be useful for proof-of-concepts or tests, since it doesn't interact with databases or filesystems.\r\n\r\nIt doesn't take any options, just import the `memoryStorage` function and call it to return a storage instance:\r\n\r\n```typescript\r\nimport { Umzug, memoryStorage } from 'umzug'\r\n\r\nconst umzug = new Umzug({\r\n  migrations: ...,\r\n  storage: memoryStorage(),\r\n  logger: console,\r\n})\r\n```\r\n\r\n#### Sequelize Storage\r\n\r\nUsing `SequelizeStorage` will create a table in your SQL database called `SequelizeMeta` containing an entry for each executed migration. You will have to pass a configured instance of Sequelize or an existing Sequelize model. Optionally you can specify the model name, table name, or column name. All major Sequelize versions are supported.\r\n\r\nDetailed documentation for the options it can take are in the `_SequelizeStorageConstructorOptions` TypeScript interface, which can be found in [src/storage/sequelize.ts](./src/storage/sequelize.ts).\r\n\r\n#### MongoDB Storage\r\n\r\nUsing `MongoDBStorage` will create a collection in your MongoDB database called `migrations` containing an entry for each executed migration. You will have either to pass a MongoDB Driver Collection as `collection` property. Alternatively you can pass a established MongoDB Driver connection and a collection name.\r\n\r\nDetailed documentation for the options it can take are in the `MongoDBStorageConstructorOptions` TypeScript interface, which can be found in [src/storage/mongodb.ts](./src/storage/mongodb.ts).\r\n\r\n#### Custom\r\n\r\nIn order to use a custom storage, you can pass your storage instance to Umzug constructor.\r\n\r\n```js\r\nclass CustomStorage {\r\n  constructor(...) {...}\r\n  logMigration(...) {...}\r\n  unlogMigration(...) {...}\r\n  executed(...) {...}\r\n}\r\n\r\nconst umzug = new Umzug({ storage: new CustomStorage(...), logger: console })\r\n```\r\n\r\nYour instance must adhere to the [UmzugStorage](./src/storage/contract.ts) interface. If you're using TypeScript you can ensure this at compile time, and get IDE type hints by importing it:\r\n\r\n```typescript\r\nimport { UmzugStorage } from 'umzug'\r\n\r\nclass CustomStorage implements UmzugStorage {\r\n  /* ... */\r\n}\r\n```\r\n\r\n### Creating migrations - API\r\n\r\nUmzug includes an optional helper for generating migration files. This will, by default, include a timestamp-based prefix and generate a file in the same folder as the most recent existing migration. It also includes some safety checks to make sure migrations aren't created with ambiguous ordering, and that they will be picked up by umzug when applying migrations. It's often most convenient to create files using the [CLI helper](#creating-migrations---cli), but the equivalent API also exists on an umzug instance:\r\n\r\n```js\r\nawait umzug.create({ name: 'my-new-migration.js' })\r\n```\r\n\r\nUmzug ships with a barebones default template for js, ts and sql migration files, but you can specify the template for your project when constructing an umzug instance. The `template` property should be a function which receives a filepath string, and returns an array of `[filepath, content]` pairs. Usually, just one pair is needed, but a second could be used to include a \"down\" migration in a separate file:\r\n\r\n```js\r\nconst umzug = new Umzug({\r\n  migrations: ...,\r\n  template: filepath => [\r\n    [\r\n      filepath,\r\n      dedent`\r\n        import { Migration } from '@my-team/migration-type'\r\n        import { logger } from '@my-team/custom-logger'\r\n\r\n        export const up: Migration = params => {\r\n          logger.info('running migration', params.name)\r\n        }\r\n\r\n        export const down: Migration = params => {\r\n          logger.info('reverting migration', params.name)\r\n        }\r\n      `\r\n    ],\r\n  ]\r\n})\r\n```\r\n\r\nTo create blank migration files, return an empty array:\r\n\r\n```js\r\nconst umzug = new Umzug({\r\n  migrations: ...,\r\n  template: () => [],\r\n})\r\n```\r\n\r\n### Events\r\n\r\nUmzug is an [emittery event emitter](https://www.npmjs.com/package/emittery). Each of the following events will be called with migration parameters as its payload (with `context`, `name`, and nullable `path` properties). Events are a convenient place to implement application-specific logic that must run around each migration:\r\n\r\n* `migrating` - A migration is about to be executed.\r\n* `migrated` - A migration has successfully been executed.\r\n* `reverting` - A migration is about to be reverted.\r\n* `reverted` - A migration has successfully been reverted.\r\n\r\nThese events run at the beginning and end of `up` and `down` calls. They'll receive an object containing a `context` property:\r\n\r\n- `beforeAll` - Before any of the migrations are run.\r\n- `afterAll` - After all the migrations have been executed. Note: this will always run, even if migrations throw an error.\r\n\r\nThe [`FileLocker` class](./src/file-locker.ts) uses `beforeAll` and `afterAll` to implement a simple filesystem-based locking mechanism.\r\n\r\nAll events are type-safe, so IDEs will prevent typos and supply strong types for the event payloads.\r\n\r\n### CLI\r\n\r\nUmzug has an optional built-in CLI helper. To use it, call the `.runAsCLI()` method from an `Umzug` instance:\r\n\r\n```js\r\n// migrator.js\r\nconst { Umzug } = require('umzug')\r\n\r\nexports.umzug = new Umzug({ ... })\r\n\r\nif (require.main === module) {\r\n  umzug.runAsCLI()\r\n}\r\n```\r\n\r\n#### CLI Usage\r\n\r\nThis script is now a runnable CLI program, complete with help text. You can run `node migrator.js --help` to see how to use it. It'll print something like\r\n\r\n<!-- codegen:start {preset: custom, source: ./codegen.js, export: cliHelp} -->\r\n```\r\nusage: <script> [-h] <command> ...\r\n\r\nUmzug migrator\r\n\r\nPositional arguments:\r\n  <command>\r\n    up        Applies pending migrations\r\n    down      Revert migrations\r\n    pending   Lists pending migrations\r\n    executed  Lists executed migrations\r\n    create    Create a migration file\r\n\r\nOptional arguments:\r\n  -h, --help  Show this help message and exit.\r\n\r\nFor detailed help about a specific command, use: <script> <command> -h\r\n```\r\n<!-- codegen:end -->\r\n\r\n#### Running migrations\r\n\r\n`node migrator up` and `node migrator down` apply and revert migrations respectively. They're the equivalent of the `.up()` and `.down()` methods.\r\n\r\nUse `node migrator up --help` and `node migrator down --help` for options (running \"to\" a specific migration, passing migration names to be run explicitly, and specifying the rerun behavior):\r\n\r\nUp:\r\n<!-- codegen:start {preset: custom, source: ./codegen.js, export: cliHelp, action: up} -->\r\n```\r\nusage: <script> up [-h] [--to NAME] [--step COUNT] [--migration NAME]\r\n                   [--rerun {THROW,SKIP,ALLOW}]\r\n                   \r\n\r\nPerforms all migrations. See --help for more options\r\n\r\nOptional arguments:\r\n  -h, --help            Show this help message and exit.\r\n  --to NAME             All migrations up to and including this one should be \r\n                        applied.\r\n  --step COUNT          Run this many migrations. If not specified, all will \r\n                        be applied.\r\n  --migration NAME      List of migrations to be applied\r\n  --rerun {THROW,SKIP,ALLOW}\r\n                        Specify what action should be taken when a migration \r\n                        that has already been applied is passed. The default \r\n                        value is \"THROW\".\r\n```\r\n<!-- codegen:end -->\r\n\r\nDown:\r\n<!-- codegen:start {preset: custom, source: ./codegen.js, export: cliHelp, action: down} -->\r\n```\r\nusage: <script> down [-h] [--to NAME] [--step COUNT] [--migration NAME]\r\n                     [--rerun {THROW,SKIP,ALLOW}]\r\n                     \r\n\r\nUndoes previously-applied migrations. By default, undoes the most recent \r\nmigration only. Use --help for more options. Useful in development to start \r\nfrom a clean slate. Use with care in production!\r\n\r\nOptional arguments:\r\n  -h, --help            Show this help message and exit.\r\n  --to NAME             All migrations up to and including this one should be \r\n                        reverted. Pass \"0\" to revert all.\r\n  --step COUNT          Run this many migrations. If not specified, one will \r\n                        be reverted.\r\n  --migration NAME      List of migrations to be reverted\r\n  --rerun {THROW,SKIP,ALLOW}\r\n                        Specify what action should be taken when a migration \r\n                        that has already been reverted is passed. The default \r\n                        value is \"THROW\".\r\n```\r\n<!-- codegen:end -->\r\n\r\n\r\n#### Listing migrations\r\n\r\n```bash\r\nnode migrator pending # list migrations yet to be run\r\nnode migrator executed # list migrations that have already run\r\n\r\nnode migrator pending --json # list pending migrations including names and paths, in a json array format\r\nnode migrator executed --json # list executed migrations including names and paths, in a json array format\r\n\r\nnode migrator pending --help # show help/options\r\nnode migrator executed --help # show help/options\r\n```\r\n\r\n<!-- codegen:start {preset: custom, source: ./codegen.js, export: cliHelp, action: pending} -->\r\n```\r\nusage: <script> pending [-h] [--json]\r\n\r\nPrints migrations returned by `umzug.pending()`. By default, prints migration \r\nnames one per line.\r\n\r\nOptional arguments:\r\n  -h, --help  Show this help message and exit.\r\n  --json      Print pending migrations in a json format including names and \r\n              paths. This allows piping output to tools like jq. Without this \r\n              flag, the migration names will be printed one per line.\r\n```\r\n<!-- codegen:end -->\r\n\r\n<!-- codegen:start {preset: custom, source: ./codegen.js, export: cliHelp, action: executed} -->\r\n```\r\nusage: <script> executed [-h] [--json]\r\n\r\nPrints migrations returned by `umzug.executed()`. By default, prints \r\nmigration names one per line.\r\n\r\nOptional arguments:\r\n  -h, --help  Show this help message and exit.\r\n  --json      Print executed migrations in a json format including names and \r\n              paths. This allows piping output to tools like jq. Without this \r\n              flag, the migration names will be printed one per line.\r\n```\r\n<!-- codegen:end -->\r\n\r\n#### Creating migrations - CLI\r\n\r\nUsually, migrations correspond to files on the filesystem. The CLI exposes a way to create migration files easily:\r\n\r\n```bash\r\nnode migrator create --name my-migration.js\r\n```\r\n\r\nThis will create a file with a name like `2000.12.25T12.34.56.my-migration.js` in the same directory as the most recent migration file. If it's the very first migration file, you need to specify the folder explicitly:\r\n\r\n```bash\r\nnode migrator create --name my-migration.js --folder path/to/directory\r\n```\r\n\r\nThe timestamp prefix can be customized to be date-only or omitted, but be aware that it's strongly recommended to ensure your migrations are lexicographically sortable so it's easy for humans and tools to determine what order they should run in - so the default prefix is recommended.\r\n\r\nUse `node migrator create --help` for more options:\r\n\r\n<!-- codegen:start {preset: custom, source: ./codegen.js, export: cliHelp, action: create} -->\r\n```\r\nusage: <script> create [-h] --name NAME [--prefix {TIMESTAMP,DATE,NONE}]\r\n                       [--folder PATH] [--allow-extension EXTENSION]\r\n                       [--skip-verify] [--allow-confusing-ordering]\r\n                       \r\n\r\nGenerates a placeholder migration file using a timestamp as a prefix. By \r\ndefault, mimics the last existing migration, or guesses where to generate the \r\nfile if no migration exists yet.\r\n\r\nOptional arguments:\r\n  -h, --help            Show this help message and exit.\r\n  --name NAME           The name of the migration file. e.g. my-migration.js, \r\n                        my-migration.ts or my-migration.sql. Note - a prefix \r\n                        will be added to this name, usually based on a \r\n                        timestamp. See --prefix\r\n  --prefix {TIMESTAMP,DATE,NONE}\r\n                        The prefix format for generated files. TIMESTAMP uses \r\n                        a second-resolution timestamp, DATE uses a \r\n                        day-resolution timestamp, and NONE removes the prefix \r\n                        completely. The default value is \"TIMESTAMP\".\r\n  --folder PATH         Path on the filesystem where the file should be \r\n                        created. The new migration will be created as a \r\n                        sibling of the last existing one if this is omitted.\r\n  --allow-extension EXTENSION\r\n                        Allowable extension for created files. By default .js,\r\n                         .ts and .sql files can be created. To create txt \r\n                        file migrations, for example, you could use '--name \r\n                        my-migration.txt --allow-extension .txt' This \r\n                        parameter may alternatively be specified via the \r\n                        UMZUG_ALLOW_EXTENSION environment variable.\r\n  --skip-verify         By default, the generated file will be checked after \r\n                        creation to make sure it is detected as a pending \r\n                        migration. This catches problems like creation in the \r\n                        wrong folder, or invalid naming conventions. This \r\n                        flag bypasses that verification step.\r\n  --allow-confusing-ordering\r\n                        By default, an error will be thrown if you try to \r\n                        create a migration that will run before a migration \r\n                        that already exists. This catches errors which can \r\n                        cause problems if you change file naming conventions. \r\n                        If you use a custom ordering system, you can disable \r\n                        this behavior, but it's strongly recommended that you \r\n                        don't! If you're unsure, just ignore this option.\r\n```\r\n<!-- codegen:end -->\r\n\r\n## License\r\n\r\nSee the [LICENSE file](./LICENSE)\r\n","readmeFilename":"README.md","gitHead":"f870552cdc2a8e0505d7fd5684f8db2f76e5ef64","_id":"umzug@3.0.0-beta-cli.12","_nodeVersion":"12.18.0","_npmVersion":"6.14.8","dist":{"integrity":"sha512-H2hZyphYQIQuWAlN6xQgSMHixQn3FO4Z1M3C/L2+rJ4geiWCR+Xq6gzbJ2yadYW63DSpDvp6IFCuOuYCs6epaw==","shasum":"82c2aff07a0c326c56e32064d9fcc318412856b2","tarball":"https://registry.npmjs.org/umzug/-/umzug-3.0.0-beta-cli.12.tgz","fileCount":37,"unpackedSize":123477,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJfvSXiCRA9TVsSAnZWagAAlswP+QGkqKu4nXwCsPg/PuEU\n6VqHzhF+3JyeK4B6r1XwMU9+ohRYfxanN3t4eyCV/lm9kOw6ls8Vdk6COv7X\nBpRerLldbhE7k/T1lfqJ+/HT7LrIMUtb14hzXbLQpH7cDah5xfuCbYvzPnvR\ngHNojfux2IwFxU1HNAyiS4J/IycPh6At7vhJ6oTPTK2RVmWgt4Uxd2UkRIPY\n7xgHBlLcdX4JfY2wkxpPEYEqDH+W+7anqnKxZ0zUmR0zZYfAtUyVGkXiK8xe\nQHz21+lUe/Gf08ttKmjJJSMcmznvnSkvUh2wElmxhfkRoVGgtan5DSci2STA\nB4LYm7Zy8qvGjL1fjVu/xWipieI1tQpf2LTD16FoU2tehGdjqx//4BKLvgZh\nWYRCM4FtMFkPYlmWHqjm4AugPMPMliMPv+r5vnhMhqPllYwadFUzzRDbK6Rn\n6e0bgdL1b7atJFEesYe5sF4KJNwrdN5mLaKdHBa1sKO0Xk8EYOPFB7GxO8BD\nL8JLa7rBu8YEvmFEnH2TG5MvR0g/hmBEA5j+BMB8WFe/3jFsqIRDJzjWkCgi\nSDpAAj4eZ0fN4wSkzcNtqs8+dYl4u+AFyS7QZzEyj+Nd7Zt7DHbH46xpYxrY\nvMc0HfARZI6tjDi1B3dL+ff5qgPuBHNQ7oxnM6EoaXoABDADJA0GHMjqDBzP\nRRXu\r\n=MUS7\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIQC41SGvLO3UU1jmo87GT1SwwmQNH00F9wWNpg6eLuzJaAIgfyGOSm1F8nurpGEjBbUR3d5vZefYlVa3TJRGKoShIdk="}]},"_npmUser":{"name":"mmkale","email":"mmkal1@outlook.com"},"directories":{},"maintainers":[{"name":"pascal.pflaum","email":"mail@pascalpflaum.de"},{"name":"sdepold","email":"sascha@depold.com"},{"name":"sushantdhiman","email":"sushantdhiman@outlook.com"},{"name":"papb","email":"papb1996@gmail.com"},{"name":"mmkale","email":"mmkal1@outlook.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/umzug_3.0.0-beta-cli.12_1606231522101_0.9081632053626669"},"_hasShrinkwrap":false},"3.0.0-beta.10":{"name":"umzug","version":"3.0.0-beta.10","description":"Framework-agnostic migration tool for Node","keywords":["migrate","migration","migrations","sequelize","database"],"main":"lib/index.js","dependencies":{"@rushstack/ts-command-line":"~4.7.7","emittery":"~0.7.2","fs-jetpack":"~4.0.0","glob":"~7.1.6","type-fest":"~0.19.0"},"devDependencies":{"@types/jest":"26.0.16","@types/lodash":"4.14.165","@types/uuid":"8.3.0","@typescript-eslint/eslint-plugin":"4.9.0","@typescript-eslint/parser":"4.9.0","del-cli":"3.0.1","eslint":"7.15.0","eslint-config-xo":"0.33.1","eslint-config-xo-typescript":"0.36.0","eslint-plugin-codegen":"0.14.3","eslint-plugin-import":"2.22.1","eslint-plugin-jest":"24.1.3","eslint-plugin-mocha":"8.0.0","eslint-plugin-prettier":"3.2.0","eslint-plugin-unicorn":"23.0.0","expect-type":"0.10.0","fs-syncer":"0.3.3","jest":"26.6.3","lodash":"4.17.20","np":"7.0.0","prettier":"2.2.1","sequelize":"5.22.3","sinon":"9.2.1","source-map-support":"0.5.19","sqlite3":"5.0.0","strip-ansi":"6.0.0","ts-jest":"26.4.4","ts-node":"9.0.0","typescript":"4.1.2","uuid":"8.3.1"},"scripts":{"build":"del-cli lib && tsc","lint":"eslint --ext .js,.ts,.md . --max-warnings 0","prepare":"npm run build","release":"np --no-yarn --no-2fa","pretest":"del-cli test/generated","test":"jest"},"repository":{"type":"git","url":"git+https://github.com/sequelize/umzug.git"},"author":{"name":"Sascha Depold","email":"sascha@depold.com"},"contributors":[{"name":"Jukka Hyytiälä","email":"hyytiala.jukka@gmail.com"},{"name":"Pascal Pflaum","email":"mail@pascalpflaum.de"},{"name":"Pedro Augusto de Paula Barbosa","email":"papb1996@gmail.com"}],"license":"MIT","bugs":{"url":"https://github.com/sequelize/umzug/issues"},"homepage":"https://github.com/sequelize/umzug","engines":{"node":">=10.0.0"},"jest":{"preset":"ts-jest","globals":{"ts-jest":{"diagnostics":false}},"testEnvironment":"node","testMatch":["**/*test.ts"],"collectCoverageFrom":["src/**"]},"readme":"# Umzug\r\n\r\n[![Build Status](https://badgen.net/github/checks/sequelize/umzug/master)](https://github.com/sequelize/umzug/actions?query=workflow%3ACI)\r\n[![npm (stable)](https://badgen.net/npm/v/umzug)](https://www.npmjs.com/package/umzug)\r\n[![npm (beta)](https://badgen.net/npm/v/umzug/beta)](https://www.npmjs.com/package/umzug/v/beta)\r\n[![npm (downloads)](https://badgen.net/npm/dm/umzug)](https://npmjs.com/package/umzug)\r\n\r\nUmzug is a framework-agnostic migration tool for Node. It provides a clean API for running and rolling back tasks.\r\n\r\n_Note: master represents the next major version of umzug - v3 - which is currently in beta. For the stable version, please refer to the [v2.x branch](https://github.com/sequelize/umzug/tree/v2.x)._\r\n\r\nTo install the v3-beta package:\r\n\r\n```\r\nnpm install umzug@beta\r\n```\r\n\r\nTo install the stable package (v2.x):\r\n\r\n```\r\nnpm install umzug\r\n```\r\n\r\n## Highlights\r\n\r\n* Written in TypeScript\r\n\t* Built-in typings\r\n\t* Auto-completion right in your IDE\r\n\t* Documentation right in your IDE\r\n* Programmatic API for migrations\r\n* Built-in [CLI](#cli)\r\n* Database agnostic\r\n* Supports logging of migration process\r\n* Supports multiple storages for migration data\r\n* [Usage examples](./examples)\r\n\r\n## Documentation\r\n\r\n### Minimal Example\r\n\r\nThe following example uses a Sqlite database through sequelize and persists the migration data in the database itself through the sequelize storage. There are several more involved examples covering a few different scenarios in the [examples folder](./examples).\r\n\r\n```js\r\n// index.js\r\nconst { Sequelize } = require('sequelize');\r\nconst { Umzug, SequelizeStorage } = require('umzug');\r\n\r\nconst sequelize = new Sequelize({ dialect: 'sqlite', storage: './db.sqlite' });\r\n\r\nconst umzug = new Umzug({\r\n  migrations: { glob: 'migrations/*.js' },\r\n  context: sequelize.getQueryInterface(),\r\n  storage: new SequelizeStorage({ sequelize }),\r\n  logger: console,\r\n});\r\n\r\n(async () => {\r\n  // Checks migrations and run them if they are not already applied. To keep\r\n  // track of the executed migrations, a table (and sequelize model) called SequelizeMeta\r\n  // will be automatically created (if it doesn't exist already) and parsed.\r\n  await umzug.up();\r\n})();\r\n```\r\n\r\n```js\r\n// migrations/00_initial.js\r\n\r\nconst { Sequelize } = require('sequelize');\r\n\r\nasync function up({ context: queryInterface }) {\r\n\tawait queryInterface.createTable('users', {\r\n\t\tid: {\r\n\t\t\ttype: Sequelize.INTEGER,\r\n\t\t\tallowNull: false,\r\n\t\t\tprimaryKey: true\r\n\t\t},\r\n\t\tname: {\r\n\t\t\ttype: Sequelize.STRING,\r\n\t\t\tallowNull: false\r\n\t\t},\r\n\t\tcreatedAt: {\r\n\t\t\ttype: Sequelize.DATE,\r\n\t\t\tallowNull: false\r\n\t\t},\r\n\t\tupdatedAt: {\r\n\t\t\ttype: Sequelize.DATE,\r\n\t\t\tallowNull: false\r\n\t\t}\r\n\t});\r\n}\r\n\r\nasync function down({ context: queryInterface }) {\r\n\tawait queryInterface.dropTable('users');\r\n}\r\n\r\nmodule.exports = { up, down };\r\n```\r\n\r\nNote that we renamed the `context` argument to `queryInterface` for clarity. The `context` is whatever we specified when creating the Umzug instance in `index.js`.\r\n\r\n<details>\r\n<summary>You can also write your migrations in typescript by using `ts-node` in the entrypoint:</summary>\r\n\r\n```typescript\r\n// index.ts\r\nrequire('ts-node/register')\r\n\r\nimport { Sequelize } from 'sequelize';\r\nimport { Umzug, SequelizeStorage } from 'umzug';\r\n\r\nconst sequelize = new Sequelize({ dialect: 'sqlite', storage: './db.sqlite' });\r\n\r\nconst umzug = new Umzug({\r\n  migrations: { glob: 'migrations/*.ts' },\r\n  context: sequelize.getQueryInterface(),\r\n  storage: new SequelizeStorage({ sequelize }),\r\n  logger: console,\r\n});\r\n\r\n// export the type helper exposed by umzug, which will have the `context` argument typed correctly\r\nexport type Migration = typeof umzug._types.migration;\r\n\r\n(async () => {\r\n  await umzug.up();\r\n})();\r\n```\r\n\r\n```typescript\r\n// migrations/00_initial.ts\r\nimport type { Migration } from '..';\r\n\r\n// types will now be available for `queryInterface`\r\nexport const up: Migration = ({ context: queryInterface }) => queryInterface.createTable(...)\r\nexport const down: Migration = ({ context: queryInterface }) => queryInterface.dropTable(...)\r\n```\r\n</details>\r\n\r\nSee [these tests](./test/umzug.test.ts) for more examples of Umzug usage, including:\r\n\r\n- passing `ignore` and `cwd` parameters to the glob instructions\r\n- customising migrations ordering\r\n- finding migrations from multiple different directories\r\n- using non-js file extensions via a custom resolver, e.g. `.sql`\r\n\r\n### Usage\r\n\r\n#### Installation\r\n\r\nThe beta version of Umzug is available on npm by specifying the correct tag:\r\n\r\n```bash\r\nnpm install umzug@beta\r\n```\r\n\r\n#### Umzug instance\r\n\r\nIt is possible to configure an Umzug instance by passing an object to the constructor.\r\n\r\n```js\r\nconst { Umzug } = require('umzug');\r\nconst umzug = new Umzug({ /* ... options ... */ });\r\n```\r\n\r\nDetailed documentation for these options are in the `UmzugOptions` TypeScript interface, which can be found in [src/types.ts](./src/types.ts).\r\n\r\n#### Getting all pending migrations\r\n\r\nYou can get a list of pending (i.e. not yet executed) migrations with the `pending()` method:\r\n\r\n```js\r\nconst migrations = await umzug.pending();\r\n// returns an array of all pending migrations.\r\n```\r\n\r\n#### Getting all executed migrations\r\n\r\nYou can get a list of already executed migrations with the `executed()` method:\r\n\r\n```js\r\nconst migrations = await umzug.executed();\r\n// returns an array of all already executed migrations\r\n```\r\n\r\n#### Executing pending migrations\r\n\r\nThe `up` method can be used to execute all pending migrations.\r\n\r\n```js\r\nconst migrations = await umzug.up();\r\n// returns an array of all executed migrations\r\n```\r\n\r\nIt is also possible to pass the name of a migration in order to just run the migrations from the current state to the passed migration name (inclusive).\r\n\r\n```js\r\nawait umzug.up({ to: '20141101203500-task' });\r\n```\r\n\r\nTo limit the number of migrations that are run, `step` can be used:\r\n\r\n```js\r\n// This will run the next two migrations\r\nawait umzug.up({ step: 2 })\r\n```\r\n\r\nRunning specific migrations while ignoring the right order, can be done like this:\r\n\r\n```js\r\nawait umzug.up({ migrations: ['20141101203500-task', '20141101203501-task-2'] });\r\n```\r\n\r\n#### Reverting executed migration\r\n\r\nThe `down` method can be used to revert the last executed migration.\r\n\r\n```js\r\nconst migration = await umzug.down();\r\n// reverts the last migration and returns it.\r\n```\r\n\r\nTo revert more than one migration, you can use `step`:\r\n\r\n```js\r\n// This will revert the last two migrations\r\nawait umzug.down({ step: 2 });\r\n```\r\n\r\nIt is possible to pass the name of a migration until which (inclusive) the migrations should be reverted. This allows the reverting of multiple migrations at once.\r\n\r\n```js\r\nconst migrations = await umzug.down({ to: '20141031080000-task' });\r\n// returns an array of all reverted migrations.\r\n```\r\n\r\nTo revert all migrations, you can pass 0 as the `to` parameter:\r\n\r\n```js\r\nawait umzug.down({ to: 0 });\r\n```\r\n\r\nReverting specific migrations while ignoring the right order, can be done like this:\r\n\r\n```js\r\nawait umzug.down({ migrations: ['20141101203500-task', '20141101203501-task-2'] });\r\n```\r\n\r\n### Migrations\r\n\r\nThere are two ways to specify migrations: via files or directly via an array of migrations.\r\n\r\n#### Migration files\r\n\r\nA migration file ideally exposes an `up` and a `down` async functions. They will perform the task of upgrading or downgrading the database.\r\n\r\n```js\r\nmodule.exports = {\r\n  async up() {\r\n    /* ... */\r\n  },\r\n  async down() {\r\n    /* ... */\r\n  }\r\n};\r\n```\r\n\r\nMigration files can be located anywhere - they will typically be loaded according to a glob pattern provided to the `Umzug` constructor.\r\n\r\n#### Direct migrations list\r\n\r\nYou can also specify directly a list of migrations to the `Umzug` constructor:\r\n\r\n```js\r\nconst { Umzug } = require('umzug');\r\n\r\nconst umzug = new Umzug({\r\n  migrations: [\r\n    {\r\n      // the name of the migration is mandatory\r\n      name: '00-first-migration',\r\n      async up({ context }) { /* ... */ },\r\n      async down({ context }) { /* ... */ }\r\n    },\r\n    {\r\n      name: '01-foo-bar-migration',\r\n      async up({ context }) { /* ... */ },\r\n      async down({ context }) { /* ... */ }\r\n    }\r\n  ],\r\n  context: sequelize.getQueryInterface(),\r\n  logger: console,\r\n});\r\n```\r\n\r\nTo load migrations in another format, you can use the `resolve` function:\r\n\r\n```js\r\nconst { Umzug } = require('umzug')\r\nconst { Sequelize } = require('sequelize')\r\nconst fs = require('fs')\r\n\r\nconst umzug = new Umzug({\r\n  migrations: {\r\n    glob: 'migrations/*.up.sql',\r\n    resolve: ({ name, path, context: sequelize }) => ({\r\n      name,\r\n      up: async () => {\r\n        const sql = fs.readFileSync(path).toString()\r\n        return sequelize.query(sql)\r\n      },\r\n      down: async () => {\r\n        // Get the corresponding `.down.sql` file to undo this migration\r\n        const sql = fs.readFileSync(path.replace('.up.sql', '.down.sql')).toString()\r\n        return sequelize.query(sql)\r\n      }\r\n    })\r\n  },\r\n  context: new Sequelize(...),\r\n  logger: console,\r\n});\r\n```\r\n\r\nYou can support mixed migration file types, and use umzug's default resolver for javascript/typescript:\r\n\r\n```js\r\nconst { Umzug } = require('umzug')\r\nconst { Sequelize } = require('sequelize')\r\nconst fs = require('fs')\r\n\r\nconst umzug = new Umzug({\r\n  migrations: {\r\n    glob: 'migrations/*.{js,ts,up.sql}',\r\n    resolve: (params) => {\r\n      if (!params.path.endsWith('.sql')) {\r\n        return Umzug.defaultResolver(params)\r\n      }\r\n      const { context: sequelize } = params\r\n      return {\r\n        name: params.name,\r\n        up: async () => {\r\n          const sql = fs.readFileSync(params.path).toString()\r\n          return sequelize.query(sql)\r\n        },\r\n        down: async () => {\r\n          // Get the corresponding `.down.sql` file to undo this migration\r\n          const sql = fs.readFileSync(params.path.replace('.up.sql', '.down.sql')).toString()\r\n          return sequelize.query(sql)\r\n        }\r\n      }\r\n    },\r\n  },\r\n  logger: console,\r\n  context: new Sequelize(...),\r\n});\r\n```\r\n\r\nThe glob syntax allows loading migrations from multiple locations:\r\n\r\n```js\r\nconst { Umzug } = require('umzug')\r\nconst { Sequelize } = require('sequelize')\r\n\r\nconst umzug = new Umzug({\r\n  migrations: {\r\n    glob: '{first-folder/*.js,second-folder-with-different-naming-convention/*.js}',\r\n  },\r\n  context: new Sequelize(...),\r\n  logger: console,\r\n});\r\n```\r\n\r\nNote on migration file sorting:\r\n\r\n- file matches, found using [glob](https://npmjs.com/package/glob), will be lexicographically sorted based on their paths\r\n  - so if your migrations are `one/m1.js`, `two/m2.js`, `three/m3.js`, the resultant order will be `one/m1.js`, `three/m3.js`, `two/m2.js`\r\n  - similarly, if your migrations are called `m1.js`, `m2.js`, ... `m10.js`, `m11.js`, the resultant ordering will be `m1.js`, `m10.js`, `m11.js`, ... `m2.js`\r\n- The easiest way to deal with this is to ensure your migrations appear in a single folder, and their paths match lexicographically with the order they should run in\r\n- If this isn't possible, the ordering can be customised using `.extend(...)` (see below)\r\n\r\n### Upgrading from v2.x\r\n\r\nThe Umzug class should be imported as a named import, i.e. `import { Umzug } from 'umzug'`.\r\n\r\nThe `MigrationMeta` type, which is returned by `umzug.executed()` and `umzug.pending()`, no longer has a `file` property - it has a `name` and *optional* `path` - since migrations are not necessarily bound to files on the file system.\r\n\r\nThe `migrations.glob` parameter replaces `path`, `pattern` and `traverseDirectories`. It can be used, in combination with `cwd` and `ignore` to do much more flexible file lookups. See https://npmjs.com/package/glob for more information on the syntax.\r\n\r\nThe `migrations.resolve` parameter replaces `customResolver`. Explicit support for `wrap` and `nameFormatter` has been removed - these can be easily implemented in a `resolve` function.\r\n\r\nThe constructor option `logging` is replaced by `logger` to allow for `warn` and `error` messages in future. NodeJS's global `console` object can be passed to this. To disable logging, replace `logging: false` with `logger: undefined`.\r\n\r\nEvents have moved from the default nodejs `EventEmitter` to [emittery](https://www.npmjs.com/package/emittery). It has better design for async code, a less bloated API surface and strong types. But, it doesn't allow passing multiple arguments to callbacks, so listeners have to change slightly, as well as `.addListener(...)` and `.removeListener(...)` no longer being supported (`.on(...)` and `.off(...)` should now be used):\r\n\r\nBefore:\r\n\r\n```js\r\numzug.on('migrating', (name, m) => console.log({ name, path: m.path }))\r\n```\r\n\r\nAfter:\r\n\r\n```js\r\numzug.on('migrating', ev => console.log({ name: ev.name, path: ev.path }))\r\n```\r\n\r\nThe `Umzug#execute` method is removed. Use `Umzug#up` or `Umzug#down`.\r\n\r\nThe options for `Umguz#up` and `Umzug#down` have changed:\r\n- `umzug.up({ to: 'some-name' })` and `umzug.down({ to: 'some-name' })` are still valid.\r\n- `umzug.up({ from: '...' })` and `umzug.down({ from: '...' })` are no longer supported. To run migrations out-of-order (which is not generally recommended), you can explicitly use `umzug.up({ migrations: ['...'] })` and `umzug.down({ migrations: ['...'] })`.\r\n- name matches must be exact. `umzug.up({ to: 'some-n' })` will no longer match a migration called `some-name`.\r\n- `umzug.down({ to: 0 })` is still valid but `umzug.up({ to: 0 })` is not.\r\n- `umzug.up({ migrations: ['m1', 'm2'] })` is still valid but the shorthand `umzug.up(['m1', 'm2'])` has been removed.\r\n- `umzug.down({ migrations: ['m1', 'm2'] })` is still valid but the shorthand `umzug.down(['m1', 'm2'])` has been removed.\r\n- `umzug.up({ migrations: ['m1', 'already-run'] })` will throw an error, if `already-run` is not found in the list of pending migrations.\r\n- `umzug.down({ migrations: ['m1', 'has-not-been-run'] })` will throw an error, if `has-not-been-run` is not found in the list of executed migrations.\r\n- `umzug.up({ migrations: ['m1', 'm2'], rerun: 'ALLOW' })` will re-apply migrations `m1` and `m2` even if they've already been run.\r\n- `umzug.up({ migrations: ['m1', 'm2'], rerun: 'SKIP' })` will skip migrations `m1` and `m2` if they've already been run.\r\n- `umzug.down({ migrations: ['m1', 'm2'], rerun: 'ALLOW' })` will \"revert\" migrations `m1` and `m2` even if they've never been run.\r\n- `umzug.down({ migrations: ['m1', 'm2'], rerun: 'SKIP' })` will skip reverting migrations `m1` and `m2` if they haven't been run or are already reverted.\r\n- `umzug.up({ migrations: ['m1', 'does-not-exist', 'm2'] })` will throw an error if the migration name is not found. Note that the error will be thrown and no migrations run unless _all_ migration names are found - whether or not `rerun: 'ALLOW'` is added.\r\n\r\nThe `context` parameter replaces `params`, and is passed in as a property to migration functions as an options object, alongs side `name` and `path`. This means the signature for migrations, which in v2 was `(context) => Promise<void>`, has changed slightly in v3, to `({ name, path, context }) => Promise<void>`. The `resolve` function can also be used to upgrade your umzug version to v3 when you have existing v2-compatible migrations:\r\n\r\n```js\r\nconst { Umzug } = require('umzug');\r\n\r\nconst umzug = new Umzug({\r\n  migrations: {\r\n    glob: 'migrations/umzug-v2-format/*.js',\r\n    resolve: ({name, path, context}) => {\r\n      // Adjust the migration from the new signature to the v2 signature, making easier to upgrade to v3\r\n      const migration = require(path)\r\n      return { name, up: async () => migration.up(context), down: async () => migration.down(context) }\r\n    }\r\n  },\r\n  context: sequelize.getQueryInterface(),\r\n  logger: console,\r\n});\r\n```\r\n\r\nSimilarly, you no longer need `migrationSorting`, you can use `Umzug#extend` to manipulate migration lists directly:\r\n\r\n```js\r\nconst { Umzug } = require('umzug');\r\n\r\nconst umzug =\r\n  new Umzug({\r\n    migrations: { glob: 'migrations/**/*.js' },\r\n    context: sequelize.getQueryInterface(),\r\n  })\r\n  .extend(migrations => migrations.sort((a, b) => b.path.localeCompare(a.path)));\r\n```\r\n\r\n### Storages\r\n\r\nStorages define where the migration data is stored.\r\n\r\n#### JSON Storage\r\n\r\nUsing `JSONStorage` will create a JSON file which will contain an array with all the executed migrations. You can specify the path to the file. The default for that is `umzug.json` in the working directory of the process.\r\n\r\nDetailed documentation for the options it can take are in the `JSONStorageConstructorOptions` TypeScript interface, which can be found in [src/storage/json.ts](./src/storage/json.ts).\r\n\r\n#### Memory Storage\r\n\r\nUsing `memoryStorage` will store migrations with an in-memory array. This can be useful for proof-of-concepts or tests, since it doesn't interact with databases or filesystems.\r\n\r\nIt doesn't take any options, just import the `memoryStorage` function and call it to return a storage instance:\r\n\r\n```typescript\r\nimport { Umzug, memoryStorage } from 'umzug'\r\n\r\nconst umzug = new Umzug({\r\n  migrations: ...,\r\n  storage: memoryStorage(),\r\n  logger: console,\r\n})\r\n```\r\n\r\n#### Sequelize Storage\r\n\r\nUsing `SequelizeStorage` will create a table in your SQL database called `SequelizeMeta` containing an entry for each executed migration. You will have to pass a configured instance of Sequelize or an existing Sequelize model. Optionally you can specify the model name, table name, or column name. All major Sequelize versions are supported.\r\n\r\nDetailed documentation for the options it can take are in the `_SequelizeStorageConstructorOptions` TypeScript interface, which can be found in [src/storage/sequelize.ts](./src/storage/sequelize.ts).\r\n\r\n#### MongoDB Storage\r\n\r\nUsing `MongoDBStorage` will create a collection in your MongoDB database called `migrations` containing an entry for each executed migration. You will have either to pass a MongoDB Driver Collection as `collection` property. Alternatively you can pass a established MongoDB Driver connection and a collection name.\r\n\r\nDetailed documentation for the options it can take are in the `MongoDBStorageConstructorOptions` TypeScript interface, which can be found in [src/storage/mongodb.ts](./src/storage/mongodb.ts).\r\n\r\n#### Custom\r\n\r\nIn order to use a custom storage, you can pass your storage instance to Umzug constructor.\r\n\r\n```js\r\nclass CustomStorage {\r\n  constructor(...) {...}\r\n  logMigration(...) {...}\r\n  unlogMigration(...) {...}\r\n  executed(...) {...}\r\n}\r\n\r\nconst umzug = new Umzug({ storage: new CustomStorage(...), logger: console })\r\n```\r\n\r\nYour instance must adhere to the [UmzugStorage](./src/storage/contract.ts) interface. If you're using TypeScript you can ensure this at compile time, and get IDE type hints by importing it:\r\n\r\n```typescript\r\nimport { UmzugStorage } from 'umzug'\r\n\r\nclass CustomStorage implements UmzugStorage {\r\n  /* ... */\r\n}\r\n```\r\n\r\n### Events\r\n\r\nUmzug is an [emittery event emitter](https://www.npmjs.com/package/emittery). Each of the following events will be called with migration parameters as its payload (with `context`, `name`, and nullable `path` properties). Events are a convenient place to implement application-specific logic that must run around each migration:\r\n\r\n* `migrating` - A migration is about to be executed.\r\n* `migrated` - A migration has successfully been executed.\r\n* `reverting` - A migration is about to be reverted.\r\n* `reverted` - A migration has successfully been reverted.\r\n\r\nThese events run at the beginning and end of `up` and `down` calls. They'll receive an object containing a `context` property:\r\n\r\n- `beforeAll` - Before any of the migrations are run.\r\n- `afterAll` - After all the migrations have been executed. Note: this will always run, even if migrations throw an error.\r\n\r\nThe [`FileLocker` class](./src/file-locker.ts) uses `beforeAll` and `afterAll` to implement a simple filesystem-based locking mechanism.\r\n\r\nAll events are type-safe, so IDEs will prevent typos and supply strong types for the event payloads.\r\n\r\n### CLI\r\n\r\n🚧🚧🚧 The CLI is new to Umzug v3 beta and is not yet stable. Feedback on it is welcome in [discussions](https://github.com/sequelize/umzug/discussions) 🚧🚧🚧\r\n\r\nUmzug instances provide a `.runAsCLI()` method. When called, this method will automatically cause your program to become a complete CLI, with help text and such:\r\n\r\n```js\r\n// migrator.js\r\nconst { Umzug } = require('umzug')\r\n\r\nexports.umzug = new Umzug({ ... })\r\n\r\nif (require.main === module) {\r\n  umzug.runAsCLI()\r\n}\r\n```\r\n\r\n#### CLI Usage\r\n\r\nA script like the one above is now a runnable CLI program. You can run `node migrator.js --help` to see how to use it. It will print something like:\r\n\r\n<!-- codegen:start {preset: custom, source: ./codegen.js, export: cliHelp} -->\r\n```\r\nusage: <script> [-h] <command> ...\r\n\r\nUmzug migrator\r\n\r\nPositional arguments:\r\n  <command>\r\n    up        Applies pending migrations\r\n    down      Revert migrations\r\n    pending   Lists pending migrations\r\n    executed  Lists executed migrations\r\n    create    Create a migration file\r\n\r\nOptional arguments:\r\n  -h, --help  Show this help message and exit.\r\n\r\nFor detailed help about a specific command, use: <script> <command> -h\r\n```\r\n<!-- codegen:end -->\r\n\r\n#### Running migrations\r\n\r\n`node migrator up` and `node migrator down` apply and revert migrations respectively. They're the equivalent of the `.up()` and `.down()` methods.\r\n\r\nUse `node migrator up --help` and `node migrator down --help` for options (running \"to\" a specific migration, passing migration names to be run explicitly, and specifying the rerun behavior):\r\n\r\nUp:\r\n<!-- codegen:start {preset: custom, source: ./codegen.js, export: cliHelp, action: up} -->\r\n```\r\nusage: <script> up [-h] [--to NAME] [--step COUNT] [--name MIGRATION]\r\n                   [--rerun {THROW,SKIP,ALLOW}]\r\n                   \r\n\r\nPerforms all migrations. See --help for more options\r\n\r\nOptional arguments:\r\n  -h, --help            Show this help message and exit.\r\n  --to NAME             All migrations up to and including this one should be \r\n                        applied.\r\n  --step COUNT          Run this many migrations. If not specified, all will \r\n                        be applied.\r\n  --name MIGRATION      Explicity declare migration name(s) to be applied.\r\n  --rerun {THROW,SKIP,ALLOW}\r\n                        Specify what action should be taken when a migration \r\n                        that has already been applied is passed to --name. \r\n                        The default value is \"THROW\".\r\n```\r\n<!-- codegen:end -->\r\n\r\nDown:\r\n<!-- codegen:start {preset: custom, source: ./codegen.js, export: cliHelp, action: down} -->\r\n```\r\nusage: <script> down [-h] [--to NAME] [--step COUNT] [--name MIGRATION]\r\n                     [--rerun {THROW,SKIP,ALLOW}]\r\n                     \r\n\r\nUndoes previously-applied migrations. By default, undoes the most recent \r\nmigration only. Use --help for more options. Useful in development to start \r\nfrom a clean slate. Use with care in production!\r\n\r\nOptional arguments:\r\n  -h, --help            Show this help message and exit.\r\n  --to NAME             All migrations up to and including this one should be \r\n                        reverted. Pass \"0\" to revert all.\r\n  --step COUNT          Run this many migrations. If not specified, one will \r\n                        be reverted.\r\n  --name MIGRATION      Explicity declare migration name(s) to be reverted.\r\n  --rerun {THROW,SKIP,ALLOW}\r\n                        Specify what action should be taken when a migration \r\n                        that has already been reverted is passed to --name. \r\n                        The default value is \"THROW\".\r\n```\r\n<!-- codegen:end -->\r\n\r\n\r\n#### Listing migrations\r\n\r\n```bash\r\nnode migrator pending # list migrations yet to be run\r\nnode migrator executed # list migrations that have already run\r\n\r\nnode migrator pending --json # list pending migrations including names and paths, in a json array format\r\nnode migrator executed --json # list executed migrations including names and paths, in a json array format\r\n\r\nnode migrator pending --help # show help/options\r\nnode migrator executed --help # show help/options\r\n```\r\n\r\n<!-- codegen:start {preset: custom, source: ./codegen.js, export: cliHelp, action: pending} -->\r\n```\r\nusage: <script> pending [-h] [--json]\r\n\r\nPrints migrations returned by `umzug.pending()`. By default, prints migration \r\nnames one per line.\r\n\r\nOptional arguments:\r\n  -h, --help  Show this help message and exit.\r\n  --json      Print pending migrations in a json format including names and \r\n              paths. This allows piping output to tools like jq. Without this \r\n              flag, the migration names will be printed one per line.\r\n```\r\n<!-- codegen:end -->\r\n\r\n<!-- codegen:start {preset: custom, source: ./codegen.js, export: cliHelp, action: executed} -->\r\n```\r\nusage: <script> executed [-h] [--json]\r\n\r\nPrints migrations returned by `umzug.executed()`. By default, prints \r\nmigration names one per line.\r\n\r\nOptional arguments:\r\n  -h, --help  Show this help message and exit.\r\n  --json      Print executed migrations in a json format including names and \r\n              paths. This allows piping output to tools like jq. Without this \r\n              flag, the migration names will be printed one per line.\r\n```\r\n<!-- codegen:end -->\r\n\r\n#### Creating migrations - CLI\r\n\r\nUsually, migrations correspond to files on the filesystem. The CLI exposes a way to create migration files easily:\r\n\r\n```bash\r\nnode migrator create --name my-migration.js\r\n```\r\n\r\nThis will create a file with a name like `2000.12.25T12.34.56.my-migration.js` in the same directory as the most recent migration file. If it's the very first migration file, you need to specify the folder explicitly:\r\n\r\n```bash\r\nnode migrator create --name my-migration.js --folder path/to/directory\r\n```\r\n\r\nThe timestamp prefix can be customized to be date-only or omitted, but be aware that it's strongly recommended to ensure your migrations are lexicographically sortable so it's easy for humans and tools to determine what order they should run in - so the default prefix is recommended.\r\n\r\nThis will generate a migration file called `<<timestamp>>.my-migration.js` with the default migration template for `.js` files that ships with Umzug.\r\n\r\nUmzug also ships with default templates for [`.ts`, `.cjs`, `.mjs` and `.sql` files](./src/templates.ts). Umzug will choose the template based on the extension you provide in `name`.\r\n\r\nYou can specify a custom template for your project when constructing an umzug instance via the `template` option. It should be a function which receives a filepath string, and returns an array of `[filepath, content]` pairs. Usually, just one pair is needed, but a second could be used to include a \"down\" migration in a separate file:\r\n\r\n```js\r\nconst umzug = new Umzug({\r\n  migrations: ...,\r\n  template: filepath => [\r\n    [filepath, fs.readFileSync('path/to/your/template/file').toString()],\r\n  ]\r\n})\r\n```\r\n\r\nThe create command includes some safety checks to make sure migrations aren't created with ambiguous ordering, and that they will be picked up by umzug when applying migrations.\r\n\r\nUse `node migrator create --help` for more options:\r\n\r\n<!-- codegen:start {preset: custom, source: ./codegen.js, export: cliHelp, action: create} -->\r\n```\r\nusage: <script> create [-h] --name NAME [--prefix {TIMESTAMP,DATE,NONE}]\r\n                       [--folder PATH] [--allow-extension EXTENSION]\r\n                       [--skip-verify] [--allow-confusing-ordering]\r\n                       \r\n\r\nGenerates a placeholder migration file using a timestamp as a prefix. By \r\ndefault, mimics the last existing migration, or guesses where to generate the \r\nfile if no migration exists yet.\r\n\r\nOptional arguments:\r\n  -h, --help            Show this help message and exit.\r\n  --name NAME           The name of the migration file. e.g. my-migration.js, \r\n                        my-migration.ts or my-migration.sql. Note - a prefix \r\n                        will be added to this name, usually based on a \r\n                        timestamp. See --prefix\r\n  --prefix {TIMESTAMP,DATE,NONE}\r\n                        The prefix format for generated files. TIMESTAMP uses \r\n                        a second-resolution timestamp, DATE uses a \r\n                        day-resolution timestamp, and NONE removes the prefix \r\n                        completely. The default value is \"TIMESTAMP\".\r\n  --folder PATH         Path on the filesystem where the file should be \r\n                        created. The new migration will be created as a \r\n                        sibling of the last existing one if this is omitted.\r\n  --allow-extension EXTENSION\r\n                        Allowable extension for created files. By default .js,\r\n                         .ts and .sql files can be created. To create txt \r\n                        file migrations, for example, you could use '--name \r\n                        my-migration.txt --allow-extension .txt' This \r\n                        parameter may alternatively be specified via the \r\n                        UMZUG_ALLOW_EXTENSION environment variable.\r\n  --skip-verify         By default, the generated file will be checked after \r\n                        creation to make sure it is detected as a pending \r\n                        migration. This catches problems like creation in the \r\n                        wrong folder, or invalid naming conventions. This \r\n                        flag bypasses that verification step.\r\n  --allow-confusing-ordering\r\n                        By default, an error will be thrown if you try to \r\n                        create a migration that will run before a migration \r\n                        that already exists. This catches errors which can \r\n                        cause problems if you change file naming conventions. \r\n                        If you use a custom ordering system, you can disable \r\n                        this behavior, but it's strongly recommended that you \r\n                        don't! If you're unsure, just ignore this option.\r\n```\r\n<!-- codegen:end -->\r\n\r\n### Creating migrations - API\r\n\r\nUmzug includes an optional helper for generating migration files. It's often most convenient to create files using the [CLI helper](#creating-migrations---cli), but the equivalent API also exists on an umzug instance:\r\n\r\n```js\r\nawait umzug.create({ name: 'my-new-migration.js' })\r\n```\r\n\r\n## License\r\n\r\nSee the [LICENSE file](./LICENSE)\r\n","readmeFilename":"README.md","gitHead":"2ebf98ba6b9d1243186bcf152ef2c56d8a13ef2c","_id":"umzug@3.0.0-beta.10","_nodeVersion":"12.18.0","_npmVersion":"6.14.8","dist":{"integrity":"sha512-58z7r4epVOJa/lPiEJ6pl204pP0mKwk/JpHFv2VWrnPSQkMDr2kTmsoQrrtWOZfsCspJ94Dc6Py3gfgewekyGw==","shasum":"b8a2f59447b4c2666ecdba319271f25d7befe045","tarball":"https://registry.npmjs.org/umzug/-/umzug-3.0.0-beta.10.tgz","fileCount":40,"unpackedSize":125211,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJfzoGACRA9TVsSAnZWagAAbCQQAKJoNXu8mu/7UKXSlmHs\nOgVtESE2/9XdmMPQQKqJC7IZFdOM4SXPwvIwJ/ZX6aB3zdxWR+0OC5U7ypP/\nyrP/r5vOZNl591z6CUIvIgJG5nR3BrJvZYoeHbt1OzFnjaUCTlxfNtPyAAOV\neG+mvfWBUIewfNLidk372u0nO/uYD2EKX7usgUX2/m1veiYs+heRf8J7ES9R\n53a2qQhLRzgvccD9cM3qi3D27sltXd4qec/9TibcE5+9dvTki/alQ9zWB09B\nt6sX0U1l04CKvjCeJ5O90do8XXYXEnoyCkdq/JUCLePGOb02cp0NKm5mEDxy\n2WOdaRI5Flw1qpI4RASf2p0kK+x1YfmqcQIXcjScIHtapLM6yL7khDKDIo+b\n8Jf3aQv+DE5jcon7HpUvXNNVrWgKaZm2hAOpzZphKdJ3EFGsjz8+m/7KuS3k\no/2BajlNOOZRahhlM5qS2AsgaQsuDoVFbgbXxOaxko8RO4Gi84NLGQl/mja9\nvU8yDFnZpRXW9YKlNwD2YqABqfsQ4YPjL7e5LGvyXZcHGdw2EeolO8TFqJTk\ncVk+23TmQoTW4eaiYITNGVkavLGBIJUgjq6CdhuVTv+6b4Ci+CeLa2BQbmJ/\n2fwIH/nx24smsn5+b/8CTfvAdSTeRPMSDoe2zZw8LYtNawBNreWyuvvB4PiO\nAze+\r\n=FRbv\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEYCIQDp8qM+ZSoRybUhqveQbvxEDpWrbMsymaWVSXXHNevHbAIhAIisG020xXrj+/LYE/m5RUNTXMpvFo/EqdLKgLjPRffE"}]},"_npmUser":{"name":"mmkale","email":"mmkal1@outlook.com"},"directories":{},"maintainers":[{"name":"pascal.pflaum","email":"mail@pascalpflaum.de"},{"name":"sdepold","email":"sascha@depold.com"},{"name":"sushantdhiman","email":"sushantdhiman@outlook.com"},{"name":"papb","email":"papb1996@gmail.com"},{"name":"mmkale","email":"mmkal1@outlook.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/umzug_3.0.0-beta.10_1607369087471_0.35158060671336333"},"_hasShrinkwrap":false},"3.0.0-beta.11":{"name":"umzug","version":"3.0.0-beta.11","description":"Framework-agnostic migration tool for Node","keywords":["migrate","migration","migrations","sequelize","database"],"main":"lib/index.js","dependencies":{"@rushstack/ts-command-line":"~4.7.7","@types/verror":"^1.10.4","emittery":"~0.7.2","fs-jetpack":"~4.0.0","glob":"~7.1.6","type-fest":"~0.19.0","verror":"^1.10.0"},"devDependencies":{"@types/jest":"26.0.16","@types/lodash":"4.14.165","@types/uuid":"8.3.0","@typescript-eslint/eslint-plugin":"4.9.0","@typescript-eslint/parser":"4.9.0","del-cli":"3.0.1","eslint":"7.15.0","eslint-config-xo":"0.33.1","eslint-config-xo-typescript":"0.36.0","eslint-plugin-codegen":"0.14.3","eslint-plugin-import":"2.22.1","eslint-plugin-jest":"24.1.3","eslint-plugin-mocha":"8.0.0","eslint-plugin-prettier":"3.2.0","eslint-plugin-unicorn":"23.0.0","expect-type":"0.10.0","fs-syncer":"0.3.3","jest":"26.6.3","lodash":"4.17.20","np":"7.0.0","prettier":"2.2.1","sequelize":"5.22.3","sinon":"9.2.1","source-map-support":"0.5.19","sqlite3":"5.0.0","strip-ansi":"6.0.0","ts-jest":"26.4.4","ts-node":"9.0.0","typescript":"4.1.2","uuid":"8.3.1"},"scripts":{"build":"del-cli lib && tsc","lint":"eslint --ext .js,.ts,.md . --max-warnings 0","prepare":"npm run build","release":"np --no-yarn --no-2fa","pretest":"del-cli test/generated","test":"jest"},"repository":{"type":"git","url":"git+https://github.com/sequelize/umzug.git"},"author":{"name":"Sascha Depold","email":"sascha@depold.com"},"contributors":[{"name":"Jukka Hyytiälä","email":"hyytiala.jukka@gmail.com"},{"name":"Pascal Pflaum","email":"mail@pascalpflaum.de"},{"name":"Pedro Augusto de Paula Barbosa","email":"papb1996@gmail.com"}],"license":"MIT","bugs":{"url":"https://github.com/sequelize/umzug/issues"},"homepage":"https://github.com/sequelize/umzug","engines":{"node":">=10.0.0"},"jest":{"preset":"ts-jest","globals":{"ts-jest":{"diagnostics":false}},"testEnvironment":"node","testMatch":["**/*test.ts"],"collectCoverageFrom":["src/**"]},"readme":"# Umzug\r\n\r\n[![Build Status](https://badgen.net/github/checks/sequelize/umzug/master)](https://github.com/sequelize/umzug/actions?query=workflow%3ACI)\r\n[![npm (stable)](https://badgen.net/npm/v/umzug)](https://www.npmjs.com/package/umzug)\r\n[![npm (beta)](https://badgen.net/npm/v/umzug/beta)](https://www.npmjs.com/package/umzug/v/beta)\r\n[![npm (downloads)](https://badgen.net/npm/dm/umzug)](https://npmjs.com/package/umzug)\r\n\r\nUmzug is a framework-agnostic migration tool for Node. It provides a clean API for running and rolling back tasks.\r\n\r\n_Note: master represents the next major version of umzug - v3 - which is currently in beta. For the stable version, please refer to the [v2.x branch](https://github.com/sequelize/umzug/tree/v2.x)._\r\n\r\nTo install the v3-beta package:\r\n\r\n```\r\nnpm install umzug@beta\r\n```\r\n\r\nTo install the stable package (v2.x):\r\n\r\n```\r\nnpm install umzug\r\n```\r\n\r\n## Highlights\r\n\r\n* Written in TypeScript\r\n\t* Built-in typings\r\n\t* Auto-completion right in your IDE\r\n\t* Documentation right in your IDE\r\n* Programmatic API for migrations\r\n* Built-in [CLI](#cli)\r\n* Database agnostic\r\n* Supports logging of migration process\r\n* Supports multiple storages for migration data\r\n* [Usage examples](./examples)\r\n\r\n## Documentation\r\n\r\n### Minimal Example\r\n\r\nThe following example uses a Sqlite database through sequelize and persists the migration data in the database itself through the sequelize storage. There are several more involved examples covering a few different scenarios in the [examples folder](./examples).\r\n\r\n```js\r\n// index.js\r\nconst { Sequelize } = require('sequelize');\r\nconst { Umzug, SequelizeStorage } = require('umzug');\r\n\r\nconst sequelize = new Sequelize({ dialect: 'sqlite', storage: './db.sqlite' });\r\n\r\nconst umzug = new Umzug({\r\n  migrations: { glob: 'migrations/*.js' },\r\n  context: sequelize.getQueryInterface(),\r\n  storage: new SequelizeStorage({ sequelize }),\r\n  logger: console,\r\n});\r\n\r\n(async () => {\r\n  // Checks migrations and run them if they are not already applied. To keep\r\n  // track of the executed migrations, a table (and sequelize model) called SequelizeMeta\r\n  // will be automatically created (if it doesn't exist already) and parsed.\r\n  await umzug.up();\r\n})();\r\n```\r\n\r\n```js\r\n// migrations/00_initial.js\r\n\r\nconst { Sequelize } = require('sequelize');\r\n\r\nasync function up({ context: queryInterface }) {\r\n\tawait queryInterface.createTable('users', {\r\n\t\tid: {\r\n\t\t\ttype: Sequelize.INTEGER,\r\n\t\t\tallowNull: false,\r\n\t\t\tprimaryKey: true\r\n\t\t},\r\n\t\tname: {\r\n\t\t\ttype: Sequelize.STRING,\r\n\t\t\tallowNull: false\r\n\t\t},\r\n\t\tcreatedAt: {\r\n\t\t\ttype: Sequelize.DATE,\r\n\t\t\tallowNull: false\r\n\t\t},\r\n\t\tupdatedAt: {\r\n\t\t\ttype: Sequelize.DATE,\r\n\t\t\tallowNull: false\r\n\t\t}\r\n\t});\r\n}\r\n\r\nasync function down({ context: queryInterface }) {\r\n\tawait queryInterface.dropTable('users');\r\n}\r\n\r\nmodule.exports = { up, down };\r\n```\r\n\r\nNote that we renamed the `context` argument to `queryInterface` for clarity. The `context` is whatever we specified when creating the Umzug instance in `index.js`.\r\n\r\n<details>\r\n<summary>You can also write your migrations in typescript by using `ts-node` in the entrypoint:</summary>\r\n\r\n```typescript\r\n// index.ts\r\nrequire('ts-node/register')\r\n\r\nimport { Sequelize } from 'sequelize';\r\nimport { Umzug, SequelizeStorage } from 'umzug';\r\n\r\nconst sequelize = new Sequelize({ dialect: 'sqlite', storage: './db.sqlite' });\r\n\r\nconst umzug = new Umzug({\r\n  migrations: { glob: 'migrations/*.ts' },\r\n  context: sequelize.getQueryInterface(),\r\n  storage: new SequelizeStorage({ sequelize }),\r\n  logger: console,\r\n});\r\n\r\n// export the type helper exposed by umzug, which will have the `context` argument typed correctly\r\nexport type Migration = typeof umzug._types.migration;\r\n\r\n(async () => {\r\n  await umzug.up();\r\n})();\r\n```\r\n\r\n```typescript\r\n// migrations/00_initial.ts\r\nimport type { Migration } from '..';\r\n\r\n// types will now be available for `queryInterface`\r\nexport const up: Migration = ({ context: queryInterface }) => queryInterface.createTable(...)\r\nexport const down: Migration = ({ context: queryInterface }) => queryInterface.dropTable(...)\r\n```\r\n</details>\r\n\r\nSee [these tests](./test/umzug.test.ts) for more examples of Umzug usage, including:\r\n\r\n- passing `ignore` and `cwd` parameters to the glob instructions\r\n- customising migrations ordering\r\n- finding migrations from multiple different directories\r\n- using non-js file extensions via a custom resolver, e.g. `.sql`\r\n\r\n### Usage\r\n\r\n#### Installation\r\n\r\nThe beta version of Umzug is available on npm by specifying the correct tag:\r\n\r\n```bash\r\nnpm install umzug@beta\r\n```\r\n\r\n#### Umzug instance\r\n\r\nIt is possible to configure an Umzug instance by passing an object to the constructor.\r\n\r\n```js\r\nconst { Umzug } = require('umzug');\r\nconst umzug = new Umzug({ /* ... options ... */ });\r\n```\r\n\r\nDetailed documentation for these options are in the `UmzugOptions` TypeScript interface, which can be found in [src/types.ts](./src/types.ts).\r\n\r\n#### Getting all pending migrations\r\n\r\nYou can get a list of pending (i.e. not yet executed) migrations with the `pending()` method:\r\n\r\n```js\r\nconst migrations = await umzug.pending();\r\n// returns an array of all pending migrations.\r\n```\r\n\r\n#### Getting all executed migrations\r\n\r\nYou can get a list of already executed migrations with the `executed()` method:\r\n\r\n```js\r\nconst migrations = await umzug.executed();\r\n// returns an array of all already executed migrations\r\n```\r\n\r\n#### Executing pending migrations\r\n\r\nThe `up` method can be used to execute all pending migrations.\r\n\r\n```js\r\nconst migrations = await umzug.up();\r\n// returns an array of all executed migrations\r\n```\r\n\r\nIt is also possible to pass the name of a migration in order to just run the migrations from the current state to the passed migration name (inclusive).\r\n\r\n```js\r\nawait umzug.up({ to: '20141101203500-task' });\r\n```\r\n\r\nTo limit the number of migrations that are run, `step` can be used:\r\n\r\n```js\r\n// This will run the next two migrations\r\nawait umzug.up({ step: 2 })\r\n```\r\n\r\nRunning specific migrations while ignoring the right order, can be done like this:\r\n\r\n```js\r\nawait umzug.up({ migrations: ['20141101203500-task', '20141101203501-task-2'] });\r\n```\r\n\r\n#### Reverting executed migration\r\n\r\nThe `down` method can be used to revert the last executed migration.\r\n\r\n```js\r\nconst migration = await umzug.down();\r\n// reverts the last migration and returns it.\r\n```\r\n\r\nTo revert more than one migration, you can use `step`:\r\n\r\n```js\r\n// This will revert the last two migrations\r\nawait umzug.down({ step: 2 });\r\n```\r\n\r\nIt is possible to pass the name of a migration until which (inclusive) the migrations should be reverted. This allows the reverting of multiple migrations at once.\r\n\r\n```js\r\nconst migrations = await umzug.down({ to: '20141031080000-task' });\r\n// returns an array of all reverted migrations.\r\n```\r\n\r\nTo revert all migrations, you can pass 0 as the `to` parameter:\r\n\r\n```js\r\nawait umzug.down({ to: 0 });\r\n```\r\n\r\nReverting specific migrations while ignoring the right order, can be done like this:\r\n\r\n```js\r\nawait umzug.down({ migrations: ['20141101203500-task', '20141101203501-task-2'] });\r\n```\r\n\r\n### Migrations\r\n\r\nThere are two ways to specify migrations: via files or directly via an array of migrations.\r\n\r\n#### Migration files\r\n\r\nA migration file ideally exposes an `up` and a `down` async functions. They will perform the task of upgrading or downgrading the database.\r\n\r\n```js\r\nmodule.exports = {\r\n  async up() {\r\n    /* ... */\r\n  },\r\n  async down() {\r\n    /* ... */\r\n  }\r\n};\r\n```\r\n\r\nMigration files can be located anywhere - they will typically be loaded according to a glob pattern provided to the `Umzug` constructor.\r\n\r\n#### Direct migrations list\r\n\r\nYou can also specify directly a list of migrations to the `Umzug` constructor:\r\n\r\n```js\r\nconst { Umzug } = require('umzug');\r\n\r\nconst umzug = new Umzug({\r\n  migrations: [\r\n    {\r\n      // the name of the migration is mandatory\r\n      name: '00-first-migration',\r\n      async up({ context }) { /* ... */ },\r\n      async down({ context }) { /* ... */ }\r\n    },\r\n    {\r\n      name: '01-foo-bar-migration',\r\n      async up({ context }) { /* ... */ },\r\n      async down({ context }) { /* ... */ }\r\n    }\r\n  ],\r\n  context: sequelize.getQueryInterface(),\r\n  logger: console,\r\n});\r\n```\r\n\r\nTo load migrations in another format, you can use the `resolve` function:\r\n\r\n```js\r\nconst { Umzug } = require('umzug')\r\nconst { Sequelize } = require('sequelize')\r\nconst fs = require('fs')\r\n\r\nconst umzug = new Umzug({\r\n  migrations: {\r\n    glob: 'migrations/*.up.sql',\r\n    resolve: ({ name, path, context: sequelize }) => ({\r\n      name,\r\n      up: async () => {\r\n        const sql = fs.readFileSync(path).toString()\r\n        return sequelize.query(sql)\r\n      },\r\n      down: async () => {\r\n        // Get the corresponding `.down.sql` file to undo this migration\r\n        const sql = fs.readFileSync(path.replace('.up.sql', '.down.sql')).toString()\r\n        return sequelize.query(sql)\r\n      }\r\n    })\r\n  },\r\n  context: new Sequelize(...),\r\n  logger: console,\r\n});\r\n```\r\n\r\nYou can support mixed migration file types, and use umzug's default resolver for javascript/typescript:\r\n\r\n```js\r\nconst { Umzug } = require('umzug')\r\nconst { Sequelize } = require('sequelize')\r\nconst fs = require('fs')\r\n\r\nconst umzug = new Umzug({\r\n  migrations: {\r\n    glob: 'migrations/*.{js,ts,up.sql}',\r\n    resolve: (params) => {\r\n      if (!params.path.endsWith('.sql')) {\r\n        return Umzug.defaultResolver(params)\r\n      }\r\n      const { context: sequelize } = params\r\n      return {\r\n        name: params.name,\r\n        up: async () => {\r\n          const sql = fs.readFileSync(params.path).toString()\r\n          return sequelize.query(sql)\r\n        },\r\n        down: async () => {\r\n          // Get the corresponding `.down.sql` file to undo this migration\r\n          const sql = fs.readFileSync(params.path.replace('.up.sql', '.down.sql')).toString()\r\n          return sequelize.query(sql)\r\n        }\r\n      }\r\n    },\r\n  },\r\n  logger: console,\r\n  context: new Sequelize(...),\r\n});\r\n```\r\n\r\nThe glob syntax allows loading migrations from multiple locations:\r\n\r\n```js\r\nconst { Umzug } = require('umzug')\r\nconst { Sequelize } = require('sequelize')\r\n\r\nconst umzug = new Umzug({\r\n  migrations: {\r\n    glob: '{first-folder/*.js,second-folder-with-different-naming-convention/*.js}',\r\n  },\r\n  context: new Sequelize(...),\r\n  logger: console,\r\n});\r\n```\r\n\r\nNote on migration file sorting:\r\n\r\n- file matches, found using [glob](https://npmjs.com/package/glob), will be lexicographically sorted based on their paths\r\n  - so if your migrations are `one/m1.js`, `two/m2.js`, `three/m3.js`, the resultant order will be `one/m1.js`, `three/m3.js`, `two/m2.js`\r\n  - similarly, if your migrations are called `m1.js`, `m2.js`, ... `m10.js`, `m11.js`, the resultant ordering will be `m1.js`, `m10.js`, `m11.js`, ... `m2.js`\r\n- The easiest way to deal with this is to ensure your migrations appear in a single folder, and their paths match lexicographically with the order they should run in\r\n- If this isn't possible, the ordering can be customised using `.extend(...)` (see below)\r\n\r\n### Upgrading from v2.x\r\n\r\nThe Umzug class should be imported as a named import, i.e. `import { Umzug } from 'umzug'`.\r\n\r\nThe `MigrationMeta` type, which is returned by `umzug.executed()` and `umzug.pending()`, no longer has a `file` property - it has a `name` and *optional* `path` - since migrations are not necessarily bound to files on the file system.\r\n\r\nThe `migrations.glob` parameter replaces `path`, `pattern` and `traverseDirectories`. It can be used, in combination with `cwd` and `ignore` to do much more flexible file lookups. See https://npmjs.com/package/glob for more information on the syntax.\r\n\r\nThe `migrations.resolve` parameter replaces `customResolver`. Explicit support for `wrap` and `nameFormatter` has been removed - these can be easily implemented in a `resolve` function.\r\n\r\nThe constructor option `logging` is replaced by `logger` to allow for `warn` and `error` messages in future. NodeJS's global `console` object can be passed to this. To disable logging, replace `logging: false` with `logger: undefined`.\r\n\r\nEvents have moved from the default nodejs `EventEmitter` to [emittery](https://www.npmjs.com/package/emittery). It has better design for async code, a less bloated API surface and strong types. But, it doesn't allow passing multiple arguments to callbacks, so listeners have to change slightly, as well as `.addListener(...)` and `.removeListener(...)` no longer being supported (`.on(...)` and `.off(...)` should now be used):\r\n\r\nBefore:\r\n\r\n```js\r\numzug.on('migrating', (name, m) => console.log({ name, path: m.path }))\r\n```\r\n\r\nAfter:\r\n\r\n```js\r\numzug.on('migrating', ev => console.log({ name: ev.name, path: ev.path }))\r\n```\r\n\r\nThe `Umzug#execute` method is removed. Use `Umzug#up` or `Umzug#down`.\r\n\r\nThe options for `Umguz#up` and `Umzug#down` have changed:\r\n- `umzug.up({ to: 'some-name' })` and `umzug.down({ to: 'some-name' })` are still valid.\r\n- `umzug.up({ from: '...' })` and `umzug.down({ from: '...' })` are no longer supported. To run migrations out-of-order (which is not generally recommended), you can explicitly use `umzug.up({ migrations: ['...'] })` and `umzug.down({ migrations: ['...'] })`.\r\n- name matches must be exact. `umzug.up({ to: 'some-n' })` will no longer match a migration called `some-name`.\r\n- `umzug.down({ to: 0 })` is still valid but `umzug.up({ to: 0 })` is not.\r\n- `umzug.up({ migrations: ['m1', 'm2'] })` is still valid but the shorthand `umzug.up(['m1', 'm2'])` has been removed.\r\n- `umzug.down({ migrations: ['m1', 'm2'] })` is still valid but the shorthand `umzug.down(['m1', 'm2'])` has been removed.\r\n- `umzug.up({ migrations: ['m1', 'already-run'] })` will throw an error, if `already-run` is not found in the list of pending migrations.\r\n- `umzug.down({ migrations: ['m1', 'has-not-been-run'] })` will throw an error, if `has-not-been-run` is not found in the list of executed migrations.\r\n- `umzug.up({ migrations: ['m1', 'm2'], rerun: 'ALLOW' })` will re-apply migrations `m1` and `m2` even if they've already been run.\r\n- `umzug.up({ migrations: ['m1', 'm2'], rerun: 'SKIP' })` will skip migrations `m1` and `m2` if they've already been run.\r\n- `umzug.down({ migrations: ['m1', 'm2'], rerun: 'ALLOW' })` will \"revert\" migrations `m1` and `m2` even if they've never been run.\r\n- `umzug.down({ migrations: ['m1', 'm2'], rerun: 'SKIP' })` will skip reverting migrations `m1` and `m2` if they haven't been run or are already reverted.\r\n- `umzug.up({ migrations: ['m1', 'does-not-exist', 'm2'] })` will throw an error if the migration name is not found. Note that the error will be thrown and no migrations run unless _all_ migration names are found - whether or not `rerun: 'ALLOW'` is added.\r\n\r\nThe `context` parameter replaces `params`, and is passed in as a property to migration functions as an options object, alongs side `name` and `path`. This means the signature for migrations, which in v2 was `(context) => Promise<void>`, has changed slightly in v3, to `({ name, path, context }) => Promise<void>`. The `resolve` function can also be used to upgrade your umzug version to v3 when you have existing v2-compatible migrations:\r\n\r\n```js\r\nconst { Umzug } = require('umzug');\r\n\r\nconst umzug = new Umzug({\r\n  migrations: {\r\n    glob: 'migrations/umzug-v2-format/*.js',\r\n    resolve: ({name, path, context}) => {\r\n      // Adjust the migration from the new signature to the v2 signature, making easier to upgrade to v3\r\n      const migration = require(path)\r\n      return { name, up: async () => migration.up(context), down: async () => migration.down(context) }\r\n    }\r\n  },\r\n  context: sequelize.getQueryInterface(),\r\n  logger: console,\r\n});\r\n```\r\n\r\nSimilarly, you no longer need `migrationSorting`, you can use `Umzug#extend` to manipulate migration lists directly:\r\n\r\n```js\r\nconst { Umzug } = require('umzug');\r\n\r\nconst umzug =\r\n  new Umzug({\r\n    migrations: { glob: 'migrations/**/*.js' },\r\n    context: sequelize.getQueryInterface(),\r\n  })\r\n  .extend(migrations => migrations.sort((a, b) => b.path.localeCompare(a.path)));\r\n```\r\n\r\n### Storages\r\n\r\nStorages define where the migration data is stored.\r\n\r\n#### JSON Storage\r\n\r\nUsing `JSONStorage` will create a JSON file which will contain an array with all the executed migrations. You can specify the path to the file. The default for that is `umzug.json` in the working directory of the process.\r\n\r\nDetailed documentation for the options it can take are in the `JSONStorageConstructorOptions` TypeScript interface, which can be found in [src/storage/json.ts](./src/storage/json.ts).\r\n\r\n#### Memory Storage\r\n\r\nUsing `memoryStorage` will store migrations with an in-memory array. This can be useful for proof-of-concepts or tests, since it doesn't interact with databases or filesystems.\r\n\r\nIt doesn't take any options, just import the `memoryStorage` function and call it to return a storage instance:\r\n\r\n```typescript\r\nimport { Umzug, memoryStorage } from 'umzug'\r\n\r\nconst umzug = new Umzug({\r\n  migrations: ...,\r\n  storage: memoryStorage(),\r\n  logger: console,\r\n})\r\n```\r\n\r\n#### Sequelize Storage\r\n\r\nUsing `SequelizeStorage` will create a table in your SQL database called `SequelizeMeta` containing an entry for each executed migration. You will have to pass a configured instance of Sequelize or an existing Sequelize model. Optionally you can specify the model name, table name, or column name. All major Sequelize versions are supported.\r\n\r\nDetailed documentation for the options it can take are in the `_SequelizeStorageConstructorOptions` TypeScript interface, which can be found in [src/storage/sequelize.ts](./src/storage/sequelize.ts).\r\n\r\n#### MongoDB Storage\r\n\r\nUsing `MongoDBStorage` will create a collection in your MongoDB database called `migrations` containing an entry for each executed migration. You will have either to pass a MongoDB Driver Collection as `collection` property. Alternatively you can pass a established MongoDB Driver connection and a collection name.\r\n\r\nDetailed documentation for the options it can take are in the `MongoDBStorageConstructorOptions` TypeScript interface, which can be found in [src/storage/mongodb.ts](./src/storage/mongodb.ts).\r\n\r\n#### Custom\r\n\r\nIn order to use a custom storage, you can pass your storage instance to Umzug constructor.\r\n\r\n```js\r\nclass CustomStorage {\r\n  constructor(...) {...}\r\n  logMigration(...) {...}\r\n  unlogMigration(...) {...}\r\n  executed(...) {...}\r\n}\r\n\r\nconst umzug = new Umzug({ storage: new CustomStorage(...), logger: console })\r\n```\r\n\r\nYour instance must adhere to the [UmzugStorage](./src/storage/contract.ts) interface. If you're using TypeScript you can ensure this at compile time, and get IDE type hints by importing it:\r\n\r\n```typescript\r\nimport { UmzugStorage } from 'umzug'\r\n\r\nclass CustomStorage implements UmzugStorage {\r\n  /* ... */\r\n}\r\n```\r\n\r\n### Events\r\n\r\nUmzug is an [emittery event emitter](https://www.npmjs.com/package/emittery). Each of the following events will be called with migration parameters as its payload (with `context`, `name`, and nullable `path` properties). Events are a convenient place to implement application-specific logic that must run around each migration:\r\n\r\n* `migrating` - A migration is about to be executed.\r\n* `migrated` - A migration has successfully been executed.\r\n* `reverting` - A migration is about to be reverted.\r\n* `reverted` - A migration has successfully been reverted.\r\n\r\nThese events run at the beginning and end of `up` and `down` calls. They'll receive an object containing a `context` property:\r\n\r\n- `beforeAll` - Before any of the migrations are run.\r\n- `afterAll` - After all the migrations have been executed. Note: this will always run, even if migrations throw an error.\r\n\r\nThe [`FileLocker` class](./src/file-locker.ts) uses `beforeAll` and `afterAll` to implement a simple filesystem-based locking mechanism.\r\n\r\nAll events are type-safe, so IDEs will prevent typos and supply strong types for the event payloads.\r\n\r\n### Errors\r\n\r\nWhen a migration throws an error, it will be wrapped in a `MigrationError` which captures the migration metadata (name, path etc.) as well as the original error message, and _will be rethrown_. In most cases, this is expected behaviour, and doesn't require any special handling beyond standard error logging setups.\r\n\r\nIf you expect failures and want to try to recover from them, you will need to try-catch the call to `umzug.up()`. You can access the original error from the `.cause` property if necessary:\r\n\r\n```js\r\ntry {\r\n  await umzug.up();\r\n} catch (e) {\r\n  if (e instanceof MigrationError) {\r\n    const original = e.cause;\r\n    // do something with the original error here\r\n  }\r\n  throw e;\r\n}\r\n```\r\n\r\nUnder the hood, [verror](https://npmjs.com/package/verror) is used to wrap errors.\r\n\r\n### CLI\r\n\r\n🚧🚧🚧 The CLI is new to Umzug v3 beta and is not yet stable. Feedback on it is welcome in [discussions](https://github.com/sequelize/umzug/discussions) 🚧🚧🚧\r\n\r\nUmzug instances provide a `.runAsCLI()` method. When called, this method will automatically cause your program to become a complete CLI, with help text and such:\r\n\r\n```js\r\n// migrator.js\r\nconst { Umzug } = require('umzug')\r\n\r\nexports.umzug = new Umzug({ ... })\r\n\r\nif (require.main === module) {\r\n  umzug.runAsCLI()\r\n}\r\n```\r\n\r\n#### CLI Usage\r\n\r\nA script like the one above is now a runnable CLI program. You can run `node migrator.js --help` to see how to use it. It will print something like:\r\n\r\n<!-- codegen:start {preset: custom, source: ./codegen.js, export: cliHelp} -->\r\n```\r\nusage: <script> [-h] <command> ...\r\n\r\nUmzug migrator\r\n\r\nPositional arguments:\r\n  <command>\r\n    up        Applies pending migrations\r\n    down      Revert migrations\r\n    pending   Lists pending migrations\r\n    executed  Lists executed migrations\r\n    create    Create a migration file\r\n\r\nOptional arguments:\r\n  -h, --help  Show this help message and exit.\r\n\r\nFor detailed help about a specific command, use: <script> <command> -h\r\n```\r\n<!-- codegen:end -->\r\n\r\n#### Running migrations\r\n\r\n`node migrator up` and `node migrator down` apply and revert migrations respectively. They're the equivalent of the `.up()` and `.down()` methods.\r\n\r\nUse `node migrator up --help` and `node migrator down --help` for options (running \"to\" a specific migration, passing migration names to be run explicitly, and specifying the rerun behavior):\r\n\r\nUp:\r\n<!-- codegen:start {preset: custom, source: ./codegen.js, export: cliHelp, action: up} -->\r\n```\r\nusage: <script> up [-h] [--to NAME] [--step COUNT] [--name MIGRATION]\r\n                   [--rerun {THROW,SKIP,ALLOW}]\r\n                   \r\n\r\nPerforms all migrations. See --help for more options\r\n\r\nOptional arguments:\r\n  -h, --help            Show this help message and exit.\r\n  --to NAME             All migrations up to and including this one should be \r\n                        applied.\r\n  --step COUNT          Run this many migrations. If not specified, all will \r\n                        be applied.\r\n  --name MIGRATION      Explicity declare migration name(s) to be applied.\r\n  --rerun {THROW,SKIP,ALLOW}\r\n                        Specify what action should be taken when a migration \r\n                        that has already been applied is passed to --name. \r\n                        The default value is \"THROW\".\r\n```\r\n<!-- codegen:end -->\r\n\r\nDown:\r\n<!-- codegen:start {preset: custom, source: ./codegen.js, export: cliHelp, action: down} -->\r\n```\r\nusage: <script> down [-h] [--to NAME] [--step COUNT] [--name MIGRATION]\r\n                     [--rerun {THROW,SKIP,ALLOW}]\r\n                     \r\n\r\nUndoes previously-applied migrations. By default, undoes the most recent \r\nmigration only. Use --help for more options. Useful in development to start \r\nfrom a clean slate. Use with care in production!\r\n\r\nOptional arguments:\r\n  -h, --help            Show this help message and exit.\r\n  --to NAME             All migrations up to and including this one should be \r\n                        reverted. Pass \"0\" to revert all.\r\n  --step COUNT          Run this many migrations. If not specified, one will \r\n                        be reverted.\r\n  --name MIGRATION      Explicity declare migration name(s) to be reverted.\r\n  --rerun {THROW,SKIP,ALLOW}\r\n                        Specify what action should be taken when a migration \r\n                        that has already been reverted is passed to --name. \r\n                        The default value is \"THROW\".\r\n```\r\n<!-- codegen:end -->\r\n\r\n\r\n#### Listing migrations\r\n\r\n```bash\r\nnode migrator pending # list migrations yet to be run\r\nnode migrator executed # list migrations that have already run\r\n\r\nnode migrator pending --json # list pending migrations including names and paths, in a json array format\r\nnode migrator executed --json # list executed migrations including names and paths, in a json array format\r\n\r\nnode migrator pending --help # show help/options\r\nnode migrator executed --help # show help/options\r\n```\r\n\r\n<!-- codegen:start {preset: custom, source: ./codegen.js, export: cliHelp, action: pending} -->\r\n```\r\nusage: <script> pending [-h] [--json]\r\n\r\nPrints migrations returned by `umzug.pending()`. By default, prints migration \r\nnames one per line.\r\n\r\nOptional arguments:\r\n  -h, --help  Show this help message and exit.\r\n  --json      Print pending migrations in a json format including names and \r\n              paths. This allows piping output to tools like jq. Without this \r\n              flag, the migration names will be printed one per line.\r\n```\r\n<!-- codegen:end -->\r\n\r\n<!-- codegen:start {preset: custom, source: ./codegen.js, export: cliHelp, action: executed} -->\r\n```\r\nusage: <script> executed [-h] [--json]\r\n\r\nPrints migrations returned by `umzug.executed()`. By default, prints \r\nmigration names one per line.\r\n\r\nOptional arguments:\r\n  -h, --help  Show this help message and exit.\r\n  --json      Print executed migrations in a json format including names and \r\n              paths. This allows piping output to tools like jq. Without this \r\n              flag, the migration names will be printed one per line.\r\n```\r\n<!-- codegen:end -->\r\n\r\n#### Creating migrations - CLI\r\n\r\nUsually, migrations correspond to files on the filesystem. The CLI exposes a way to create migration files easily:\r\n\r\n```bash\r\nnode migrator create --name my-migration.js\r\n```\r\n\r\nThis will create a file with a name like `2000.12.25T12.34.56.my-migration.js` in the same directory as the most recent migration file. If it's the very first migration file, you need to specify the folder explicitly:\r\n\r\n```bash\r\nnode migrator create --name my-migration.js --folder path/to/directory\r\n```\r\n\r\nThe timestamp prefix can be customized to be date-only or omitted, but be aware that it's strongly recommended to ensure your migrations are lexicographically sortable so it's easy for humans and tools to determine what order they should run in - so the default prefix is recommended.\r\n\r\nThis will generate a migration file called `<<timestamp>>.my-migration.js` with the default migration template for `.js` files that ships with Umzug.\r\n\r\nUmzug also ships with default templates for [`.ts`, `.cjs`, `.mjs` and `.sql` files](./src/templates.ts). Umzug will choose the template based on the extension you provide in `name`.\r\n\r\nYou can specify a custom template for your project when constructing an umzug instance via the `template` option. It should be a function which receives a filepath string, and returns an array of `[filepath, content]` pairs. Usually, just one pair is needed, but a second could be used to include a \"down\" migration in a separate file:\r\n\r\n```js\r\nconst umzug = new Umzug({\r\n  migrations: ...,\r\n  template: filepath => [\r\n    [filepath, fs.readFileSync('path/to/your/template/file').toString()],\r\n  ]\r\n})\r\n```\r\n\r\nThe create command includes some safety checks to make sure migrations aren't created with ambiguous ordering, and that they will be picked up by umzug when applying migrations.\r\n\r\nUse `node migrator create --help` for more options:\r\n\r\n<!-- codegen:start {preset: custom, source: ./codegen.js, export: cliHelp, action: create} -->\r\n```\r\nusage: <script> create [-h] --name NAME [--prefix {TIMESTAMP,DATE,NONE}]\r\n                       [--folder PATH] [--allow-extension EXTENSION]\r\n                       [--skip-verify] [--allow-confusing-ordering]\r\n                       \r\n\r\nGenerates a placeholder migration file using a timestamp as a prefix. By \r\ndefault, mimics the last existing migration, or guesses where to generate the \r\nfile if no migration exists yet.\r\n\r\nOptional arguments:\r\n  -h, --help            Show this help message and exit.\r\n  --name NAME           The name of the migration file. e.g. my-migration.js, \r\n                        my-migration.ts or my-migration.sql. Note - a prefix \r\n                        will be added to this name, usually based on a \r\n                        timestamp. See --prefix\r\n  --prefix {TIMESTAMP,DATE,NONE}\r\n                        The prefix format for generated files. TIMESTAMP uses \r\n                        a second-resolution timestamp, DATE uses a \r\n                        day-resolution timestamp, and NONE removes the prefix \r\n                        completely. The default value is \"TIMESTAMP\".\r\n  --folder PATH         Path on the filesystem where the file should be \r\n                        created. The new migration will be created as a \r\n                        sibling of the last existing one if this is omitted.\r\n  --allow-extension EXTENSION\r\n                        Allowable extension for created files. By default .js,\r\n                         .ts and .sql files can be created. To create txt \r\n                        file migrations, for example, you could use '--name \r\n                        my-migration.txt --allow-extension .txt' This \r\n                        parameter may alternatively be specified via the \r\n                        UMZUG_ALLOW_EXTENSION environment variable.\r\n  --skip-verify         By default, the generated file will be checked after \r\n                        creation to make sure it is detected as a pending \r\n                        migration. This catches problems like creation in the \r\n                        wrong folder, or invalid naming conventions. This \r\n                        flag bypasses that verification step.\r\n  --allow-confusing-ordering\r\n                        By default, an error will be thrown if you try to \r\n                        create a migration that will run before a migration \r\n                        that already exists. This catches errors which can \r\n                        cause problems if you change file naming conventions. \r\n                        If you use a custom ordering system, you can disable \r\n                        this behavior, but it's strongly recommended that you \r\n                        don't! If you're unsure, just ignore this option.\r\n```\r\n<!-- codegen:end -->\r\n\r\n### Creating migrations - API\r\n\r\nUmzug includes an optional helper for generating migration files. It's often most convenient to create files using the [CLI helper](#creating-migrations---cli), but the equivalent API also exists on an umzug instance:\r\n\r\n```js\r\nawait umzug.create({ name: 'my-new-migration.js' })\r\n```\r\n\r\n## License\r\n\r\nSee the [LICENSE file](./LICENSE)\r\n","readmeFilename":"README.md","gitHead":"01827b8a84c01014fb49565112be0942a1c66d6c","_id":"umzug@3.0.0-beta.11","_nodeVersion":"12.18.0","_npmVersion":"6.14.8","dist":{"integrity":"sha512-+rUoLmH+EVN0aaV3ZamnhIF8UlY6smuaf6TLczvmi0Z37FP/6qFYg2JYrEDQ+3W3DY89eiOMETL9H2yn5gLIcg==","shasum":"491754ef8d43f6ad373151ad468e77e2215ff825","tarball":"https://registry.npmjs.org/umzug/-/umzug-3.0.0-beta.11.tgz","fileCount":40,"unpackedSize":128517,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJf0og3CRA9TVsSAnZWagAA7u4QAJ1hbElFUSUWucH+gsB7\npwILlxo4A/xM7j5ZPD0X0IWhnZ0TJtfA4DGgHK1DkYms/Bs/0hPLvRxHKaoK\nhh7xjCoMNKsi9tZSpq3lwO48f7Fwu98KXWk34RJ6L0cMbE0EiSQen3liOwmC\nYSMRMRcozkgPrkpS01bLxMVmsdqwKiqBMkWKlvaQeNZSuTAHnVS4womqigGl\numgmS8b1nYnLQLi9A3O3cg68WmmVLUf5KKv/Hq4iiyAcqfYH8gWRKD3Sy8K+\nXOtAo8a5FZHHCp3Y5br+2qNK2VrN+0ZQcOTQB+Zl5o8xfjiDLbMc29muaSP3\ncqP49TtKFGT6fy5r7/AWHzlCXVJt0L6V1tVDIl0TO+4Ucki1PJ245hp/Ahez\naaUHMmHPYXOFwdQLxTMRmNCV5EoYB900oOB5x50KYsevG6P56hJNiLKTdvOF\nBz5KSb+mzN5dzXXuH12SyfZMzyQ2xexp8lmXUP8WyiOa5LBU1NvOZ0LlluCg\n6uTQOVSKuExGDng3Dzj6WdRaqwi4TUe1U4SMFAkEqo8YfXr6v7yU5SUAu1C8\n2w0ZnSF5sCLEYd4D9s1UAkKnWp4sOAJ3oA2sRYfRK99YvIRNiLuMZL2i0GNF\n+Iym2dKvwx0+wgAdOwRMrf6BYJamAKvXfSN1jDM0f6pHMiKyuG2YL+lmzZmi\nM6Tg\r\n=BMZK\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEQCIEKsOKYRazRTn4d8pQ7JnwbtrA2o3GmbvlgpT3gJxHEyAiB1SFLz1yTkUTydUBAc+0/xF2OV34trHBZfXXhcnrL27w=="}]},"_npmUser":{"name":"mmkale","email":"mmkal1@outlook.com"},"directories":{},"maintainers":[{"name":"pascal.pflaum","email":"mail@pascalpflaum.de"},{"name":"sdepold","email":"sascha@depold.com"},{"name":"sushantdhiman","email":"sushantdhiman@outlook.com"},{"name":"papb","email":"papb1996@gmail.com"},{"name":"mmkale","email":"mmkal1@outlook.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/umzug_3.0.0-beta.11_1607632950882_0.5827074747629752"},"_hasShrinkwrap":false},"3.0.0-beta.12":{"name":"umzug","version":"3.0.0-beta.12","description":"Framework-agnostic migration tool for Node","keywords":["migrate","migration","migrations","sequelize","database"],"main":"lib/index.js","dependencies":{"@rushstack/ts-command-line":"~4.7.7","@types/verror":"^1.10.4","emittery":"~0.7.2","fs-jetpack":"~4.0.0","glob":"~7.1.6","type-fest":"~0.19.0","verror":"^1.10.0"},"devDependencies":{"@types/jest":"26.0.16","@types/lodash":"4.14.165","@types/uuid":"8.3.0","@typescript-eslint/eslint-plugin":"4.9.0","@typescript-eslint/parser":"4.9.0","del-cli":"3.0.1","eslint":"7.15.0","eslint-config-xo":"0.33.1","eslint-config-xo-typescript":"0.36.0","eslint-plugin-codegen":"0.14.3","eslint-plugin-import":"2.22.1","eslint-plugin-jest":"24.1.3","eslint-plugin-mocha":"8.0.0","eslint-plugin-prettier":"3.2.0","eslint-plugin-unicorn":"23.0.0","expect-type":"0.10.0","fs-syncer":"0.3.3","jest":"26.6.3","lodash":"4.17.20","np":"7.0.0","prettier":"2.2.1","sequelize":"5.22.3","sinon":"9.2.1","source-map-support":"0.5.19","sqlite3":"5.0.0","strip-ansi":"6.0.0","ts-jest":"26.4.4","ts-node":"9.0.0","typescript":"4.1.2","uuid":"8.3.1"},"scripts":{"build":"del-cli lib && tsc","lint":"eslint --ext .js,.ts,.md . --max-warnings 0","prepare":"npm run build","release":"np --no-yarn --no-2fa","pretest":"del-cli test/generated","test":"jest"},"repository":{"type":"git","url":"git+https://github.com/sequelize/umzug.git"},"author":{"name":"Sascha Depold","email":"sascha@depold.com"},"contributors":[{"name":"Jukka Hyytiälä","email":"hyytiala.jukka@gmail.com"},{"name":"Pascal Pflaum","email":"mail@pascalpflaum.de"},{"name":"Pedro Augusto de Paula Barbosa","email":"papb1996@gmail.com"}],"license":"MIT","bugs":{"url":"https://github.com/sequelize/umzug/issues"},"homepage":"https://github.com/sequelize/umzug","engines":{"node":">=10.0.0"},"jest":{"preset":"ts-jest","globals":{"ts-jest":{"diagnostics":false}},"testEnvironment":"node","testMatch":["**/*test.ts"],"collectCoverageFrom":["src/**"]},"readme":"# Umzug\r\n\r\n[![Build Status](https://badgen.net/github/checks/sequelize/umzug/master)](https://github.com/sequelize/umzug/actions?query=workflow%3ACI)\r\n[![npm (stable)](https://badgen.net/npm/v/umzug)](https://www.npmjs.com/package/umzug)\r\n[![npm (beta)](https://badgen.net/npm/v/umzug/beta)](https://www.npmjs.com/package/umzug/v/beta)\r\n[![npm (downloads)](https://badgen.net/npm/dm/umzug)](https://npmjs.com/package/umzug)\r\n\r\nUmzug is a framework-agnostic migration tool for Node. It provides a clean API for running and rolling back tasks.\r\n\r\n_Note: master represents the next major version of umzug - v3 - which is currently in beta. For the stable version, please refer to the [v2.x branch](https://github.com/sequelize/umzug/tree/v2.x)._\r\n\r\nTo install the v3-beta package:\r\n\r\n```\r\nnpm install umzug@beta\r\n```\r\n\r\nTo install the stable package (v2.x):\r\n\r\n```\r\nnpm install umzug\r\n```\r\n\r\n## Highlights\r\n\r\n* Written in TypeScript\r\n\t* Built-in typings\r\n\t* Auto-completion right in your IDE\r\n\t* Documentation right in your IDE\r\n* Programmatic API for migrations\r\n* Built-in [CLI](#cli)\r\n* Database agnostic\r\n* Supports logging of migration process\r\n* Supports multiple storages for migration data\r\n* [Usage examples](./examples)\r\n\r\n## Documentation\r\n\r\n### Minimal Example\r\n\r\nThe following example uses a Sqlite database through sequelize and persists the migration data in the database itself through the sequelize storage. There are several more involved examples covering a few different scenarios in the [examples folder](./examples).\r\n\r\n```js\r\n// index.js\r\nconst { Sequelize } = require('sequelize');\r\nconst { Umzug, SequelizeStorage } = require('umzug');\r\n\r\nconst sequelize = new Sequelize({ dialect: 'sqlite', storage: './db.sqlite' });\r\n\r\nconst umzug = new Umzug({\r\n  migrations: { glob: 'migrations/*.js' },\r\n  context: sequelize.getQueryInterface(),\r\n  storage: new SequelizeStorage({ sequelize }),\r\n  logger: console,\r\n});\r\n\r\n(async () => {\r\n  // Checks migrations and run them if they are not already applied. To keep\r\n  // track of the executed migrations, a table (and sequelize model) called SequelizeMeta\r\n  // will be automatically created (if it doesn't exist already) and parsed.\r\n  await umzug.up();\r\n})();\r\n```\r\n\r\n```js\r\n// migrations/00_initial.js\r\n\r\nconst { Sequelize } = require('sequelize');\r\n\r\nasync function up({ context: queryInterface }) {\r\n\tawait queryInterface.createTable('users', {\r\n\t\tid: {\r\n\t\t\ttype: Sequelize.INTEGER,\r\n\t\t\tallowNull: false,\r\n\t\t\tprimaryKey: true\r\n\t\t},\r\n\t\tname: {\r\n\t\t\ttype: Sequelize.STRING,\r\n\t\t\tallowNull: false\r\n\t\t},\r\n\t\tcreatedAt: {\r\n\t\t\ttype: Sequelize.DATE,\r\n\t\t\tallowNull: false\r\n\t\t},\r\n\t\tupdatedAt: {\r\n\t\t\ttype: Sequelize.DATE,\r\n\t\t\tallowNull: false\r\n\t\t}\r\n\t});\r\n}\r\n\r\nasync function down({ context: queryInterface }) {\r\n\tawait queryInterface.dropTable('users');\r\n}\r\n\r\nmodule.exports = { up, down };\r\n```\r\n\r\nNote that we renamed the `context` argument to `queryInterface` for clarity. The `context` is whatever we specified when creating the Umzug instance in `index.js`.\r\n\r\n<details>\r\n<summary>You can also write your migrations in typescript by using `ts-node` in the entrypoint:</summary>\r\n\r\n```typescript\r\n// index.ts\r\nrequire('ts-node/register')\r\n\r\nimport { Sequelize } from 'sequelize';\r\nimport { Umzug, SequelizeStorage } from 'umzug';\r\n\r\nconst sequelize = new Sequelize({ dialect: 'sqlite', storage: './db.sqlite' });\r\n\r\nconst umzug = new Umzug({\r\n  migrations: { glob: 'migrations/*.ts' },\r\n  context: sequelize.getQueryInterface(),\r\n  storage: new SequelizeStorage({ sequelize }),\r\n  logger: console,\r\n});\r\n\r\n// export the type helper exposed by umzug, which will have the `context` argument typed correctly\r\nexport type Migration = typeof umzug._types.migration;\r\n\r\n(async () => {\r\n  await umzug.up();\r\n})();\r\n```\r\n\r\n```typescript\r\n// migrations/00_initial.ts\r\nimport type { Migration } from '..';\r\n\r\n// types will now be available for `queryInterface`\r\nexport const up: Migration = ({ context: queryInterface }) => queryInterface.createTable(...)\r\nexport const down: Migration = ({ context: queryInterface }) => queryInterface.dropTable(...)\r\n```\r\n</details>\r\n\r\nSee [these tests](./test/umzug.test.ts) for more examples of Umzug usage, including:\r\n\r\n- passing `ignore` and `cwd` parameters to the glob instructions\r\n- customising migrations ordering\r\n- finding migrations from multiple different directories\r\n- using non-js file extensions via a custom resolver, e.g. `.sql`\r\n\r\n### Usage\r\n\r\n#### Installation\r\n\r\nThe beta version of Umzug is available on npm by specifying the correct tag:\r\n\r\n```bash\r\nnpm install umzug@beta\r\n```\r\n\r\n#### Umzug instance\r\n\r\nIt is possible to configure an Umzug instance by passing an object to the constructor.\r\n\r\n```js\r\nconst { Umzug } = require('umzug');\r\nconst umzug = new Umzug({ /* ... options ... */ });\r\n```\r\n\r\nDetailed documentation for these options are in the `UmzugOptions` TypeScript interface, which can be found in [src/types.ts](./src/types.ts).\r\n\r\n#### Getting all pending migrations\r\n\r\nYou can get a list of pending (i.e. not yet executed) migrations with the `pending()` method:\r\n\r\n```js\r\nconst migrations = await umzug.pending();\r\n// returns an array of all pending migrations.\r\n```\r\n\r\n#### Getting all executed migrations\r\n\r\nYou can get a list of already executed migrations with the `executed()` method:\r\n\r\n```js\r\nconst migrations = await umzug.executed();\r\n// returns an array of all already executed migrations\r\n```\r\n\r\n#### Executing pending migrations\r\n\r\nThe `up` method can be used to execute all pending migrations.\r\n\r\n```js\r\nconst migrations = await umzug.up();\r\n// returns an array of all executed migrations\r\n```\r\n\r\nIt is also possible to pass the name of a migration in order to just run the migrations from the current state to the passed migration name (inclusive).\r\n\r\n```js\r\nawait umzug.up({ to: '20141101203500-task' });\r\n```\r\n\r\nTo limit the number of migrations that are run, `step` can be used:\r\n\r\n```js\r\n// This will run the next two migrations\r\nawait umzug.up({ step: 2 })\r\n```\r\n\r\nRunning specific migrations while ignoring the right order, can be done like this:\r\n\r\n```js\r\nawait umzug.up({ migrations: ['20141101203500-task', '20141101203501-task-2'] });\r\n```\r\n\r\n#### Reverting executed migration\r\n\r\nThe `down` method can be used to revert the last executed migration.\r\n\r\n```js\r\nconst migration = await umzug.down();\r\n// reverts the last migration and returns it.\r\n```\r\n\r\nTo revert more than one migration, you can use `step`:\r\n\r\n```js\r\n// This will revert the last two migrations\r\nawait umzug.down({ step: 2 });\r\n```\r\n\r\nIt is possible to pass the name of a migration until which (inclusive) the migrations should be reverted. This allows the reverting of multiple migrations at once.\r\n\r\n```js\r\nconst migrations = await umzug.down({ to: '20141031080000-task' });\r\n// returns an array of all reverted migrations.\r\n```\r\n\r\nTo revert all migrations, you can pass 0 as the `to` parameter:\r\n\r\n```js\r\nawait umzug.down({ to: 0 });\r\n```\r\n\r\nReverting specific migrations while ignoring the right order, can be done like this:\r\n\r\n```js\r\nawait umzug.down({ migrations: ['20141101203500-task', '20141101203501-task-2'] });\r\n```\r\n\r\n### Migrations\r\n\r\nThere are two ways to specify migrations: via files or directly via an array of migrations.\r\n\r\n#### Migration files\r\n\r\nA migration file ideally exposes an `up` and a `down` async functions. They will perform the task of upgrading or downgrading the database.\r\n\r\n```js\r\nmodule.exports = {\r\n  async up() {\r\n    /* ... */\r\n  },\r\n  async down() {\r\n    /* ... */\r\n  }\r\n};\r\n```\r\n\r\nMigration files can be located anywhere - they will typically be loaded according to a glob pattern provided to the `Umzug` constructor.\r\n\r\n#### Direct migrations list\r\n\r\nYou can also specify directly a list of migrations to the `Umzug` constructor:\r\n\r\n```js\r\nconst { Umzug } = require('umzug');\r\n\r\nconst umzug = new Umzug({\r\n  migrations: [\r\n    {\r\n      // the name of the migration is mandatory\r\n      name: '00-first-migration',\r\n      async up({ context }) { /* ... */ },\r\n      async down({ context }) { /* ... */ }\r\n    },\r\n    {\r\n      name: '01-foo-bar-migration',\r\n      async up({ context }) { /* ... */ },\r\n      async down({ context }) { /* ... */ }\r\n    }\r\n  ],\r\n  context: sequelize.getQueryInterface(),\r\n  logger: console,\r\n});\r\n```\r\n\r\nTo load migrations in another format, you can use the `resolve` function:\r\n\r\n```js\r\nconst { Umzug } = require('umzug')\r\nconst { Sequelize } = require('sequelize')\r\nconst fs = require('fs')\r\n\r\nconst umzug = new Umzug({\r\n  migrations: {\r\n    glob: 'migrations/*.up.sql',\r\n    resolve: ({ name, path, context: sequelize }) => ({\r\n      name,\r\n      up: async () => {\r\n        const sql = fs.readFileSync(path).toString()\r\n        return sequelize.query(sql)\r\n      },\r\n      down: async () => {\r\n        // Get the corresponding `.down.sql` file to undo this migration\r\n        const sql = fs.readFileSync(path.replace('.up.sql', '.down.sql')).toString()\r\n        return sequelize.query(sql)\r\n      }\r\n    })\r\n  },\r\n  context: new Sequelize(...),\r\n  logger: console,\r\n});\r\n```\r\n\r\nYou can support mixed migration file types, and use umzug's default resolver for javascript/typescript:\r\n\r\n```js\r\nconst { Umzug } = require('umzug')\r\nconst { Sequelize } = require('sequelize')\r\nconst fs = require('fs')\r\n\r\nconst umzug = new Umzug({\r\n  migrations: {\r\n    glob: 'migrations/*.{js,ts,up.sql}',\r\n    resolve: (params) => {\r\n      if (!params.path.endsWith('.sql')) {\r\n        return Umzug.defaultResolver(params)\r\n      }\r\n      const { context: sequelize } = params\r\n      return {\r\n        name: params.name,\r\n        up: async () => {\r\n          const sql = fs.readFileSync(params.path).toString()\r\n          return sequelize.query(sql)\r\n        },\r\n        down: async () => {\r\n          // Get the corresponding `.down.sql` file to undo this migration\r\n          const sql = fs.readFileSync(params.path.replace('.up.sql', '.down.sql')).toString()\r\n          return sequelize.query(sql)\r\n        }\r\n      }\r\n    },\r\n  },\r\n  logger: console,\r\n  context: new Sequelize(...),\r\n});\r\n```\r\n\r\nThe glob syntax allows loading migrations from multiple locations:\r\n\r\n```js\r\nconst { Umzug } = require('umzug')\r\nconst { Sequelize } = require('sequelize')\r\n\r\nconst umzug = new Umzug({\r\n  migrations: {\r\n    glob: '{first-folder/*.js,second-folder-with-different-naming-convention/*.js}',\r\n  },\r\n  context: new Sequelize(...),\r\n  logger: console,\r\n});\r\n```\r\n\r\nNote on migration file sorting:\r\n\r\n- file matches, found using [glob](https://npmjs.com/package/glob), will be lexicographically sorted based on their paths\r\n  - so if your migrations are `one/m1.js`, `two/m2.js`, `three/m3.js`, the resultant order will be `one/m1.js`, `three/m3.js`, `two/m2.js`\r\n  - similarly, if your migrations are called `m1.js`, `m2.js`, ... `m10.js`, `m11.js`, the resultant ordering will be `m1.js`, `m10.js`, `m11.js`, ... `m2.js`\r\n- The easiest way to deal with this is to ensure your migrations appear in a single folder, and their paths match lexicographically with the order they should run in\r\n- If this isn't possible, the ordering can be customised using `.extend(...)` (see below)\r\n\r\n### Upgrading from v2.x\r\n\r\nThe Umzug class should be imported as a named import, i.e. `import { Umzug } from 'umzug'`.\r\n\r\nThe `MigrationMeta` type, which is returned by `umzug.executed()` and `umzug.pending()`, no longer has a `file` property - it has a `name` and *optional* `path` - since migrations are not necessarily bound to files on the file system.\r\n\r\nThe `migrations.glob` parameter replaces `path`, `pattern` and `traverseDirectories`. It can be used, in combination with `cwd` and `ignore` to do much more flexible file lookups. See https://npmjs.com/package/glob for more information on the syntax.\r\n\r\nThe `migrations.resolve` parameter replaces `customResolver`. Explicit support for `wrap` and `nameFormatter` has been removed - these can be easily implemented in a `resolve` function.\r\n\r\nThe constructor option `logging` is replaced by `logger` to allow for `warn` and `error` messages in future. NodeJS's global `console` object can be passed to this. To disable logging, replace `logging: false` with `logger: undefined`.\r\n\r\nEvents have moved from the default nodejs `EventEmitter` to [emittery](https://www.npmjs.com/package/emittery). It has better design for async code, a less bloated API surface and strong types. But, it doesn't allow passing multiple arguments to callbacks, so listeners have to change slightly, as well as `.addListener(...)` and `.removeListener(...)` no longer being supported (`.on(...)` and `.off(...)` should now be used):\r\n\r\nBefore:\r\n\r\n```js\r\numzug.on('migrating', (name, m) => console.log({ name, path: m.path }))\r\n```\r\n\r\nAfter:\r\n\r\n```js\r\numzug.on('migrating', ev => console.log({ name: ev.name, path: ev.path }))\r\n```\r\n\r\nThe `Umzug#execute` method is removed. Use `Umzug#up` or `Umzug#down`.\r\n\r\nThe options for `Umguz#up` and `Umzug#down` have changed:\r\n- `umzug.up({ to: 'some-name' })` and `umzug.down({ to: 'some-name' })` are still valid.\r\n- `umzug.up({ from: '...' })` and `umzug.down({ from: '...' })` are no longer supported. To run migrations out-of-order (which is not generally recommended), you can explicitly use `umzug.up({ migrations: ['...'] })` and `umzug.down({ migrations: ['...'] })`.\r\n- name matches must be exact. `umzug.up({ to: 'some-n' })` will no longer match a migration called `some-name`.\r\n- `umzug.down({ to: 0 })` is still valid but `umzug.up({ to: 0 })` is not.\r\n- `umzug.up({ migrations: ['m1', 'm2'] })` is still valid but the shorthand `umzug.up(['m1', 'm2'])` has been removed.\r\n- `umzug.down({ migrations: ['m1', 'm2'] })` is still valid but the shorthand `umzug.down(['m1', 'm2'])` has been removed.\r\n- `umzug.up({ migrations: ['m1', 'already-run'] })` will throw an error, if `already-run` is not found in the list of pending migrations.\r\n- `umzug.down({ migrations: ['m1', 'has-not-been-run'] })` will throw an error, if `has-not-been-run` is not found in the list of executed migrations.\r\n- `umzug.up({ migrations: ['m1', 'm2'], rerun: 'ALLOW' })` will re-apply migrations `m1` and `m2` even if they've already been run.\r\n- `umzug.up({ migrations: ['m1', 'm2'], rerun: 'SKIP' })` will skip migrations `m1` and `m2` if they've already been run.\r\n- `umzug.down({ migrations: ['m1', 'm2'], rerun: 'ALLOW' })` will \"revert\" migrations `m1` and `m2` even if they've never been run.\r\n- `umzug.down({ migrations: ['m1', 'm2'], rerun: 'SKIP' })` will skip reverting migrations `m1` and `m2` if they haven't been run or are already reverted.\r\n- `umzug.up({ migrations: ['m1', 'does-not-exist', 'm2'] })` will throw an error if the migration name is not found. Note that the error will be thrown and no migrations run unless _all_ migration names are found - whether or not `rerun: 'ALLOW'` is added.\r\n\r\nThe `context` parameter replaces `params`, and is passed in as a property to migration functions as an options object, alongs side `name` and `path`. This means the signature for migrations, which in v2 was `(context) => Promise<void>`, has changed slightly in v3, to `({ name, path, context }) => Promise<void>`. The `resolve` function can also be used to upgrade your umzug version to v3 when you have existing v2-compatible migrations:\r\n\r\n```js\r\nconst { Umzug } = require('umzug');\r\n\r\nconst umzug = new Umzug({\r\n  migrations: {\r\n    glob: 'migrations/umzug-v2-format/*.js',\r\n    resolve: ({name, path, context}) => {\r\n      // Adjust the migration from the new signature to the v2 signature, making easier to upgrade to v3\r\n      const migration = require(path)\r\n      return { name, up: async () => migration.up(context), down: async () => migration.down(context) }\r\n    }\r\n  },\r\n  context: sequelize.getQueryInterface(),\r\n  logger: console,\r\n});\r\n```\r\n\r\nSimilarly, you no longer need `migrationSorting`, you can use `Umzug#extend` to manipulate migration lists directly:\r\n\r\n```js\r\nconst { Umzug } = require('umzug');\r\n\r\nconst umzug =\r\n  new Umzug({\r\n    migrations: { glob: 'migrations/**/*.js' },\r\n    context: sequelize.getQueryInterface(),\r\n  })\r\n  .extend(migrations => migrations.sort((a, b) => b.path.localeCompare(a.path)));\r\n```\r\n\r\n### Storages\r\n\r\nStorages define where the migration data is stored.\r\n\r\n#### JSON Storage\r\n\r\nUsing `JSONStorage` will create a JSON file which will contain an array with all the executed migrations. You can specify the path to the file. The default for that is `umzug.json` in the working directory of the process.\r\n\r\nDetailed documentation for the options it can take are in the `JSONStorageConstructorOptions` TypeScript interface, which can be found in [src/storage/json.ts](./src/storage/json.ts).\r\n\r\n#### Memory Storage\r\n\r\nUsing `memoryStorage` will store migrations with an in-memory array. This can be useful for proof-of-concepts or tests, since it doesn't interact with databases or filesystems.\r\n\r\nIt doesn't take any options, just import the `memoryStorage` function and call it to return a storage instance:\r\n\r\n```typescript\r\nimport { Umzug, memoryStorage } from 'umzug'\r\n\r\nconst umzug = new Umzug({\r\n  migrations: ...,\r\n  storage: memoryStorage(),\r\n  logger: console,\r\n})\r\n```\r\n\r\n#### Sequelize Storage\r\n\r\nUsing `SequelizeStorage` will create a table in your SQL database called `SequelizeMeta` containing an entry for each executed migration. You will have to pass a configured instance of Sequelize or an existing Sequelize model. Optionally you can specify the model name, table name, or column name. All major Sequelize versions are supported.\r\n\r\nDetailed documentation for the options it can take are in the `_SequelizeStorageConstructorOptions` TypeScript interface, which can be found in [src/storage/sequelize.ts](./src/storage/sequelize.ts).\r\n\r\n#### MongoDB Storage\r\n\r\nUsing `MongoDBStorage` will create a collection in your MongoDB database called `migrations` containing an entry for each executed migration. You will have either to pass a MongoDB Driver Collection as `collection` property. Alternatively you can pass a established MongoDB Driver connection and a collection name.\r\n\r\nDetailed documentation for the options it can take are in the `MongoDBStorageConstructorOptions` TypeScript interface, which can be found in [src/storage/mongodb.ts](./src/storage/mongodb.ts).\r\n\r\n#### Custom\r\n\r\nIn order to use a custom storage, you can pass your storage instance to Umzug constructor.\r\n\r\n```js\r\nclass CustomStorage {\r\n  constructor(...) {...}\r\n  logMigration(...) {...}\r\n  unlogMigration(...) {...}\r\n  executed(...) {...}\r\n}\r\n\r\nconst umzug = new Umzug({ storage: new CustomStorage(...), logger: console })\r\n```\r\n\r\nYour instance must adhere to the [UmzugStorage](./src/storage/contract.ts) interface. If you're using TypeScript you can ensure this at compile time, and get IDE type hints by importing it:\r\n\r\n```typescript\r\nimport { UmzugStorage } from 'umzug'\r\n\r\nclass CustomStorage implements UmzugStorage {\r\n  /* ... */\r\n}\r\n```\r\n\r\n### Events\r\n\r\nUmzug is an [emittery event emitter](https://www.npmjs.com/package/emittery). Each of the following events will be called with migration parameters as its payload (with `context`, `name`, and nullable `path` properties). Events are a convenient place to implement application-specific logic that must run around each migration:\r\n\r\n* `migrating` - A migration is about to be executed.\r\n* `migrated` - A migration has successfully been executed.\r\n* `reverting` - A migration is about to be reverted.\r\n* `reverted` - A migration has successfully been reverted.\r\n\r\nThese events run at the beginning and end of `up` and `down` calls. They'll receive an object containing a `context` property:\r\n\r\n- `beforeAll` - Before any of the migrations are run.\r\n- `afterAll` - After all the migrations have been executed. Note: this will always run, even if migrations throw an error.\r\n\r\nThe [`FileLocker` class](./src/file-locker.ts) uses `beforeAll` and `afterAll` to implement a simple filesystem-based locking mechanism.\r\n\r\nAll events are type-safe, so IDEs will prevent typos and supply strong types for the event payloads.\r\n\r\n### Errors\r\n\r\nWhen a migration throws an error, it will be wrapped in a `MigrationError` which captures the migration metadata (name, path etc.) as well as the original error message, and _will be rethrown_. In most cases, this is expected behaviour, and doesn't require any special handling beyond standard error logging setups.\r\n\r\nIf you expect failures and want to try to recover from them, you will need to try-catch the call to `umzug.up()`. You can access the original error from the `.cause` property if necessary:\r\n\r\n```js\r\ntry {\r\n  await umzug.up();\r\n} catch (e) {\r\n  if (e instanceof MigrationError) {\r\n    const original = e.cause;\r\n    // do something with the original error here\r\n  }\r\n  throw e;\r\n}\r\n```\r\n\r\nUnder the hood, [verror](https://npmjs.com/package/verror) is used to wrap errors.\r\n\r\n### CLI\r\n\r\n🚧🚧🚧 The CLI is new to Umzug v3 beta and is not yet stable. Feedback on it is welcome in [discussions](https://github.com/sequelize/umzug/discussions) 🚧🚧🚧\r\n\r\nUmzug instances provide a `.runAsCLI()` method. When called, this method will automatically cause your program to become a complete CLI, with help text and such:\r\n\r\n```js\r\n// migrator.js\r\nconst { Umzug } = require('umzug')\r\n\r\nexports.umzug = new Umzug({ ... })\r\n\r\nif (require.main === module) {\r\n  umzug.runAsCLI()\r\n}\r\n```\r\n\r\n#### CLI Usage\r\n\r\nA script like the one above is now a runnable CLI program. You can run `node migrator.js --help` to see how to use it. It will print something like:\r\n\r\n<!-- codegen:start {preset: custom, source: ./codegen.js, export: cliHelp} -->\r\n```\r\nusage: <script> [-h] <command> ...\r\n\r\nUmzug migrator\r\n\r\nPositional arguments:\r\n  <command>\r\n    up        Applies pending migrations\r\n    down      Revert migrations\r\n    pending   Lists pending migrations\r\n    executed  Lists executed migrations\r\n    create    Create a migration file\r\n\r\nOptional arguments:\r\n  -h, --help  Show this help message and exit.\r\n\r\nFor detailed help about a specific command, use: <script> <command> -h\r\n```\r\n<!-- codegen:end -->\r\n\r\n#### Running migrations\r\n\r\n`node migrator up` and `node migrator down` apply and revert migrations respectively. They're the equivalent of the `.up()` and `.down()` methods.\r\n\r\nUse `node migrator up --help` and `node migrator down --help` for options (running \"to\" a specific migration, passing migration names to be run explicitly, and specifying the rerun behavior):\r\n\r\nUp:\r\n<!-- codegen:start {preset: custom, source: ./codegen.js, export: cliHelp, action: up} -->\r\n```\r\nusage: <script> up [-h] [--to NAME] [--step COUNT] [--name MIGRATION]\r\n                   [--rerun {THROW,SKIP,ALLOW}]\r\n                   \r\n\r\nPerforms all migrations. See --help for more options\r\n\r\nOptional arguments:\r\n  -h, --help            Show this help message and exit.\r\n  --to NAME             All migrations up to and including this one should be \r\n                        applied.\r\n  --step COUNT          Run this many migrations. If not specified, all will \r\n                        be applied.\r\n  --name MIGRATION      Explicity declare migration name(s) to be applied.\r\n  --rerun {THROW,SKIP,ALLOW}\r\n                        Specify what action should be taken when a migration \r\n                        that has already been applied is passed to --name. \r\n                        The default value is \"THROW\".\r\n```\r\n<!-- codegen:end -->\r\n\r\nDown:\r\n<!-- codegen:start {preset: custom, source: ./codegen.js, export: cliHelp, action: down} -->\r\n```\r\nusage: <script> down [-h] [--to NAME] [--step COUNT] [--name MIGRATION]\r\n                     [--rerun {THROW,SKIP,ALLOW}]\r\n                     \r\n\r\nUndoes previously-applied migrations. By default, undoes the most recent \r\nmigration only. Use --help for more options. Useful in development to start \r\nfrom a clean slate. Use with care in production!\r\n\r\nOptional arguments:\r\n  -h, --help            Show this help message and exit.\r\n  --to NAME             All migrations up to and including this one should be \r\n                        reverted. Pass \"0\" to revert all.\r\n  --step COUNT          Run this many migrations. If not specified, one will \r\n                        be reverted.\r\n  --name MIGRATION      Explicity declare migration name(s) to be reverted.\r\n  --rerun {THROW,SKIP,ALLOW}\r\n                        Specify what action should be taken when a migration \r\n                        that has already been reverted is passed to --name. \r\n                        The default value is \"THROW\".\r\n```\r\n<!-- codegen:end -->\r\n\r\n\r\n#### Listing migrations\r\n\r\n```bash\r\nnode migrator pending # list migrations yet to be run\r\nnode migrator executed # list migrations that have already run\r\n\r\nnode migrator pending --json # list pending migrations including names and paths, in a json array format\r\nnode migrator executed --json # list executed migrations including names and paths, in a json array format\r\n\r\nnode migrator pending --help # show help/options\r\nnode migrator executed --help # show help/options\r\n```\r\n\r\n<!-- codegen:start {preset: custom, source: ./codegen.js, export: cliHelp, action: pending} -->\r\n```\r\nusage: <script> pending [-h] [--json]\r\n\r\nPrints migrations returned by `umzug.pending()`. By default, prints migration \r\nnames one per line.\r\n\r\nOptional arguments:\r\n  -h, --help  Show this help message and exit.\r\n  --json      Print pending migrations in a json format including names and \r\n              paths. This allows piping output to tools like jq. Without this \r\n              flag, the migration names will be printed one per line.\r\n```\r\n<!-- codegen:end -->\r\n\r\n<!-- codegen:start {preset: custom, source: ./codegen.js, export: cliHelp, action: executed} -->\r\n```\r\nusage: <script> executed [-h] [--json]\r\n\r\nPrints migrations returned by `umzug.executed()`. By default, prints \r\nmigration names one per line.\r\n\r\nOptional arguments:\r\n  -h, --help  Show this help message and exit.\r\n  --json      Print executed migrations in a json format including names and \r\n              paths. This allows piping output to tools like jq. Without this \r\n              flag, the migration names will be printed one per line.\r\n```\r\n<!-- codegen:end -->\r\n\r\n#### Creating migrations - CLI\r\n\r\nUsually, migrations correspond to files on the filesystem. The CLI exposes a way to create migration files easily:\r\n\r\n```bash\r\nnode migrator create --name my-migration.js\r\n```\r\n\r\nThis will create a file with a name like `2000.12.25T12.34.56.my-migration.js` in the same directory as the most recent migration file. If it's the very first migration file, you need to specify the folder explicitly:\r\n\r\n```bash\r\nnode migrator create --name my-migration.js --folder path/to/directory\r\n```\r\n\r\nThe timestamp prefix can be customized to be date-only or omitted, but be aware that it's strongly recommended to ensure your migrations are lexicographically sortable so it's easy for humans and tools to determine what order they should run in - so the default prefix is recommended.\r\n\r\nThis will generate a migration file called `<<timestamp>>.my-migration.js` with the default migration template for `.js` files that ships with Umzug.\r\n\r\nUmzug also ships with default templates for [`.ts`, `.cjs`, `.mjs` and `.sql` files](./src/templates.ts). Umzug will choose the template based on the extension you provide in `name`.\r\n\r\nYou can specify a custom template for your project when constructing an umzug instance via the `template` option. It should be a function which receives a filepath string, and returns an array of `[filepath, content]` pairs. Usually, just one pair is needed, but a second could be used to include a \"down\" migration in a separate file:\r\n\r\n```js\r\nconst umzug = new Umzug({\r\n  migrations: ...,\r\n  template: filepath => [\r\n    [filepath, fs.readFileSync('path/to/your/template/file').toString()],\r\n  ]\r\n})\r\n```\r\n\r\nThe create command includes some safety checks to make sure migrations aren't created with ambiguous ordering, and that they will be picked up by umzug when applying migrations.\r\n\r\nUse `node migrator create --help` for more options:\r\n\r\n<!-- codegen:start {preset: custom, source: ./codegen.js, export: cliHelp, action: create} -->\r\n```\r\nusage: <script> create [-h] --name NAME [--prefix {TIMESTAMP,DATE,NONE}]\r\n                       [--folder PATH] [--allow-extension EXTENSION]\r\n                       [--skip-verify] [--allow-confusing-ordering]\r\n                       \r\n\r\nGenerates a placeholder migration file using a timestamp as a prefix. By \r\ndefault, mimics the last existing migration, or guesses where to generate the \r\nfile if no migration exists yet.\r\n\r\nOptional arguments:\r\n  -h, --help            Show this help message and exit.\r\n  --name NAME           The name of the migration file. e.g. my-migration.js, \r\n                        my-migration.ts or my-migration.sql. Note - a prefix \r\n                        will be added to this name, usually based on a \r\n                        timestamp. See --prefix\r\n  --prefix {TIMESTAMP,DATE,NONE}\r\n                        The prefix format for generated files. TIMESTAMP uses \r\n                        a second-resolution timestamp, DATE uses a \r\n                        day-resolution timestamp, and NONE removes the prefix \r\n                        completely. The default value is \"TIMESTAMP\".\r\n  --folder PATH         Path on the filesystem where the file should be \r\n                        created. The new migration will be created as a \r\n                        sibling of the last existing one if this is omitted.\r\n  --allow-extension EXTENSION\r\n                        Allowable extension for created files. By default .js,\r\n                         .ts and .sql files can be created. To create txt \r\n                        file migrations, for example, you could use '--name \r\n                        my-migration.txt --allow-extension .txt' This \r\n                        parameter may alternatively be specified via the \r\n                        UMZUG_ALLOW_EXTENSION environment variable.\r\n  --skip-verify         By default, the generated file will be checked after \r\n                        creation to make sure it is detected as a pending \r\n                        migration. This catches problems like creation in the \r\n                        wrong folder, or invalid naming conventions. This \r\n                        flag bypasses that verification step.\r\n  --allow-confusing-ordering\r\n                        By default, an error will be thrown if you try to \r\n                        create a migration that will run before a migration \r\n                        that already exists. This catches errors which can \r\n                        cause problems if you change file naming conventions. \r\n                        If you use a custom ordering system, you can disable \r\n                        this behavior, but it's strongly recommended that you \r\n                        don't! If you're unsure, just ignore this option.\r\n```\r\n<!-- codegen:end -->\r\n\r\n### Creating migrations - API\r\n\r\nUmzug includes an optional helper for generating migration files. It's often most convenient to create files using the [CLI helper](#creating-migrations---cli), but the equivalent API also exists on an umzug instance:\r\n\r\n```js\r\nawait umzug.create({ name: 'my-new-migration.js' })\r\n```\r\n\r\n## License\r\n\r\nSee the [LICENSE file](./LICENSE)\r\n","readmeFilename":"README.md","gitHead":"ac343744fbb1988d017734deadf49051570702ce","_id":"umzug@3.0.0-beta.12","_nodeVersion":"12.18.0","_npmVersion":"6.14.8","dist":{"integrity":"sha512-jlx5XsFTMBRKYRvyRSZeCbD6XYzc0goRMxh5BgHB7058MMhloMnWKxi2wOc/zGmB39TRGZImVGZdxjiuC1qxDA==","shasum":"f37e9381d20eb431259cf6b405ae7d25a81039f5","tarball":"https://registry.npmjs.org/umzug/-/umzug-3.0.0-beta.12.tgz","fileCount":40,"unpackedSize":129022,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJf0opICRA9TVsSAnZWagAAuggP/24ktPXDRTPyeMaQmQw1\nI8iGIYuLbg4t0OBGz6+7EqwZQyBFdPLbMoYPiJNNpb0V03AVwMD3hK357OTZ\n+1MvlGlzyGg0T+nqIoLNwaarHiWkfnoDRwmUWPTkYM4t8AkgFysZMIsyVtXi\nSdHriqeipKFSY1BOhHuKt43ONcJhIL2ymWDv+erHUV8zcnf5MtBTS7A5XZya\n2bqNMSQ0DoZBO1ZeKqn0bwBSRpIK+Pbk/J/2thAXIiMHp0bGVgKYI2PXKcll\n+O6UrsPCjXU5TfbH47nH3+uH6x03snLLUcFV4zkV14LKOM6li8OKf7q5D+YB\nMpjlvgL5CB68j2AntfO8INS1QGrHZWS3cUrQspawChh+WrIQWMJLgTpLUIyb\nZf5vjr7Uc0S9ictSjfW6jHcKRsoOLbh7x7Qx1JApGKOKgf32jVuNO9DGE/sZ\nYXqhqKEBqpJi+pCCLL1TuCyQ90oVGRiyFpudnswb3SCUtQdTsN027qx5Bp6r\n8410U06qorbgEDVDbTzc0hjSI1DjCOPYh6oN3tgl1IIok+DOK97FPMLX6tFZ\njbtSK9KzkLJ4CAm2vMjkPDPezrVzvNlao5IVOSMUXp7VqvZTL/+e7lVdGbek\nYzXIH091UZ4E5XfAgkTSMct1deY5aRIWD6cnpS50P15M6fClFjmsARQCWe1i\nNuOh\r\n=KoRT\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIEdviXASiLqd7TUHI7+0PkT4DTmrjOmPXIEmcfFqgKQjAiEAoDnrcKjSpvuG9rDCND1F94AopqpGD5qaOheLn/W5wxI="}]},"_npmUser":{"name":"mmkale","email":"mmkal1@outlook.com"},"directories":{},"maintainers":[{"name":"pascal.pflaum","email":"mail@pascalpflaum.de"},{"name":"sdepold","email":"sascha@depold.com"},{"name":"sushantdhiman","email":"sushantdhiman@outlook.com"},{"name":"papb","email":"papb1996@gmail.com"},{"name":"mmkale","email":"mmkal1@outlook.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/umzug_3.0.0-beta.12_1607633479809_0.9839231521783123"},"_hasShrinkwrap":false},"3.0.0-beta.13":{"name":"umzug","version":"3.0.0-beta.13","description":"Framework-agnostic migration tool for Node","keywords":["migrate","migration","migrations","sequelize","database"],"main":"lib/index.js","dependencies":{"@rushstack/ts-command-line":"~4.7.7","@types/verror":"^1.10.4","emittery":"~0.7.2","fs-jetpack":"~4.0.0","glob":"~7.1.6","type-fest":"~0.19.0","verror":"^1.10.0"},"devDependencies":{"@types/jest":"26.0.16","@types/lodash":"4.14.165","@types/uuid":"8.3.0","@typescript-eslint/eslint-plugin":"4.9.0","@typescript-eslint/parser":"4.9.0","del-cli":"3.0.1","eslint":"7.15.0","eslint-config-xo":"0.33.1","eslint-config-xo-typescript":"0.36.0","eslint-plugin-codegen":"0.14.3","eslint-plugin-import":"2.22.1","eslint-plugin-jest":"24.1.3","eslint-plugin-mocha":"8.0.0","eslint-plugin-prettier":"3.2.0","eslint-plugin-unicorn":"23.0.0","expect-type":"0.10.0","fs-syncer":"0.3.3","jest":"26.6.3","lodash":"4.17.20","np":"7.0.0","prettier":"2.2.1","sequelize":"5.22.3","sinon":"9.2.1","source-map-support":"0.5.19","sqlite3":"5.0.0","strip-ansi":"6.0.0","ts-jest":"26.4.4","ts-node":"9.0.0","typescript":"4.1.2","uuid":"8.3.1"},"scripts":{"build":"del-cli lib && tsc","lint":"eslint --ext .js,.ts,.md . --max-warnings 0","prepare":"npm run build","release":"np --no-yarn --no-2fa","pretest":"del-cli test/generated","test":"jest"},"repository":{"type":"git","url":"git+https://github.com/sequelize/umzug.git"},"author":{"name":"Sascha Depold","email":"sascha@depold.com"},"contributors":[{"name":"Jukka Hyytiälä","email":"hyytiala.jukka@gmail.com"},{"name":"Pascal Pflaum","email":"mail@pascalpflaum.de"},{"name":"Pedro Augusto de Paula Barbosa","email":"papb1996@gmail.com"}],"license":"MIT","bugs":{"url":"https://github.com/sequelize/umzug/issues"},"homepage":"https://github.com/sequelize/umzug","engines":{"node":">=10.0.0"},"jest":{"preset":"ts-jest","globals":{"ts-jest":{"diagnostics":false}},"testEnvironment":"node","testMatch":["**/*test.ts"],"collectCoverageFrom":["src/**"]},"readme":"# Umzug\r\n\r\n[![Build Status](https://badgen.net/github/checks/sequelize/umzug/master)](https://github.com/sequelize/umzug/actions?query=workflow%3ACI)\r\n[![npm (stable)](https://badgen.net/npm/v/umzug)](https://www.npmjs.com/package/umzug)\r\n[![npm (beta)](https://badgen.net/npm/v/umzug/beta)](https://www.npmjs.com/package/umzug/v/beta)\r\n[![npm (downloads)](https://badgen.net/npm/dm/umzug)](https://npmjs.com/package/umzug)\r\n\r\nUmzug is a framework-agnostic migration tool for Node. It provides a clean API for running and rolling back tasks.\r\n\r\n_Note: master represents the next major version of umzug - v3 - which is currently in beta. For the stable version, please refer to the [v2.x branch](https://github.com/sequelize/umzug/tree/v2.x)._\r\n\r\nTo install the v3-beta package:\r\n\r\n```\r\nnpm install umzug@beta\r\n```\r\n\r\nTo install the stable package (v2.x):\r\n\r\n```\r\nnpm install umzug\r\n```\r\n\r\n## Highlights\r\n\r\n* Written in TypeScript\r\n\t* Built-in typings\r\n\t* Auto-completion right in your IDE\r\n\t* Documentation right in your IDE\r\n* Programmatic API for migrations\r\n* Built-in [CLI](#cli)\r\n* Database agnostic\r\n* Supports logging of migration process\r\n* Supports multiple storages for migration data\r\n* [Usage examples](./examples)\r\n\r\n## Documentation\r\n\r\n### Minimal Example\r\n\r\nThe following example uses a Sqlite database through sequelize and persists the migration data in the database itself through the sequelize storage. There are several more involved examples covering a few different scenarios in the [examples folder](./examples).\r\n\r\n```js\r\n// index.js\r\nconst { Sequelize } = require('sequelize');\r\nconst { Umzug, SequelizeStorage } = require('umzug');\r\n\r\nconst sequelize = new Sequelize({ dialect: 'sqlite', storage: './db.sqlite' });\r\n\r\nconst umzug = new Umzug({\r\n  migrations: { glob: 'migrations/*.js' },\r\n  context: sequelize.getQueryInterface(),\r\n  storage: new SequelizeStorage({ sequelize }),\r\n  logger: console,\r\n});\r\n\r\n(async () => {\r\n  // Checks migrations and run them if they are not already applied. To keep\r\n  // track of the executed migrations, a table (and sequelize model) called SequelizeMeta\r\n  // will be automatically created (if it doesn't exist already) and parsed.\r\n  await umzug.up();\r\n})();\r\n```\r\n\r\n```js\r\n// migrations/00_initial.js\r\n\r\nconst { Sequelize } = require('sequelize');\r\n\r\nasync function up({ context: queryInterface }) {\r\n\tawait queryInterface.createTable('users', {\r\n\t\tid: {\r\n\t\t\ttype: Sequelize.INTEGER,\r\n\t\t\tallowNull: false,\r\n\t\t\tprimaryKey: true\r\n\t\t},\r\n\t\tname: {\r\n\t\t\ttype: Sequelize.STRING,\r\n\t\t\tallowNull: false\r\n\t\t},\r\n\t\tcreatedAt: {\r\n\t\t\ttype: Sequelize.DATE,\r\n\t\t\tallowNull: false\r\n\t\t},\r\n\t\tupdatedAt: {\r\n\t\t\ttype: Sequelize.DATE,\r\n\t\t\tallowNull: false\r\n\t\t}\r\n\t});\r\n}\r\n\r\nasync function down({ context: queryInterface }) {\r\n\tawait queryInterface.dropTable('users');\r\n}\r\n\r\nmodule.exports = { up, down };\r\n```\r\n\r\nNote that we renamed the `context` argument to `queryInterface` for clarity. The `context` is whatever we specified when creating the Umzug instance in `index.js`.\r\n\r\n<details>\r\n<summary>You can also write your migrations in typescript by using `ts-node` in the entrypoint:</summary>\r\n\r\n```typescript\r\n// index.ts\r\nrequire('ts-node/register')\r\n\r\nimport { Sequelize } from 'sequelize';\r\nimport { Umzug, SequelizeStorage } from 'umzug';\r\n\r\nconst sequelize = new Sequelize({ dialect: 'sqlite', storage: './db.sqlite' });\r\n\r\nconst umzug = new Umzug({\r\n  migrations: { glob: 'migrations/*.ts' },\r\n  context: sequelize.getQueryInterface(),\r\n  storage: new SequelizeStorage({ sequelize }),\r\n  logger: console,\r\n});\r\n\r\n// export the type helper exposed by umzug, which will have the `context` argument typed correctly\r\nexport type Migration = typeof umzug._types.migration;\r\n\r\n(async () => {\r\n  await umzug.up();\r\n})();\r\n```\r\n\r\n```typescript\r\n// migrations/00_initial.ts\r\nimport type { Migration } from '..';\r\n\r\n// types will now be available for `queryInterface`\r\nexport const up: Migration = ({ context: queryInterface }) => queryInterface.createTable(...)\r\nexport const down: Migration = ({ context: queryInterface }) => queryInterface.dropTable(...)\r\n```\r\n</details>\r\n\r\nSee [these tests](./test/umzug.test.ts) for more examples of Umzug usage, including:\r\n\r\n- passing `ignore` and `cwd` parameters to the glob instructions\r\n- customising migrations ordering\r\n- finding migrations from multiple different directories\r\n- using non-js file extensions via a custom resolver, e.g. `.sql`\r\n\r\n### Usage\r\n\r\n#### Installation\r\n\r\nThe beta version of Umzug is available on npm by specifying the correct tag:\r\n\r\n```bash\r\nnpm install umzug@beta\r\n```\r\n\r\n#### Umzug instance\r\n\r\nIt is possible to configure an Umzug instance by passing an object to the constructor.\r\n\r\n```js\r\nconst { Umzug } = require('umzug');\r\nconst umzug = new Umzug({ /* ... options ... */ });\r\n```\r\n\r\nDetailed documentation for these options are in the `UmzugOptions` TypeScript interface, which can be found in [src/types.ts](./src/types.ts).\r\n\r\n#### Getting all pending migrations\r\n\r\nYou can get a list of pending (i.e. not yet executed) migrations with the `pending()` method:\r\n\r\n```js\r\nconst migrations = await umzug.pending();\r\n// returns an array of all pending migrations.\r\n```\r\n\r\n#### Getting all executed migrations\r\n\r\nYou can get a list of already executed migrations with the `executed()` method:\r\n\r\n```js\r\nconst migrations = await umzug.executed();\r\n// returns an array of all already executed migrations\r\n```\r\n\r\n#### Executing pending migrations\r\n\r\nThe `up` method can be used to execute all pending migrations.\r\n\r\n```js\r\nconst migrations = await umzug.up();\r\n// returns an array of all executed migrations\r\n```\r\n\r\nIt is also possible to pass the name of a migration in order to just run the migrations from the current state to the passed migration name (inclusive).\r\n\r\n```js\r\nawait umzug.up({ to: '20141101203500-task' });\r\n```\r\n\r\nTo limit the number of migrations that are run, `step` can be used:\r\n\r\n```js\r\n// This will run the next two migrations\r\nawait umzug.up({ step: 2 })\r\n```\r\n\r\nRunning specific migrations while ignoring the right order, can be done like this:\r\n\r\n```js\r\nawait umzug.up({ migrations: ['20141101203500-task', '20141101203501-task-2'] });\r\n```\r\n\r\n#### Reverting executed migration\r\n\r\nThe `down` method can be used to revert the last executed migration.\r\n\r\n```js\r\nconst migration = await umzug.down();\r\n// reverts the last migration and returns it.\r\n```\r\n\r\nTo revert more than one migration, you can use `step`:\r\n\r\n```js\r\n// This will revert the last two migrations\r\nawait umzug.down({ step: 2 });\r\n```\r\n\r\nIt is possible to pass the name of a migration until which (inclusive) the migrations should be reverted. This allows the reverting of multiple migrations at once.\r\n\r\n```js\r\nconst migrations = await umzug.down({ to: '20141031080000-task' });\r\n// returns an array of all reverted migrations.\r\n```\r\n\r\nTo revert all migrations, you can pass 0 as the `to` parameter:\r\n\r\n```js\r\nawait umzug.down({ to: 0 });\r\n```\r\n\r\nReverting specific migrations while ignoring the right order, can be done like this:\r\n\r\n```js\r\nawait umzug.down({ migrations: ['20141101203500-task', '20141101203501-task-2'] });\r\n```\r\n\r\n### Migrations\r\n\r\nThere are two ways to specify migrations: via files or directly via an array of migrations.\r\n\r\n#### Migration files\r\n\r\nA migration file ideally exposes an `up` and a `down` async functions. They will perform the task of upgrading or downgrading the database.\r\n\r\n```js\r\nmodule.exports = {\r\n  async up() {\r\n    /* ... */\r\n  },\r\n  async down() {\r\n    /* ... */\r\n  }\r\n};\r\n```\r\n\r\nMigration files can be located anywhere - they will typically be loaded according to a glob pattern provided to the `Umzug` constructor.\r\n\r\n#### Direct migrations list\r\n\r\nYou can also specify directly a list of migrations to the `Umzug` constructor:\r\n\r\n```js\r\nconst { Umzug } = require('umzug');\r\n\r\nconst umzug = new Umzug({\r\n  migrations: [\r\n    {\r\n      // the name of the migration is mandatory\r\n      name: '00-first-migration',\r\n      async up({ context }) { /* ... */ },\r\n      async down({ context }) { /* ... */ }\r\n    },\r\n    {\r\n      name: '01-foo-bar-migration',\r\n      async up({ context }) { /* ... */ },\r\n      async down({ context }) { /* ... */ }\r\n    }\r\n  ],\r\n  context: sequelize.getQueryInterface(),\r\n  logger: console,\r\n});\r\n```\r\n\r\nTo load migrations in another format, you can use the `resolve` function:\r\n\r\n```js\r\nconst { Umzug } = require('umzug')\r\nconst { Sequelize } = require('sequelize')\r\nconst fs = require('fs')\r\n\r\nconst umzug = new Umzug({\r\n  migrations: {\r\n    glob: 'migrations/*.up.sql',\r\n    resolve: ({ name, path, context: sequelize }) => ({\r\n      name,\r\n      up: async () => {\r\n        const sql = fs.readFileSync(path).toString()\r\n        return sequelize.query(sql)\r\n      },\r\n      down: async () => {\r\n        // Get the corresponding `.down.sql` file to undo this migration\r\n        const sql = fs.readFileSync(path.replace('.up.sql', '.down.sql')).toString()\r\n        return sequelize.query(sql)\r\n      }\r\n    })\r\n  },\r\n  context: new Sequelize(...),\r\n  logger: console,\r\n});\r\n```\r\n\r\nYou can support mixed migration file types, and use umzug's default resolver for javascript/typescript:\r\n\r\n```js\r\nconst { Umzug } = require('umzug')\r\nconst { Sequelize } = require('sequelize')\r\nconst fs = require('fs')\r\n\r\nconst umzug = new Umzug({\r\n  migrations: {\r\n    glob: 'migrations/*.{js,ts,up.sql}',\r\n    resolve: (params) => {\r\n      if (!params.path.endsWith('.sql')) {\r\n        return Umzug.defaultResolver(params)\r\n      }\r\n      const { context: sequelize } = params\r\n      return {\r\n        name: params.name,\r\n        up: async () => {\r\n          const sql = fs.readFileSync(params.path).toString()\r\n          return sequelize.query(sql)\r\n        },\r\n        down: async () => {\r\n          // Get the corresponding `.down.sql` file to undo this migration\r\n          const sql = fs.readFileSync(params.path.replace('.up.sql', '.down.sql')).toString()\r\n          return sequelize.query(sql)\r\n        }\r\n      }\r\n    },\r\n  },\r\n  logger: console,\r\n  context: new Sequelize(...),\r\n});\r\n```\r\n\r\nThe glob syntax allows loading migrations from multiple locations:\r\n\r\n```js\r\nconst { Umzug } = require('umzug')\r\nconst { Sequelize } = require('sequelize')\r\n\r\nconst umzug = new Umzug({\r\n  migrations: {\r\n    glob: '{first-folder/*.js,second-folder-with-different-naming-convention/*.js}',\r\n  },\r\n  context: new Sequelize(...),\r\n  logger: console,\r\n});\r\n```\r\n\r\nNote on migration file sorting:\r\n\r\n- file matches, found using [glob](https://npmjs.com/package/glob), will be lexicographically sorted based on their paths\r\n  - so if your migrations are `one/m1.js`, `two/m2.js`, `three/m3.js`, the resultant order will be `one/m1.js`, `three/m3.js`, `two/m2.js`\r\n  - similarly, if your migrations are called `m1.js`, `m2.js`, ... `m10.js`, `m11.js`, the resultant ordering will be `m1.js`, `m10.js`, `m11.js`, ... `m2.js`\r\n- The easiest way to deal with this is to ensure your migrations appear in a single folder, and their paths match lexicographically with the order they should run in\r\n- If this isn't possible, the ordering can be customised using `.extend(...)` (see below)\r\n\r\n### Upgrading from v2.x\r\n\r\nThe Umzug class should be imported as a named import, i.e. `import { Umzug } from 'umzug'`.\r\n\r\nThe `MigrationMeta` type, which is returned by `umzug.executed()` and `umzug.pending()`, no longer has a `file` property - it has a `name` and *optional* `path` - since migrations are not necessarily bound to files on the file system.\r\n\r\nThe `migrations.glob` parameter replaces `path`, `pattern` and `traverseDirectories`. It can be used, in combination with `cwd` and `ignore` to do much more flexible file lookups. See https://npmjs.com/package/glob for more information on the syntax.\r\n\r\nThe `migrations.resolve` parameter replaces `customResolver`. Explicit support for `wrap` and `nameFormatter` has been removed - these can be easily implemented in a `resolve` function.\r\n\r\nThe constructor option `logging` is replaced by `logger` to allow for `warn` and `error` messages in future. NodeJS's global `console` object can be passed to this. To disable logging, replace `logging: false` with `logger: undefined`.\r\n\r\nEvents have moved from the default nodejs `EventEmitter` to [emittery](https://www.npmjs.com/package/emittery). It has better design for async code, a less bloated API surface and strong types. But, it doesn't allow passing multiple arguments to callbacks, so listeners have to change slightly, as well as `.addListener(...)` and `.removeListener(...)` no longer being supported (`.on(...)` and `.off(...)` should now be used):\r\n\r\nBefore:\r\n\r\n```js\r\numzug.on('migrating', (name, m) => console.log({ name, path: m.path }))\r\n```\r\n\r\nAfter:\r\n\r\n```js\r\numzug.on('migrating', ev => console.log({ name: ev.name, path: ev.path }))\r\n```\r\n\r\nThe `Umzug#execute` method is removed. Use `Umzug#up` or `Umzug#down`.\r\n\r\nThe options for `Umguz#up` and `Umzug#down` have changed:\r\n- `umzug.up({ to: 'some-name' })` and `umzug.down({ to: 'some-name' })` are still valid.\r\n- `umzug.up({ from: '...' })` and `umzug.down({ from: '...' })` are no longer supported. To run migrations out-of-order (which is not generally recommended), you can explicitly use `umzug.up({ migrations: ['...'] })` and `umzug.down({ migrations: ['...'] })`.\r\n- name matches must be exact. `umzug.up({ to: 'some-n' })` will no longer match a migration called `some-name`.\r\n- `umzug.down({ to: 0 })` is still valid but `umzug.up({ to: 0 })` is not.\r\n- `umzug.up({ migrations: ['m1', 'm2'] })` is still valid but the shorthand `umzug.up(['m1', 'm2'])` has been removed.\r\n- `umzug.down({ migrations: ['m1', 'm2'] })` is still valid but the shorthand `umzug.down(['m1', 'm2'])` has been removed.\r\n- `umzug.up({ migrations: ['m1', 'already-run'] })` will throw an error, if `already-run` is not found in the list of pending migrations.\r\n- `umzug.down({ migrations: ['m1', 'has-not-been-run'] })` will throw an error, if `has-not-been-run` is not found in the list of executed migrations.\r\n- `umzug.up({ migrations: ['m1', 'm2'], rerun: 'ALLOW' })` will re-apply migrations `m1` and `m2` even if they've already been run.\r\n- `umzug.up({ migrations: ['m1', 'm2'], rerun: 'SKIP' })` will skip migrations `m1` and `m2` if they've already been run.\r\n- `umzug.down({ migrations: ['m1', 'm2'], rerun: 'ALLOW' })` will \"revert\" migrations `m1` and `m2` even if they've never been run.\r\n- `umzug.down({ migrations: ['m1', 'm2'], rerun: 'SKIP' })` will skip reverting migrations `m1` and `m2` if they haven't been run or are already reverted.\r\n- `umzug.up({ migrations: ['m1', 'does-not-exist', 'm2'] })` will throw an error if the migration name is not found. Note that the error will be thrown and no migrations run unless _all_ migration names are found - whether or not `rerun: 'ALLOW'` is added.\r\n\r\nThe `context` parameter replaces `params`, and is passed in as a property to migration functions as an options object, alongs side `name` and `path`. This means the signature for migrations, which in v2 was `(context) => Promise<void>`, has changed slightly in v3, to `({ name, path, context }) => Promise<void>`. The `resolve` function can also be used to upgrade your umzug version to v3 when you have existing v2-compatible migrations:\r\n\r\n```js\r\nconst { Umzug } = require('umzug');\r\n\r\nconst umzug = new Umzug({\r\n  migrations: {\r\n    glob: 'migrations/umzug-v2-format/*.js',\r\n    resolve: ({name, path, context}) => {\r\n      // Adjust the migration from the new signature to the v2 signature, making easier to upgrade to v3\r\n      const migration = require(path)\r\n      return { name, up: async () => migration.up(context), down: async () => migration.down(context) }\r\n    }\r\n  },\r\n  context: sequelize.getQueryInterface(),\r\n  logger: console,\r\n});\r\n```\r\n\r\nSimilarly, you no longer need `migrationSorting`, you can use `Umzug#extend` to manipulate migration lists directly:\r\n\r\n```js\r\nconst { Umzug } = require('umzug');\r\n\r\nconst umzug =\r\n  new Umzug({\r\n    migrations: { glob: 'migrations/**/*.js' },\r\n    context: sequelize.getQueryInterface(),\r\n  })\r\n  .extend(migrations => migrations.sort((a, b) => b.path.localeCompare(a.path)));\r\n```\r\n\r\n### Storages\r\n\r\nStorages define where the migration data is stored.\r\n\r\n#### JSON Storage\r\n\r\nUsing `JSONStorage` will create a JSON file which will contain an array with all the executed migrations. You can specify the path to the file. The default for that is `umzug.json` in the working directory of the process.\r\n\r\nDetailed documentation for the options it can take are in the `JSONStorageConstructorOptions` TypeScript interface, which can be found in [src/storage/json.ts](./src/storage/json.ts).\r\n\r\n#### Memory Storage\r\n\r\nUsing `memoryStorage` will store migrations with an in-memory array. This can be useful for proof-of-concepts or tests, since it doesn't interact with databases or filesystems.\r\n\r\nIt doesn't take any options, just import the `memoryStorage` function and call it to return a storage instance:\r\n\r\n```typescript\r\nimport { Umzug, memoryStorage } from 'umzug'\r\n\r\nconst umzug = new Umzug({\r\n  migrations: ...,\r\n  storage: memoryStorage(),\r\n  logger: console,\r\n})\r\n```\r\n\r\n#### Sequelize Storage\r\n\r\nUsing `SequelizeStorage` will create a table in your SQL database called `SequelizeMeta` containing an entry for each executed migration. You will have to pass a configured instance of Sequelize or an existing Sequelize model. Optionally you can specify the model name, table name, or column name. All major Sequelize versions are supported.\r\n\r\nDetailed documentation for the options it can take are in the `_SequelizeStorageConstructorOptions` TypeScript interface, which can be found in [src/storage/sequelize.ts](./src/storage/sequelize.ts).\r\n\r\n#### MongoDB Storage\r\n\r\nUsing `MongoDBStorage` will create a collection in your MongoDB database called `migrations` containing an entry for each executed migration. You will have either to pass a MongoDB Driver Collection as `collection` property. Alternatively you can pass a established MongoDB Driver connection and a collection name.\r\n\r\nDetailed documentation for the options it can take are in the `MongoDBStorageConstructorOptions` TypeScript interface, which can be found in [src/storage/mongodb.ts](./src/storage/mongodb.ts).\r\n\r\n#### Custom\r\n\r\nIn order to use a custom storage, you can pass your storage instance to Umzug constructor.\r\n\r\n```js\r\nclass CustomStorage {\r\n  constructor(...) {...}\r\n  logMigration(...) {...}\r\n  unlogMigration(...) {...}\r\n  executed(...) {...}\r\n}\r\n\r\nconst umzug = new Umzug({ storage: new CustomStorage(...), logger: console })\r\n```\r\n\r\nYour instance must adhere to the [UmzugStorage](./src/storage/contract.ts) interface. If you're using TypeScript you can ensure this at compile time, and get IDE type hints by importing it:\r\n\r\n```typescript\r\nimport { UmzugStorage } from 'umzug'\r\n\r\nclass CustomStorage implements UmzugStorage {\r\n  /* ... */\r\n}\r\n```\r\n\r\n### Events\r\n\r\nUmzug is an [emittery event emitter](https://www.npmjs.com/package/emittery). Each of the following events will be called with migration parameters as its payload (with `context`, `name`, and nullable `path` properties). Events are a convenient place to implement application-specific logic that must run around each migration:\r\n\r\n* `migrating` - A migration is about to be executed.\r\n* `migrated` - A migration has successfully been executed.\r\n* `reverting` - A migration is about to be reverted.\r\n* `reverted` - A migration has successfully been reverted.\r\n\r\nThese events run at the beginning and end of `up` and `down` calls. They'll receive an object containing a `context` property:\r\n\r\n- `beforeCommand` - Before any command (`'up' | 'down' | 'executed' | 'pending'`) is run.\r\n- `afterCommand` - After any command (`'up' | 'down' | 'executed' | 'pending'`) is run. Note: this will always run, even if the command throws an error.\r\n\r\nThe [`FileLocker` class](./src/file-locker.ts) uses `beforeAll` and `afterAll` to implement a simple filesystem-based locking mechanism.\r\n\r\nAll events are type-safe, so IDEs will prevent typos and supply strong types for the event payloads.\r\n\r\n### Errors\r\n\r\nWhen a migration throws an error, it will be wrapped in a `MigrationError` which captures the migration metadata (name, path etc.) as well as the original error message, and _will be rethrown_. In most cases, this is expected behaviour, and doesn't require any special handling beyond standard error logging setups.\r\n\r\nIf you expect failures and want to try to recover from them, you will need to try-catch the call to `umzug.up()`. You can access the original error from the `.cause` property if necessary:\r\n\r\n```js\r\ntry {\r\n  await umzug.up();\r\n} catch (e) {\r\n  if (e instanceof MigrationError) {\r\n    const original = e.cause;\r\n    // do something with the original error here\r\n  }\r\n  throw e;\r\n}\r\n```\r\n\r\nUnder the hood, [verror](https://npmjs.com/package/verror) is used to wrap errors.\r\n\r\n### CLI\r\n\r\n🚧🚧🚧 The CLI is new to Umzug v3 beta and is not yet stable. Feedback on it is welcome in [discussions](https://github.com/sequelize/umzug/discussions) 🚧🚧🚧\r\n\r\nUmzug instances provide a `.runAsCLI()` method. When called, this method will automatically cause your program to become a complete CLI, with help text and such:\r\n\r\n```js\r\n// migrator.js\r\nconst { Umzug } = require('umzug')\r\n\r\nexports.umzug = new Umzug({ ... })\r\n\r\nif (require.main === module) {\r\n  umzug.runAsCLI()\r\n}\r\n```\r\n\r\n#### CLI Usage\r\n\r\nA script like the one above is now a runnable CLI program. You can run `node migrator.js --help` to see how to use it. It will print something like:\r\n\r\n<!-- codegen:start {preset: custom, source: ./codegen.js, export: cliHelp} -->\r\n```\r\nusage: <script> [-h] <command> ...\r\n\r\nUmzug migrator\r\n\r\nPositional arguments:\r\n  <command>\r\n    up        Applies pending migrations\r\n    down      Revert migrations\r\n    pending   Lists pending migrations\r\n    executed  Lists executed migrations\r\n    create    Create a migration file\r\n\r\nOptional arguments:\r\n  -h, --help  Show this help message and exit.\r\n\r\nFor detailed help about a specific command, use: <script> <command> -h\r\n```\r\n<!-- codegen:end -->\r\n\r\n#### Running migrations\r\n\r\n`node migrator up` and `node migrator down` apply and revert migrations respectively. They're the equivalent of the `.up()` and `.down()` methods.\r\n\r\nUse `node migrator up --help` and `node migrator down --help` for options (running \"to\" a specific migration, passing migration names to be run explicitly, and specifying the rerun behavior):\r\n\r\nUp:\r\n<!-- codegen:start {preset: custom, source: ./codegen.js, export: cliHelp, action: up} -->\r\n```\r\nusage: <script> up [-h] [--to NAME] [--step COUNT] [--name MIGRATION]\r\n                   [--rerun {THROW,SKIP,ALLOW}]\r\n                   \r\n\r\nPerforms all migrations. See --help for more options\r\n\r\nOptional arguments:\r\n  -h, --help            Show this help message and exit.\r\n  --to NAME             All migrations up to and including this one should be \r\n                        applied.\r\n  --step COUNT          Run this many migrations. If not specified, all will \r\n                        be applied.\r\n  --name MIGRATION      Explicity declare migration name(s) to be applied.\r\n  --rerun {THROW,SKIP,ALLOW}\r\n                        Specify what action should be taken when a migration \r\n                        that has already been applied is passed to --name. \r\n                        The default value is \"THROW\".\r\n```\r\n<!-- codegen:end -->\r\n\r\nDown:\r\n<!-- codegen:start {preset: custom, source: ./codegen.js, export: cliHelp, action: down} -->\r\n```\r\nusage: <script> down [-h] [--to NAME] [--step COUNT] [--name MIGRATION]\r\n                     [--rerun {THROW,SKIP,ALLOW}]\r\n                     \r\n\r\nUndoes previously-applied migrations. By default, undoes the most recent \r\nmigration only. Use --help for more options. Useful in development to start \r\nfrom a clean slate. Use with care in production!\r\n\r\nOptional arguments:\r\n  -h, --help            Show this help message and exit.\r\n  --to NAME             All migrations up to and including this one should be \r\n                        reverted. Pass \"0\" to revert all.\r\n  --step COUNT          Run this many migrations. If not specified, one will \r\n                        be reverted.\r\n  --name MIGRATION      Explicity declare migration name(s) to be reverted.\r\n  --rerun {THROW,SKIP,ALLOW}\r\n                        Specify what action should be taken when a migration \r\n                        that has already been reverted is passed to --name. \r\n                        The default value is \"THROW\".\r\n```\r\n<!-- codegen:end -->\r\n\r\n\r\n#### Listing migrations\r\n\r\n```bash\r\nnode migrator pending # list migrations yet to be run\r\nnode migrator executed # list migrations that have already run\r\n\r\nnode migrator pending --json # list pending migrations including names and paths, in a json array format\r\nnode migrator executed --json # list executed migrations including names and paths, in a json array format\r\n\r\nnode migrator pending --help # show help/options\r\nnode migrator executed --help # show help/options\r\n```\r\n\r\n<!-- codegen:start {preset: custom, source: ./codegen.js, export: cliHelp, action: pending} -->\r\n```\r\nusage: <script> pending [-h] [--json]\r\n\r\nPrints migrations returned by `umzug.pending()`. By default, prints migration \r\nnames one per line.\r\n\r\nOptional arguments:\r\n  -h, --help  Show this help message and exit.\r\n  --json      Print pending migrations in a json format including names and \r\n              paths. This allows piping output to tools like jq. Without this \r\n              flag, the migration names will be printed one per line.\r\n```\r\n<!-- codegen:end -->\r\n\r\n<!-- codegen:start {preset: custom, source: ./codegen.js, export: cliHelp, action: executed} -->\r\n```\r\nusage: <script> executed [-h] [--json]\r\n\r\nPrints migrations returned by `umzug.executed()`. By default, prints \r\nmigration names one per line.\r\n\r\nOptional arguments:\r\n  -h, --help  Show this help message and exit.\r\n  --json      Print executed migrations in a json format including names and \r\n              paths. This allows piping output to tools like jq. Without this \r\n              flag, the migration names will be printed one per line.\r\n```\r\n<!-- codegen:end -->\r\n\r\n#### Creating migrations - CLI\r\n\r\nUsually, migrations correspond to files on the filesystem. The CLI exposes a way to create migration files easily:\r\n\r\n```bash\r\nnode migrator create --name my-migration.js\r\n```\r\n\r\nThis will create a file with a name like `2000.12.25T12.34.56.my-migration.js` in the same directory as the most recent migration file. If it's the very first migration file, you need to specify the folder explicitly:\r\n\r\n```bash\r\nnode migrator create --name my-migration.js --folder path/to/directory\r\n```\r\n\r\nThe timestamp prefix can be customized to be date-only or omitted, but be aware that it's strongly recommended to ensure your migrations are lexicographically sortable so it's easy for humans and tools to determine what order they should run in - so the default prefix is recommended.\r\n\r\nThis will generate a migration file called `<<timestamp>>.my-migration.js` with the default migration template for `.js` files that ships with Umzug.\r\n\r\nUmzug also ships with default templates for [`.ts`, `.cjs`, `.mjs` and `.sql` files](./src/templates.ts). Umzug will choose the template based on the extension you provide in `name`.\r\n\r\nYou can specify a custom template for your project when constructing an umzug instance via the `template` option. It should be a function which receives a filepath string, and returns an array of `[filepath, content]` pairs. Usually, just one pair is needed, but a second could be used to include a \"down\" migration in a separate file:\r\n\r\n```js\r\nconst umzug = new Umzug({\r\n  migrations: ...,\r\n  template: filepath => [\r\n    [filepath, fs.readFileSync('path/to/your/template/file').toString()],\r\n  ]\r\n})\r\n```\r\n\r\nThe create command includes some safety checks to make sure migrations aren't created with ambiguous ordering, and that they will be picked up by umzug when applying migrations.\r\n\r\nUse `node migrator create --help` for more options:\r\n\r\n<!-- codegen:start {preset: custom, source: ./codegen.js, export: cliHelp, action: create} -->\r\n```\r\nusage: <script> create [-h] --name NAME [--prefix {TIMESTAMP,DATE,NONE}]\r\n                       [--folder PATH] [--allow-extension EXTENSION]\r\n                       [--skip-verify] [--allow-confusing-ordering]\r\n                       \r\n\r\nGenerates a placeholder migration file using a timestamp as a prefix. By \r\ndefault, mimics the last existing migration, or guesses where to generate the \r\nfile if no migration exists yet.\r\n\r\nOptional arguments:\r\n  -h, --help            Show this help message and exit.\r\n  --name NAME           The name of the migration file. e.g. my-migration.js, \r\n                        my-migration.ts or my-migration.sql. Note - a prefix \r\n                        will be added to this name, usually based on a \r\n                        timestamp. See --prefix\r\n  --prefix {TIMESTAMP,DATE,NONE}\r\n                        The prefix format for generated files. TIMESTAMP uses \r\n                        a second-resolution timestamp, DATE uses a \r\n                        day-resolution timestamp, and NONE removes the prefix \r\n                        completely. The default value is \"TIMESTAMP\".\r\n  --folder PATH         Path on the filesystem where the file should be \r\n                        created. The new migration will be created as a \r\n                        sibling of the last existing one if this is omitted.\r\n  --allow-extension EXTENSION\r\n                        Allowable extension for created files. By default .js,\r\n                         .ts and .sql files can be created. To create txt \r\n                        file migrations, for example, you could use '--name \r\n                        my-migration.txt --allow-extension .txt' This \r\n                        parameter may alternatively be specified via the \r\n                        UMZUG_ALLOW_EXTENSION environment variable.\r\n  --skip-verify         By default, the generated file will be checked after \r\n                        creation to make sure it is detected as a pending \r\n                        migration. This catches problems like creation in the \r\n                        wrong folder, or invalid naming conventions. This \r\n                        flag bypasses that verification step.\r\n  --allow-confusing-ordering\r\n                        By default, an error will be thrown if you try to \r\n                        create a migration that will run before a migration \r\n                        that already exists. This catches errors which can \r\n                        cause problems if you change file naming conventions. \r\n                        If you use a custom ordering system, you can disable \r\n                        this behavior, but it's strongly recommended that you \r\n                        don't! If you're unsure, just ignore this option.\r\n```\r\n<!-- codegen:end -->\r\n\r\n### Creating migrations - API\r\n\r\nUmzug includes an optional helper for generating migration files. It's often most convenient to create files using the [CLI helper](#creating-migrations---cli), but the equivalent API also exists on an umzug instance:\r\n\r\n```js\r\nawait umzug.create({ name: 'my-new-migration.js' })\r\n```\r\n\r\n## License\r\n\r\nSee the [LICENSE file](./LICENSE)\r\n","readmeFilename":"README.md","gitHead":"8066ed6e5a62c762f2d3657a6ad39aa72eeb521e","_id":"umzug@3.0.0-beta.13","_nodeVersion":"12.18.0","_npmVersion":"6.14.8","dist":{"integrity":"sha512-+A7fFxDQDsq+VL/4aSzOOrwFuIOCSGESKsY5EcyEJ48yj6VseDpC+6/mlJs+w1ARsTb/yk1OxH6Zk7LqbNyXRQ==","shasum":"2a28ec0490fc6169b72208a4de010a720c68e886","tarball":"https://registry.npmjs.org/umzug/-/umzug-3.0.0-beta.13.tgz","fileCount":40,"unpackedSize":131078,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJf2NvpCRA9TVsSAnZWagAA96oP/2tVcP0fDBGLSablh2GB\nJ226NH3IzI9QE2q/5P2D6xWBmrgMQLEBICZqYiHkCnfFS8prB9/CQiZXtM9Z\nAyNrNb135ZAXqhZ3ng9w+H+A+m9Y59hFyI6YGJVvW94A+ugQkJwls40m3Obe\n3T1A0OakV0EU8bnx0KugUaitV6xEljnqMU+yDqHyPwF7Y7/JZjv+VNZ9Nfc8\n7xlLBpQYOADNpB+8NM0Sx2NfxCPUcpSjbEEu4ZTHMKHB2n0XmBPE0CxrTAmv\n/xJ6WNiHS/CQxaAeNyGzgagFJ+j1SsgZZeilwMgwc5yE97VMK3F7F09Q0wOB\nIPDVN+DS7Etybf2FVlKHypCMUedWz/g5SamtmgmoTYAoO7Ggg47+nQr9tb3p\nDil7roQ6F988pltTKjD/3CfgQoKwXbXrM360LMHki0z2su0qyadhQ0BcXkB7\njq5v2wxo2poKG6NXsJnjAE5GzHmOhSa4goyUZ0qpttPpa+jn/Kbqtizkx/zE\n9L+XjtYe7usagpYL1suWWRvJDau8hLGBhKeRPyQyjUsaW/2r+MiqcGcO9FC1\nSg35zy0tbfPUh9Gk7I2psXqebziEkOXX0d2DbPrxy243Zdlkw9Qw55YZxvgy\n7AGeK25kEQsJx0RIvgFdLKNKf5bvJIfYeSvS4zHlgH/gcchIWpm3oI3qWg+A\nXwCp\r\n=AXLc\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEQCIH/cMk80hWa0HYHVrjCKI6rdxAbX7y35W/82XdAIU6iCAiBYUAH7x1922J7ccPP3YxP7UHIcWFL/cqiW3KRm/G0TFA=="}]},"_npmUser":{"name":"mmkale","email":"mmkal1@outlook.com"},"directories":{},"maintainers":[{"name":"pascal.pflaum","email":"mail@pascalpflaum.de"},{"name":"sdepold","email":"sascha@depold.com"},{"name":"sushantdhiman","email":"sushantdhiman@outlook.com"},{"name":"papb","email":"papb1996@gmail.com"},{"name":"mmkale","email":"mmkal1@outlook.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/umzug_3.0.0-beta.13_1608047592273_0.3388612847401655"},"_hasShrinkwrap":false},"3.0.0-beta.14":{"name":"umzug","version":"3.0.0-beta.14","description":"Framework-agnostic migration tool for Node","keywords":["migrate","migration","migrations","sequelize","database"],"main":"lib/index.js","dependencies":{"@rushstack/ts-command-line":"^4.7.7","@types/verror":"^1.10.4","emittery":"^0.7.2","fs-jetpack":"^4.1.0","glob":"^7.1.6","type-fest":"^0.20.0","verror":"^1.10.0"},"devDependencies":{"@types/jest":"26.0.19","@types/lodash":"4.14.165","@types/uuid":"8.3.0","@typescript-eslint/eslint-plugin":"4.10.0","@typescript-eslint/parser":"4.10.0","del-cli":"3.0.1","eslint":"7.16.0","eslint-config-xo":"0.33.1","eslint-config-xo-typescript":"0.37.0","eslint-plugin-codegen":"0.14.4","eslint-plugin-import":"2.22.1","eslint-plugin-jest":"24.1.3","eslint-plugin-mocha":"8.0.0","eslint-plugin-prettier":"3.3.0","eslint-plugin-unicorn":"24.0.0","expect-type":"0.11.0","fs-syncer":"0.3.4","jest":"26.6.3","lodash":"4.17.20","np":"7.0.0","prettier":"2.2.1","sequelize":"5.22.3","sinon":"9.2.2","source-map-support":"0.5.19","sqlite3":"5.0.0","strip-ansi":"6.0.0","ts-jest":"26.4.4","ts-node":"9.1.1","typescript":"4.1.3","uuid":"8.3.2"},"scripts":{"build":"del-cli lib && tsc","lint":"eslint --ext .js,.ts,.md . --max-warnings 0","prepare":"npm run build","release":"np --no-yarn --no-2fa","pretest":"del-cli test/generated","test":"jest"},"repository":{"type":"git","url":"git+https://github.com/sequelize/umzug.git"},"author":{"name":"Sascha Depold","email":"sascha@depold.com"},"contributors":[{"name":"Jukka Hyytiälä","email":"hyytiala.jukka@gmail.com"},{"name":"Pascal Pflaum","email":"mail@pascalpflaum.de"},{"name":"Pedro Augusto de Paula Barbosa","email":"papb1996@gmail.com"}],"license":"MIT","bugs":{"url":"https://github.com/sequelize/umzug/issues"},"homepage":"https://github.com/sequelize/umzug","engines":{"node":">=10.0.0"},"jest":{"preset":"ts-jest","globals":{"ts-jest":{"diagnostics":false}},"testEnvironment":"node","testMatch":["**/*test.ts"],"collectCoverageFrom":["src/**"]},"readme":"# Umzug\r\n\r\n[![Build Status](https://badgen.net/github/checks/sequelize/umzug/master)](https://github.com/sequelize/umzug/actions?query=workflow%3ACI)\r\n[![npm (stable)](https://badgen.net/npm/v/umzug)](https://www.npmjs.com/package/umzug)\r\n[![npm (beta)](https://badgen.net/npm/v/umzug/beta)](https://www.npmjs.com/package/umzug/v/beta)\r\n[![npm (downloads)](https://badgen.net/npm/dm/umzug)](https://npmjs.com/package/umzug)\r\n\r\nUmzug is a framework-agnostic migration tool for Node. It provides a clean API for running and rolling back tasks.\r\n\r\n_Note: master represents the next major version of umzug - v3 - which is currently in beta. For the stable version, please refer to the [v2.x branch](https://github.com/sequelize/umzug/tree/v2.x)._\r\n\r\nTo install the v3-beta package:\r\n\r\n```\r\nnpm install umzug@beta\r\n```\r\n\r\nTo install the stable package (v2.x):\r\n\r\n```\r\nnpm install umzug\r\n```\r\n\r\n## Highlights\r\n\r\n* Written in TypeScript\r\n\t* Built-in typings\r\n\t* Auto-completion right in your IDE\r\n\t* Documentation right in your IDE\r\n* Programmatic API for migrations\r\n* Built-in [CLI](#cli)\r\n* Database agnostic\r\n* Supports logging of migration process\r\n* Supports multiple storages for migration data\r\n* [Usage examples](./examples)\r\n\r\n## Documentation\r\n\r\n### Minimal Example\r\n\r\nThe following example uses a Sqlite database through sequelize and persists the migration data in the database itself through the sequelize storage. There are several more involved examples covering a few different scenarios in the [examples folder](./examples).\r\n\r\n```js\r\n// index.js\r\nconst { Sequelize } = require('sequelize');\r\nconst { Umzug, SequelizeStorage } = require('umzug');\r\n\r\nconst sequelize = new Sequelize({ dialect: 'sqlite', storage: './db.sqlite' });\r\n\r\nconst umzug = new Umzug({\r\n  migrations: { glob: 'migrations/*.js' },\r\n  context: sequelize.getQueryInterface(),\r\n  storage: new SequelizeStorage({ sequelize }),\r\n  logger: console,\r\n});\r\n\r\n(async () => {\r\n  // Checks migrations and run them if they are not already applied. To keep\r\n  // track of the executed migrations, a table (and sequelize model) called SequelizeMeta\r\n  // will be automatically created (if it doesn't exist already) and parsed.\r\n  await umzug.up();\r\n})();\r\n```\r\n\r\n```js\r\n// migrations/00_initial.js\r\n\r\nconst { Sequelize } = require('sequelize');\r\n\r\nasync function up({ context: queryInterface }) {\r\n\tawait queryInterface.createTable('users', {\r\n\t\tid: {\r\n\t\t\ttype: Sequelize.INTEGER,\r\n\t\t\tallowNull: false,\r\n\t\t\tprimaryKey: true\r\n\t\t},\r\n\t\tname: {\r\n\t\t\ttype: Sequelize.STRING,\r\n\t\t\tallowNull: false\r\n\t\t},\r\n\t\tcreatedAt: {\r\n\t\t\ttype: Sequelize.DATE,\r\n\t\t\tallowNull: false\r\n\t\t},\r\n\t\tupdatedAt: {\r\n\t\t\ttype: Sequelize.DATE,\r\n\t\t\tallowNull: false\r\n\t\t}\r\n\t});\r\n}\r\n\r\nasync function down({ context: queryInterface }) {\r\n\tawait queryInterface.dropTable('users');\r\n}\r\n\r\nmodule.exports = { up, down };\r\n```\r\n\r\nNote that we renamed the `context` argument to `queryInterface` for clarity. The `context` is whatever we specified when creating the Umzug instance in `index.js`.\r\n\r\n<details>\r\n<summary>You can also write your migrations in typescript by using `ts-node` in the entrypoint:</summary>\r\n\r\n```typescript\r\n// index.ts\r\nrequire('ts-node/register')\r\n\r\nimport { Sequelize } from 'sequelize';\r\nimport { Umzug, SequelizeStorage } from 'umzug';\r\n\r\nconst sequelize = new Sequelize({ dialect: 'sqlite', storage: './db.sqlite' });\r\n\r\nconst umzug = new Umzug({\r\n  migrations: { glob: 'migrations/*.ts' },\r\n  context: sequelize.getQueryInterface(),\r\n  storage: new SequelizeStorage({ sequelize }),\r\n  logger: console,\r\n});\r\n\r\n// export the type helper exposed by umzug, which will have the `context` argument typed correctly\r\nexport type Migration = typeof umzug._types.migration;\r\n\r\n(async () => {\r\n  await umzug.up();\r\n})();\r\n```\r\n\r\n```typescript\r\n// migrations/00_initial.ts\r\nimport type { Migration } from '..';\r\n\r\n// types will now be available for `queryInterface`\r\nexport const up: Migration = ({ context: queryInterface }) => queryInterface.createTable(...)\r\nexport const down: Migration = ({ context: queryInterface }) => queryInterface.dropTable(...)\r\n```\r\n</details>\r\n\r\nSee [these tests](./test/umzug.test.ts) for more examples of Umzug usage, including:\r\n\r\n- passing `ignore` and `cwd` parameters to the glob instructions\r\n- customising migrations ordering\r\n- finding migrations from multiple different directories\r\n- using non-js file extensions via a custom resolver, e.g. `.sql`\r\n\r\n### Usage\r\n\r\n#### Installation\r\n\r\nThe beta version of Umzug is available on npm by specifying the correct tag:\r\n\r\n```bash\r\nnpm install umzug@beta\r\n```\r\n\r\n#### Umzug instance\r\n\r\nIt is possible to configure an Umzug instance by passing an object to the constructor.\r\n\r\n```js\r\nconst { Umzug } = require('umzug');\r\nconst umzug = new Umzug({ /* ... options ... */ });\r\n```\r\n\r\nDetailed documentation for these options are in the `UmzugOptions` TypeScript interface, which can be found in [src/types.ts](./src/types.ts).\r\n\r\n#### Getting all pending migrations\r\n\r\nYou can get a list of pending (i.e. not yet executed) migrations with the `pending()` method:\r\n\r\n```js\r\nconst migrations = await umzug.pending();\r\n// returns an array of all pending migrations.\r\n```\r\n\r\n#### Getting all executed migrations\r\n\r\nYou can get a list of already executed migrations with the `executed()` method:\r\n\r\n```js\r\nconst migrations = await umzug.executed();\r\n// returns an array of all already executed migrations\r\n```\r\n\r\n#### Executing pending migrations\r\n\r\nThe `up` method can be used to execute all pending migrations.\r\n\r\n```js\r\nconst migrations = await umzug.up();\r\n// returns an array of all executed migrations\r\n```\r\n\r\nIt is also possible to pass the name of a migration in order to just run the migrations from the current state to the passed migration name (inclusive).\r\n\r\n```js\r\nawait umzug.up({ to: '20141101203500-task' });\r\n```\r\n\r\nTo limit the number of migrations that are run, `step` can be used:\r\n\r\n```js\r\n// This will run the next two migrations\r\nawait umzug.up({ step: 2 })\r\n```\r\n\r\nRunning specific migrations while ignoring the right order, can be done like this:\r\n\r\n```js\r\nawait umzug.up({ migrations: ['20141101203500-task', '20141101203501-task-2'] });\r\n```\r\n\r\n#### Reverting executed migration\r\n\r\nThe `down` method can be used to revert the last executed migration.\r\n\r\n```js\r\nconst migration = await umzug.down();\r\n// reverts the last migration and returns it.\r\n```\r\n\r\nTo revert more than one migration, you can use `step`:\r\n\r\n```js\r\n// This will revert the last two migrations\r\nawait umzug.down({ step: 2 });\r\n```\r\n\r\nIt is possible to pass the name of a migration until which (inclusive) the migrations should be reverted. This allows the reverting of multiple migrations at once.\r\n\r\n```js\r\nconst migrations = await umzug.down({ to: '20141031080000-task' });\r\n// returns an array of all reverted migrations.\r\n```\r\n\r\nTo revert all migrations, you can pass 0 as the `to` parameter:\r\n\r\n```js\r\nawait umzug.down({ to: 0 });\r\n```\r\n\r\nReverting specific migrations while ignoring the right order, can be done like this:\r\n\r\n```js\r\nawait umzug.down({ migrations: ['20141101203500-task', '20141101203501-task-2'] });\r\n```\r\n\r\n### Migrations\r\n\r\nThere are two ways to specify migrations: via files or directly via an array of migrations.\r\n\r\n#### Migration files\r\n\r\nA migration file ideally exposes an `up` and a `down` async functions. They will perform the task of upgrading or downgrading the database.\r\n\r\n```js\r\nmodule.exports = {\r\n  async up() {\r\n    /* ... */\r\n  },\r\n  async down() {\r\n    /* ... */\r\n  }\r\n};\r\n```\r\n\r\nMigration files can be located anywhere - they will typically be loaded according to a glob pattern provided to the `Umzug` constructor.\r\n\r\n#### Direct migrations list\r\n\r\nYou can also specify directly a list of migrations to the `Umzug` constructor:\r\n\r\n```js\r\nconst { Umzug } = require('umzug');\r\n\r\nconst umzug = new Umzug({\r\n  migrations: [\r\n    {\r\n      // the name of the migration is mandatory\r\n      name: '00-first-migration',\r\n      async up({ context }) { /* ... */ },\r\n      async down({ context }) { /* ... */ }\r\n    },\r\n    {\r\n      name: '01-foo-bar-migration',\r\n      async up({ context }) { /* ... */ },\r\n      async down({ context }) { /* ... */ }\r\n    }\r\n  ],\r\n  context: sequelize.getQueryInterface(),\r\n  logger: console,\r\n});\r\n```\r\n\r\nTo load migrations in another format, you can use the `resolve` function:\r\n\r\n```js\r\nconst { Umzug } = require('umzug')\r\nconst { Sequelize } = require('sequelize')\r\nconst fs = require('fs')\r\n\r\nconst umzug = new Umzug({\r\n  migrations: {\r\n    glob: 'migrations/*.up.sql',\r\n    resolve: ({ name, path, context: sequelize }) => ({\r\n      name,\r\n      up: async () => {\r\n        const sql = fs.readFileSync(path).toString()\r\n        return sequelize.query(sql)\r\n      },\r\n      down: async () => {\r\n        // Get the corresponding `.down.sql` file to undo this migration\r\n        const sql = fs.readFileSync(path.replace('.up.sql', '.down.sql')).toString()\r\n        return sequelize.query(sql)\r\n      }\r\n    })\r\n  },\r\n  context: new Sequelize(...),\r\n  logger: console,\r\n});\r\n```\r\n\r\nYou can support mixed migration file types, and use umzug's default resolver for javascript/typescript:\r\n\r\n```js\r\nconst { Umzug } = require('umzug')\r\nconst { Sequelize } = require('sequelize')\r\nconst fs = require('fs')\r\n\r\nconst umzug = new Umzug({\r\n  migrations: {\r\n    glob: 'migrations/*.{js,ts,up.sql}',\r\n    resolve: (params) => {\r\n      if (!params.path.endsWith('.sql')) {\r\n        return Umzug.defaultResolver(params)\r\n      }\r\n      const { context: sequelize } = params\r\n      return {\r\n        name: params.name,\r\n        up: async () => {\r\n          const sql = fs.readFileSync(params.path).toString()\r\n          return sequelize.query(sql)\r\n        },\r\n        down: async () => {\r\n          // Get the corresponding `.down.sql` file to undo this migration\r\n          const sql = fs.readFileSync(params.path.replace('.up.sql', '.down.sql')).toString()\r\n          return sequelize.query(sql)\r\n        }\r\n      }\r\n    },\r\n  },\r\n  logger: console,\r\n  context: new Sequelize(...),\r\n});\r\n```\r\n\r\nThe glob syntax allows loading migrations from multiple locations:\r\n\r\n```js\r\nconst { Umzug } = require('umzug')\r\nconst { Sequelize } = require('sequelize')\r\n\r\nconst umzug = new Umzug({\r\n  migrations: {\r\n    glob: '{first-folder/*.js,second-folder-with-different-naming-convention/*.js}',\r\n  },\r\n  context: new Sequelize(...),\r\n  logger: console,\r\n});\r\n```\r\n\r\nNote on migration file sorting:\r\n\r\n- file matches, found using [glob](https://npmjs.com/package/glob), will be lexicographically sorted based on their paths\r\n  - so if your migrations are `one/m1.js`, `two/m2.js`, `three/m3.js`, the resultant order will be `one/m1.js`, `three/m3.js`, `two/m2.js`\r\n  - similarly, if your migrations are called `m1.js`, `m2.js`, ... `m10.js`, `m11.js`, the resultant ordering will be `m1.js`, `m10.js`, `m11.js`, ... `m2.js`\r\n- The easiest way to deal with this is to ensure your migrations appear in a single folder, and their paths match lexicographically with the order they should run in\r\n- If this isn't possible, the ordering can be customised using `.extend(...)` (see below)\r\n\r\n### Upgrading from v2.x\r\n\r\nThe Umzug class should be imported as a named import, i.e. `import { Umzug } from 'umzug'`.\r\n\r\nThe `MigrationMeta` type, which is returned by `umzug.executed()` and `umzug.pending()`, no longer has a `file` property - it has a `name` and *optional* `path` - since migrations are not necessarily bound to files on the file system.\r\n\r\nThe `migrations.glob` parameter replaces `path`, `pattern` and `traverseDirectories`. It can be used, in combination with `cwd` and `ignore` to do much more flexible file lookups. See https://npmjs.com/package/glob for more information on the syntax.\r\n\r\nThe `migrations.resolve` parameter replaces `customResolver`. Explicit support for `wrap` and `nameFormatter` has been removed - these can be easily implemented in a `resolve` function.\r\n\r\nThe constructor option `logging` is replaced by `logger` to allow for `warn` and `error` messages in future. NodeJS's global `console` object can be passed to this. To disable logging, replace `logging: false` with `logger: undefined`.\r\n\r\nEvents have moved from the default nodejs `EventEmitter` to [emittery](https://www.npmjs.com/package/emittery). It has better design for async code, a less bloated API surface and strong types. But, it doesn't allow passing multiple arguments to callbacks, so listeners have to change slightly, as well as `.addListener(...)` and `.removeListener(...)` no longer being supported (`.on(...)` and `.off(...)` should now be used):\r\n\r\nBefore:\r\n\r\n```js\r\numzug.on('migrating', (name, m) => console.log({ name, path: m.path }))\r\n```\r\n\r\nAfter:\r\n\r\n```js\r\numzug.on('migrating', ev => console.log({ name: ev.name, path: ev.path }))\r\n```\r\n\r\nThe `Umzug#execute` method is removed. Use `Umzug#up` or `Umzug#down`.\r\n\r\nThe options for `Umguz#up` and `Umzug#down` have changed:\r\n- `umzug.up({ to: 'some-name' })` and `umzug.down({ to: 'some-name' })` are still valid.\r\n- `umzug.up({ from: '...' })` and `umzug.down({ from: '...' })` are no longer supported. To run migrations out-of-order (which is not generally recommended), you can explicitly use `umzug.up({ migrations: ['...'] })` and `umzug.down({ migrations: ['...'] })`.\r\n- name matches must be exact. `umzug.up({ to: 'some-n' })` will no longer match a migration called `some-name`.\r\n- `umzug.down({ to: 0 })` is still valid but `umzug.up({ to: 0 })` is not.\r\n- `umzug.up({ migrations: ['m1', 'm2'] })` is still valid but the shorthand `umzug.up(['m1', 'm2'])` has been removed.\r\n- `umzug.down({ migrations: ['m1', 'm2'] })` is still valid but the shorthand `umzug.down(['m1', 'm2'])` has been removed.\r\n- `umzug.up({ migrations: ['m1', 'already-run'] })` will throw an error, if `already-run` is not found in the list of pending migrations.\r\n- `umzug.down({ migrations: ['m1', 'has-not-been-run'] })` will throw an error, if `has-not-been-run` is not found in the list of executed migrations.\r\n- `umzug.up({ migrations: ['m1', 'm2'], rerun: 'ALLOW' })` will re-apply migrations `m1` and `m2` even if they've already been run.\r\n- `umzug.up({ migrations: ['m1', 'm2'], rerun: 'SKIP' })` will skip migrations `m1` and `m2` if they've already been run.\r\n- `umzug.down({ migrations: ['m1', 'm2'], rerun: 'ALLOW' })` will \"revert\" migrations `m1` and `m2` even if they've never been run.\r\n- `umzug.down({ migrations: ['m1', 'm2'], rerun: 'SKIP' })` will skip reverting migrations `m1` and `m2` if they haven't been run or are already reverted.\r\n- `umzug.up({ migrations: ['m1', 'does-not-exist', 'm2'] })` will throw an error if the migration name is not found. Note that the error will be thrown and no migrations run unless _all_ migration names are found - whether or not `rerun: 'ALLOW'` is added.\r\n\r\nThe `context` parameter replaces `params`, and is passed in as a property to migration functions as an options object, alongs side `name` and `path`. This means the signature for migrations, which in v2 was `(context) => Promise<void>`, has changed slightly in v3, to `({ name, path, context }) => Promise<void>`. The `resolve` function can also be used to upgrade your umzug version to v3 when you have existing v2-compatible migrations:\r\n\r\n```js\r\nconst { Umzug } = require('umzug');\r\n\r\nconst umzug = new Umzug({\r\n  migrations: {\r\n    glob: 'migrations/umzug-v2-format/*.js',\r\n    resolve: ({name, path, context}) => {\r\n      // Adjust the migration from the new signature to the v2 signature, making easier to upgrade to v3\r\n      const migration = require(path)\r\n      return { name, up: async () => migration.up(context), down: async () => migration.down(context) }\r\n    }\r\n  },\r\n  context: sequelize.getQueryInterface(),\r\n  logger: console,\r\n});\r\n```\r\n\r\nSimilarly, you no longer need `migrationSorting`, you can use `Umzug#extend` to manipulate migration lists directly:\r\n\r\n```js\r\nconst { Umzug } = require('umzug');\r\n\r\nconst umzug =\r\n  new Umzug({\r\n    migrations: { glob: 'migrations/**/*.js' },\r\n    context: sequelize.getQueryInterface(),\r\n  })\r\n  .extend(migrations => migrations.sort((a, b) => b.path.localeCompare(a.path)));\r\n```\r\n\r\n### Storages\r\n\r\nStorages define where the migration data is stored.\r\n\r\n#### JSON Storage\r\n\r\nUsing `JSONStorage` will create a JSON file which will contain an array with all the executed migrations. You can specify the path to the file. The default for that is `umzug.json` in the working directory of the process.\r\n\r\nDetailed documentation for the options it can take are in the `JSONStorageConstructorOptions` TypeScript interface, which can be found in [src/storage/json.ts](./src/storage/json.ts).\r\n\r\n#### Memory Storage\r\n\r\nUsing `memoryStorage` will store migrations with an in-memory array. This can be useful for proof-of-concepts or tests, since it doesn't interact with databases or filesystems.\r\n\r\nIt doesn't take any options, just import the `memoryStorage` function and call it to return a storage instance:\r\n\r\n```typescript\r\nimport { Umzug, memoryStorage } from 'umzug'\r\n\r\nconst umzug = new Umzug({\r\n  migrations: ...,\r\n  storage: memoryStorage(),\r\n  logger: console,\r\n})\r\n```\r\n\r\n#### Sequelize Storage\r\n\r\nUsing `SequelizeStorage` will create a table in your SQL database called `SequelizeMeta` containing an entry for each executed migration. You will have to pass a configured instance of Sequelize or an existing Sequelize model. Optionally you can specify the model name, table name, or column name. All major Sequelize versions are supported.\r\n\r\nDetailed documentation for the options it can take are in the `_SequelizeStorageConstructorOptions` TypeScript interface, which can be found in [src/storage/sequelize.ts](./src/storage/sequelize.ts).\r\n\r\n#### MongoDB Storage\r\n\r\nUsing `MongoDBStorage` will create a collection in your MongoDB database called `migrations` containing an entry for each executed migration. You will have either to pass a MongoDB Driver Collection as `collection` property. Alternatively you can pass a established MongoDB Driver connection and a collection name.\r\n\r\nDetailed documentation for the options it can take are in the `MongoDBStorageConstructorOptions` TypeScript interface, which can be found in [src/storage/mongodb.ts](./src/storage/mongodb.ts).\r\n\r\n#### Custom\r\n\r\nIn order to use a custom storage, you can pass your storage instance to Umzug constructor.\r\n\r\n```js\r\nclass CustomStorage {\r\n  constructor(...) {...}\r\n  logMigration(...) {...}\r\n  unlogMigration(...) {...}\r\n  executed(...) {...}\r\n}\r\n\r\nconst umzug = new Umzug({ storage: new CustomStorage(...), logger: console })\r\n```\r\n\r\nYour instance must adhere to the [UmzugStorage](./src/storage/contract.ts) interface. If you're using TypeScript you can ensure this at compile time, and get IDE type hints by importing it:\r\n\r\n```typescript\r\nimport { UmzugStorage } from 'umzug'\r\n\r\nclass CustomStorage implements UmzugStorage {\r\n  /* ... */\r\n}\r\n```\r\n\r\n### Events\r\n\r\nUmzug is an [emittery event emitter](https://www.npmjs.com/package/emittery). Each of the following events will be called with migration parameters as its payload (with `context`, `name`, and nullable `path` properties). Events are a convenient place to implement application-specific logic that must run around each migration:\r\n\r\n* `migrating` - A migration is about to be executed.\r\n* `migrated` - A migration has successfully been executed.\r\n* `reverting` - A migration is about to be reverted.\r\n* `reverted` - A migration has successfully been reverted.\r\n\r\nThese events run at the beginning and end of `up` and `down` calls. They'll receive an object containing a `context` property:\r\n\r\n- `beforeCommand` - Before any command (`'up' | 'down' | 'executed' | 'pending'`) is run.\r\n- `afterCommand` - After any command (`'up' | 'down' | 'executed' | 'pending'`) is run. Note: this will always run, even if the command throws an error.\r\n\r\nThe [`FileLocker` class](./src/file-locker.ts) uses `beforeAll` and `afterAll` to implement a simple filesystem-based locking mechanism.\r\n\r\nAll events are type-safe, so IDEs will prevent typos and supply strong types for the event payloads.\r\n\r\n### Errors\r\n\r\nWhen a migration throws an error, it will be wrapped in a `MigrationError` which captures the migration metadata (name, path etc.) as well as the original error message, and _will be rethrown_. In most cases, this is expected behaviour, and doesn't require any special handling beyond standard error logging setups.\r\n\r\nIf you expect failures and want to try to recover from them, you will need to try-catch the call to `umzug.up()`. You can access the original error from the `.cause` property if necessary:\r\n\r\n```js\r\ntry {\r\n  await umzug.up();\r\n} catch (e) {\r\n  if (e instanceof MigrationError) {\r\n    const original = e.cause;\r\n    // do something with the original error here\r\n  }\r\n  throw e;\r\n}\r\n```\r\n\r\nUnder the hood, [verror](https://npmjs.com/package/verror) is used to wrap errors.\r\n\r\n### CLI\r\n\r\n🚧🚧🚧 The CLI is new to Umzug v3 beta and is not yet stable. Feedback on it is welcome in [discussions](https://github.com/sequelize/umzug/discussions) 🚧🚧🚧\r\n\r\nUmzug instances provide a `.runAsCLI()` method. When called, this method will automatically cause your program to become a complete CLI, with help text and such:\r\n\r\n```js\r\n// migrator.js\r\nconst { Umzug } = require('umzug')\r\n\r\nexports.umzug = new Umzug({ ... })\r\n\r\nif (require.main === module) {\r\n  umzug.runAsCLI()\r\n}\r\n```\r\n\r\n#### CLI Usage\r\n\r\nA script like the one above is now a runnable CLI program. You can run `node migrator.js --help` to see how to use it. It will print something like:\r\n\r\n<!-- codegen:start {preset: custom, source: ./codegen.js, export: cliHelp} -->\r\n```\r\nusage: <script> [-h] <command> ...\r\n\r\nUmzug migrator\r\n\r\nPositional arguments:\r\n  <command>\r\n    up        Applies pending migrations\r\n    down      Revert migrations\r\n    pending   Lists pending migrations\r\n    executed  Lists executed migrations\r\n    create    Create a migration file\r\n\r\nOptional arguments:\r\n  -h, --help  Show this help message and exit.\r\n\r\nFor detailed help about a specific command, use: <script> <command> -h\r\n```\r\n<!-- codegen:end -->\r\n\r\n#### Running migrations\r\n\r\n`node migrator up` and `node migrator down` apply and revert migrations respectively. They're the equivalent of the `.up()` and `.down()` methods.\r\n\r\nUse `node migrator up --help` and `node migrator down --help` for options (running \"to\" a specific migration, passing migration names to be run explicitly, and specifying the rerun behavior):\r\n\r\nUp:\r\n<!-- codegen:start {preset: custom, source: ./codegen.js, export: cliHelp, action: up} -->\r\n```\r\nusage: <script> up [-h] [--to NAME] [--step COUNT] [--name MIGRATION]\r\n                   [--rerun {THROW,SKIP,ALLOW}]\r\n                   \r\n\r\nPerforms all migrations. See --help for more options\r\n\r\nOptional arguments:\r\n  -h, --help            Show this help message and exit.\r\n  --to NAME             All migrations up to and including this one should be \r\n                        applied.\r\n  --step COUNT          Run this many migrations. If not specified, all will \r\n                        be applied.\r\n  --name MIGRATION      Explicity declare migration name(s) to be applied.\r\n  --rerun {THROW,SKIP,ALLOW}\r\n                        Specify what action should be taken when a migration \r\n                        that has already been applied is passed to --name. \r\n                        The default value is \"THROW\".\r\n```\r\n<!-- codegen:end -->\r\n\r\nDown:\r\n<!-- codegen:start {preset: custom, source: ./codegen.js, export: cliHelp, action: down} -->\r\n```\r\nusage: <script> down [-h] [--to NAME] [--step COUNT] [--name MIGRATION]\r\n                     [--rerun {THROW,SKIP,ALLOW}]\r\n                     \r\n\r\nUndoes previously-applied migrations. By default, undoes the most recent \r\nmigration only. Use --help for more options. Useful in development to start \r\nfrom a clean slate. Use with care in production!\r\n\r\nOptional arguments:\r\n  -h, --help            Show this help message and exit.\r\n  --to NAME             All migrations up to and including this one should be \r\n                        reverted. Pass \"0\" to revert all.\r\n  --step COUNT          Run this many migrations. If not specified, one will \r\n                        be reverted.\r\n  --name MIGRATION      Explicity declare migration name(s) to be reverted.\r\n  --rerun {THROW,SKIP,ALLOW}\r\n                        Specify what action should be taken when a migration \r\n                        that has already been reverted is passed to --name. \r\n                        The default value is \"THROW\".\r\n```\r\n<!-- codegen:end -->\r\n\r\n\r\n#### Listing migrations\r\n\r\n```bash\r\nnode migrator pending # list migrations yet to be run\r\nnode migrator executed # list migrations that have already run\r\n\r\nnode migrator pending --json # list pending migrations including names and paths, in a json array format\r\nnode migrator executed --json # list executed migrations including names and paths, in a json array format\r\n\r\nnode migrator pending --help # show help/options\r\nnode migrator executed --help # show help/options\r\n```\r\n\r\n<!-- codegen:start {preset: custom, source: ./codegen.js, export: cliHelp, action: pending} -->\r\n```\r\nusage: <script> pending [-h] [--json]\r\n\r\nPrints migrations returned by `umzug.pending()`. By default, prints migration \r\nnames one per line.\r\n\r\nOptional arguments:\r\n  -h, --help  Show this help message and exit.\r\n  --json      Print pending migrations in a json format including names and \r\n              paths. This allows piping output to tools like jq. Without this \r\n              flag, the migration names will be printed one per line.\r\n```\r\n<!-- codegen:end -->\r\n\r\n<!-- codegen:start {preset: custom, source: ./codegen.js, export: cliHelp, action: executed} -->\r\n```\r\nusage: <script> executed [-h] [--json]\r\n\r\nPrints migrations returned by `umzug.executed()`. By default, prints \r\nmigration names one per line.\r\n\r\nOptional arguments:\r\n  -h, --help  Show this help message and exit.\r\n  --json      Print executed migrations in a json format including names and \r\n              paths. This allows piping output to tools like jq. Without this \r\n              flag, the migration names will be printed one per line.\r\n```\r\n<!-- codegen:end -->\r\n\r\n#### Creating migrations - CLI\r\n\r\nUsually, migrations correspond to files on the filesystem. The CLI exposes a way to create migration files easily:\r\n\r\n```bash\r\nnode migrator create --name my-migration.js\r\n```\r\n\r\nThis will create a file with a name like `2000.12.25T12.34.56.my-migration.js` in the same directory as the most recent migration file. If it's the very first migration file, you need to specify the folder explicitly:\r\n\r\n```bash\r\nnode migrator create --name my-migration.js --folder path/to/directory\r\n```\r\n\r\nThe timestamp prefix can be customized to be date-only or omitted, but be aware that it's strongly recommended to ensure your migrations are lexicographically sortable so it's easy for humans and tools to determine what order they should run in - so the default prefix is recommended.\r\n\r\nThis will generate a migration file called `<<timestamp>>.my-migration.js` with the default migration template for `.js` files that ships with Umzug.\r\n\r\nUmzug also ships with default templates for [`.ts`, `.cjs`, `.mjs` and `.sql` files](./src/templates.ts). Umzug will choose the template based on the extension you provide in `name`.\r\n\r\nYou can specify a custom template for your project when constructing an umzug instance via the `template` option. It should be a function which receives a filepath string, and returns an array of `[filepath, content]` pairs. Usually, just one pair is needed, but a second could be used to include a \"down\" migration in a separate file:\r\n\r\n```js\r\nconst umzug = new Umzug({\r\n  migrations: ...,\r\n  template: filepath => [\r\n    [filepath, fs.readFileSync('path/to/your/template/file').toString()],\r\n  ]\r\n})\r\n```\r\n\r\nThe create command includes some safety checks to make sure migrations aren't created with ambiguous ordering, and that they will be picked up by umzug when applying migrations.\r\n\r\nUse `node migrator create --help` for more options:\r\n\r\n<!-- codegen:start {preset: custom, source: ./codegen.js, export: cliHelp, action: create} -->\r\n```\r\nusage: <script> create [-h] --name NAME [--prefix {TIMESTAMP,DATE,NONE}]\r\n                       [--folder PATH] [--allow-extension EXTENSION]\r\n                       [--skip-verify] [--allow-confusing-ordering]\r\n                       \r\n\r\nGenerates a placeholder migration file using a timestamp as a prefix. By \r\ndefault, mimics the last existing migration, or guesses where to generate the \r\nfile if no migration exists yet.\r\n\r\nOptional arguments:\r\n  -h, --help            Show this help message and exit.\r\n  --name NAME           The name of the migration file. e.g. my-migration.js, \r\n                        my-migration.ts or my-migration.sql. Note - a prefix \r\n                        will be added to this name, usually based on a \r\n                        timestamp. See --prefix\r\n  --prefix {TIMESTAMP,DATE,NONE}\r\n                        The prefix format for generated files. TIMESTAMP uses \r\n                        a second-resolution timestamp, DATE uses a \r\n                        day-resolution timestamp, and NONE removes the prefix \r\n                        completely. The default value is \"TIMESTAMP\".\r\n  --folder PATH         Path on the filesystem where the file should be \r\n                        created. The new migration will be created as a \r\n                        sibling of the last existing one if this is omitted.\r\n  --allow-extension EXTENSION\r\n                        Allowable extension for created files. By default .js,\r\n                         .ts and .sql files can be created. To create txt \r\n                        file migrations, for example, you could use '--name \r\n                        my-migration.txt --allow-extension .txt' This \r\n                        parameter may alternatively be specified via the \r\n                        UMZUG_ALLOW_EXTENSION environment variable.\r\n  --skip-verify         By default, the generated file will be checked after \r\n                        creation to make sure it is detected as a pending \r\n                        migration. This catches problems like creation in the \r\n                        wrong folder, or invalid naming conventions. This \r\n                        flag bypasses that verification step.\r\n  --allow-confusing-ordering\r\n                        By default, an error will be thrown if you try to \r\n                        create a migration that will run before a migration \r\n                        that already exists. This catches errors which can \r\n                        cause problems if you change file naming conventions. \r\n                        If you use a custom ordering system, you can disable \r\n                        this behavior, but it's strongly recommended that you \r\n                        don't! If you're unsure, just ignore this option.\r\n```\r\n<!-- codegen:end -->\r\n\r\n### Creating migrations - API\r\n\r\nUmzug includes an optional helper for generating migration files. It's often most convenient to create files using the [CLI helper](#creating-migrations---cli), but the equivalent API also exists on an umzug instance:\r\n\r\n```js\r\nawait umzug.create({ name: 'my-new-migration.js' })\r\n```\r\n\r\n## License\r\n\r\nSee the [LICENSE file](./LICENSE)\r\n","readmeFilename":"README.md","gitHead":"0e64e6a00e2f28e17717f52bbc1e27fbf4fa0bff","_id":"umzug@3.0.0-beta.14","_nodeVersion":"12.18.0","_npmVersion":"6.14.8","dist":{"integrity":"sha512-5FcSwsxgnRcSj/puTYLKhK0JFhiWM6+AjtyX8NtSogM8ykoi5/C0dUw97GLQEZ9VGx9YI4fupY9uA7jHc1pMaw==","shasum":"e7d25f6a25e77b6d6ec0cc1ad08a80ff291bc576","tarball":"https://registry.npmjs.org/umzug/-/umzug-3.0.0-beta.14.tgz","fileCount":40,"unpackedSize":131098,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJf4PFrCRA9TVsSAnZWagAAXWsP/2q5Cn035fWm4sauzPWS\n0dwLcgCVetObOcJTZ1zrDQq2l5xS9m59TByS1ps639oaEukkpzH7EroA29gM\nf9XtQ1y5qAHVv13wq6+ycDfh6GtEkhVxD85h5xRXJxrsi8BnA1XbJY1yJVUg\nXqzAZezvoVpVdEWde8PB3c9+Gmj1NusjDKaBeHWa46YXh5aQAexcoXGkb/F/\nZE8yUI8+YQPkFELQWbSS4uGjirS3A2dEwf5XHYoHVpog/O66vZBbM2K/Nlat\n+BN+rEvlYt8BZdT+tTKCsNe8M8gFpCfeH604S8i4mON3aqyu9uNktHPI2tDb\ncHB0Ox4MMneW906bFkjhh+akanI1GeEWMfhHslyD/BQzBJ+c6r0riMo/NzCy\nJ32m9+IPHibliPBSxr7lrLtTp/e8xHYlWKfbp801+avpf8JjNaMOWGxDGAhU\n2BwYk8UcC/NGNz593/Ws/wNeivHiTptedjCHTGjqg+R7KN4pdJVKJm3irm5i\nyytXrJ1ERdtlif1Wnwcl0sxZhoPg1dDQNjXpaN2l4jdi/1pXXhn8ZgEFR2tu\nsOQ2K7izeibAkKLNQQv6KDm231gFJYaXdziZqVUJVMzy0fSf4/OIiptzz3v5\nrkxfEbLUeOQstvDATplVy+5QBsp2eWs4cykuT89tmq9ivHaxEK7gaxYhiiKF\nlZIK\r\n=n7uk\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEYCIQC/bnvkbFen4vHBDraeH4pKfHPtpXhOCzzKM800metI4gIhAJA7nwHhVWl6aK5qiDyd+h2yPvb8Vmjai6EguFc9FIHj"}]},"_npmUser":{"name":"mmkale","email":"mmkal1@outlook.com"},"directories":{},"maintainers":[{"name":"pascal.pflaum","email":"mail@pascalpflaum.de"},{"name":"sdepold","email":"sascha@depold.com"},{"name":"sushantdhiman","email":"sushantdhiman@outlook.com"},{"name":"papb","email":"papb1996@gmail.com"},{"name":"mmkale","email":"mmkal1@outlook.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/umzug_3.0.0-beta.14_1608577387031_0.5229262907510117"},"_hasShrinkwrap":false},"3.0.0-beta.15":{"name":"umzug","version":"3.0.0-beta.15","description":"Framework-agnostic migration tool for Node","keywords":["migrate","migration","migrations","sequelize","database"],"main":"lib/index.js","dependencies":{"@rushstack/ts-command-line":"^4.7.7","@types/verror":"^1.10.4","emittery":"^0.8.1","fs-jetpack":"^4.1.0","glob":"^7.1.6","type-fest":"^0.20.0","verror":"^1.10.0"},"devDependencies":{"@types/jest":"26.0.20","@types/lodash":"4.14.168","@types/uuid":"8.3.0","@typescript-eslint/eslint-plugin":"4.14.1","@typescript-eslint/parser":"4.14.1","del-cli":"3.0.1","eslint":"7.19.0","eslint-config-xo":"0.34.0","eslint-config-xo-typescript":"0.37.0","eslint-plugin-codegen":"0.15.0","eslint-plugin-import":"2.22.1","eslint-plugin-jest":"24.1.3","eslint-plugin-mocha":"8.0.0","eslint-plugin-prettier":"3.3.1","eslint-plugin-unicorn":"24.0.0","expect-type":"0.11.0","fs-syncer":"0.3.4","jest":"26.6.3","lodash":"4.17.20","np":"7.2.0","prettier":"2.2.1","sequelize":"5.22.3","sinon":"9.2.4","source-map-support":"0.5.19","sqlite3":"5.0.1","strip-ansi":"6.0.0","ts-jest":"26.5.0","ts-node":"9.1.1","typescript":"4.1.3","uuid":"8.3.2"},"scripts":{"build":"del-cli lib && tsc -p tsconfig.lib.json","eslint":"eslint --ext .js,.ts,.md . --max-warnings 0","lint":"npm run type-check && npm run eslint","prepare":"npm run build","release":"np --no-yarn --no-2fa","pretest":"del-cli test/generated","test":"jest","type-check":"tsc -p ."},"repository":{"type":"git","url":"git+https://github.com/sequelize/umzug.git"},"author":{"name":"Sascha Depold","email":"sascha@depold.com"},"contributors":[{"name":"Jukka Hyytiälä","email":"hyytiala.jukka@gmail.com"},{"name":"Pascal Pflaum","email":"mail@pascalpflaum.de"},{"name":"Pedro Augusto de Paula Barbosa","email":"papb1996@gmail.com"}],"license":"MIT","bugs":{"url":"https://github.com/sequelize/umzug/issues"},"homepage":"https://github.com/sequelize/umzug","engines":{"node":">=10.0.0"},"jest":{"preset":"ts-jest","globals":{"ts-jest":{"diagnostics":false}},"testEnvironment":"node","testMatch":["**/*test.ts"],"collectCoverageFrom":["src/**"]},"readme":"# Umzug\r\n\r\n[![Build Status](https://badgen.net/github/checks/sequelize/umzug/master)](https://github.com/sequelize/umzug/actions?query=workflow%3ACI)\r\n[![npm (stable)](https://badgen.net/npm/v/umzug)](https://www.npmjs.com/package/umzug)\r\n[![npm (beta)](https://badgen.net/npm/v/umzug/beta)](https://www.npmjs.com/package/umzug/v/beta)\r\n[![npm (downloads)](https://badgen.net/npm/dm/umzug)](https://npmjs.com/package/umzug)\r\n\r\nUmzug is a framework-agnostic migration tool for Node. It provides a clean API for running and rolling back tasks.\r\n\r\n_Note: master represents the next major version of umzug - v3 - which is currently in beta. For the stable version, please refer to the [v2.x branch](https://github.com/sequelize/umzug/tree/v2.x)._\r\n\r\nTo install the v3-beta package:\r\n\r\n```\r\nnpm install umzug@beta\r\n```\r\n\r\nTo install the stable package (v2.x):\r\n\r\n```\r\nnpm install umzug\r\n```\r\n\r\n## Highlights\r\n\r\n* Written in TypeScript\r\n\t* Built-in typings\r\n\t* Auto-completion right in your IDE\r\n\t* Documentation right in your IDE\r\n* Programmatic API for migrations\r\n* Built-in [CLI](#cli)\r\n* Database agnostic\r\n* Supports logging of migration process\r\n* Supports multiple storages for migration data\r\n* [Usage examples](./examples)\r\n\r\n## Documentation\r\n\r\n### Minimal Example\r\n\r\nThe following example uses a Sqlite database through sequelize and persists the migration data in the database itself through the sequelize storage. There are several more involved examples covering a few different scenarios in the [examples folder](./examples).\r\n\r\n```js\r\n// index.js\r\nconst { Sequelize } = require('sequelize');\r\nconst { Umzug, SequelizeStorage } = require('umzug');\r\n\r\nconst sequelize = new Sequelize({ dialect: 'sqlite', storage: './db.sqlite' });\r\n\r\nconst umzug = new Umzug({\r\n  migrations: { glob: 'migrations/*.js' },\r\n  context: sequelize.getQueryInterface(),\r\n  storage: new SequelizeStorage({ sequelize }),\r\n  logger: console,\r\n});\r\n\r\n(async () => {\r\n  // Checks migrations and run them if they are not already applied. To keep\r\n  // track of the executed migrations, a table (and sequelize model) called SequelizeMeta\r\n  // will be automatically created (if it doesn't exist already) and parsed.\r\n  await umzug.up();\r\n})();\r\n```\r\n\r\n```js\r\n// migrations/00_initial.js\r\n\r\nconst { Sequelize } = require('sequelize');\r\n\r\nasync function up({ context: queryInterface }) {\r\n\tawait queryInterface.createTable('users', {\r\n\t\tid: {\r\n\t\t\ttype: Sequelize.INTEGER,\r\n\t\t\tallowNull: false,\r\n\t\t\tprimaryKey: true\r\n\t\t},\r\n\t\tname: {\r\n\t\t\ttype: Sequelize.STRING,\r\n\t\t\tallowNull: false\r\n\t\t},\r\n\t\tcreatedAt: {\r\n\t\t\ttype: Sequelize.DATE,\r\n\t\t\tallowNull: false\r\n\t\t},\r\n\t\tupdatedAt: {\r\n\t\t\ttype: Sequelize.DATE,\r\n\t\t\tallowNull: false\r\n\t\t}\r\n\t});\r\n}\r\n\r\nasync function down({ context: queryInterface }) {\r\n\tawait queryInterface.dropTable('users');\r\n}\r\n\r\nmodule.exports = { up, down };\r\n```\r\n\r\nNote that we renamed the `context` argument to `queryInterface` for clarity. The `context` is whatever we specified when creating the Umzug instance in `index.js`.\r\n\r\n<details>\r\n<summary>You can also write your migrations in typescript by using `ts-node` in the entrypoint:</summary>\r\n\r\n```typescript\r\n// index.ts\r\nrequire('ts-node/register')\r\n\r\nimport { Sequelize } from 'sequelize';\r\nimport { Umzug, SequelizeStorage } from 'umzug';\r\n\r\nconst sequelize = new Sequelize({ dialect: 'sqlite', storage: './db.sqlite' });\r\n\r\nconst umzug = new Umzug({\r\n  migrations: { glob: 'migrations/*.ts' },\r\n  context: sequelize.getQueryInterface(),\r\n  storage: new SequelizeStorage({ sequelize }),\r\n  logger: console,\r\n});\r\n\r\n// export the type helper exposed by umzug, which will have the `context` argument typed correctly\r\nexport type Migration = typeof umzug._types.migration;\r\n\r\n(async () => {\r\n  await umzug.up();\r\n})();\r\n```\r\n\r\n```typescript\r\n// migrations/00_initial.ts\r\nimport type { Migration } from '..';\r\n\r\n// types will now be available for `queryInterface`\r\nexport const up: Migration = ({ context: queryInterface }) => queryInterface.createTable(...)\r\nexport const down: Migration = ({ context: queryInterface }) => queryInterface.dropTable(...)\r\n```\r\n</details>\r\n\r\nSee [these tests](./test/umzug.test.ts) for more examples of Umzug usage, including:\r\n\r\n- passing `ignore` and `cwd` parameters to the glob instructions\r\n- customising migrations ordering\r\n- finding migrations from multiple different directories\r\n- using non-js file extensions via a custom resolver, e.g. `.sql`\r\n\r\n### Usage\r\n\r\n#### Installation\r\n\r\nThe beta version of Umzug is available on npm by specifying the correct tag:\r\n\r\n```bash\r\nnpm install umzug@beta\r\n```\r\n\r\n#### Umzug instance\r\n\r\nIt is possible to configure an Umzug instance by passing an object to the constructor.\r\n\r\n```js\r\nconst { Umzug } = require('umzug');\r\nconst umzug = new Umzug({ /* ... options ... */ });\r\n```\r\n\r\nDetailed documentation for these options are in the `UmzugOptions` TypeScript interface, which can be found in [src/types.ts](./src/types.ts).\r\n\r\n#### Getting all pending migrations\r\n\r\nYou can get a list of pending (i.e. not yet executed) migrations with the `pending()` method:\r\n\r\n```js\r\nconst migrations = await umzug.pending();\r\n// returns an array of all pending migrations.\r\n```\r\n\r\n#### Getting all executed migrations\r\n\r\nYou can get a list of already executed migrations with the `executed()` method:\r\n\r\n```js\r\nconst migrations = await umzug.executed();\r\n// returns an array of all already executed migrations\r\n```\r\n\r\n#### Executing pending migrations\r\n\r\nThe `up` method can be used to execute all pending migrations.\r\n\r\n```js\r\nconst migrations = await umzug.up();\r\n// returns an array of all executed migrations\r\n```\r\n\r\nIt is also possible to pass the name of a migration in order to just run the migrations from the current state to the passed migration name (inclusive).\r\n\r\n```js\r\nawait umzug.up({ to: '20141101203500-task' });\r\n```\r\n\r\nTo limit the number of migrations that are run, `step` can be used:\r\n\r\n```js\r\n// This will run the next two migrations\r\nawait umzug.up({ step: 2 })\r\n```\r\n\r\nRunning specific migrations while ignoring the right order, can be done like this:\r\n\r\n```js\r\nawait umzug.up({ migrations: ['20141101203500-task', '20141101203501-task-2'] });\r\n```\r\n\r\n#### Reverting executed migration\r\n\r\nThe `down` method can be used to revert the last executed migration.\r\n\r\n```js\r\nconst migration = await umzug.down();\r\n// reverts the last migration and returns it.\r\n```\r\n\r\nTo revert more than one migration, you can use `step`:\r\n\r\n```js\r\n// This will revert the last two migrations\r\nawait umzug.down({ step: 2 });\r\n```\r\n\r\nIt is possible to pass the name of a migration until which (inclusive) the migrations should be reverted. This allows the reverting of multiple migrations at once.\r\n\r\n```js\r\nconst migrations = await umzug.down({ to: '20141031080000-task' });\r\n// returns an array of all reverted migrations.\r\n```\r\n\r\nTo revert all migrations, you can pass 0 as the `to` parameter:\r\n\r\n```js\r\nawait umzug.down({ to: 0 });\r\n```\r\n\r\nReverting specific migrations while ignoring the right order, can be done like this:\r\n\r\n```js\r\nawait umzug.down({ migrations: ['20141101203500-task', '20141101203501-task-2'] });\r\n```\r\n\r\n### Migrations\r\n\r\nThere are two ways to specify migrations: via files or directly via an array of migrations.\r\n\r\n#### Migration files\r\n\r\nA migration file ideally exposes an `up` and a `down` async functions. They will perform the task of upgrading or downgrading the database.\r\n\r\n```js\r\nmodule.exports = {\r\n  async up() {\r\n    /* ... */\r\n  },\r\n  async down() {\r\n    /* ... */\r\n  }\r\n};\r\n```\r\n\r\nMigration files can be located anywhere - they will typically be loaded according to a glob pattern provided to the `Umzug` constructor.\r\n\r\n#### Direct migrations list\r\n\r\nYou can also specify directly a list of migrations to the `Umzug` constructor:\r\n\r\n```js\r\nconst { Umzug } = require('umzug');\r\n\r\nconst umzug = new Umzug({\r\n  migrations: [\r\n    {\r\n      // the name of the migration is mandatory\r\n      name: '00-first-migration',\r\n      async up({ context }) { /* ... */ },\r\n      async down({ context }) { /* ... */ }\r\n    },\r\n    {\r\n      name: '01-foo-bar-migration',\r\n      async up({ context }) { /* ... */ },\r\n      async down({ context }) { /* ... */ }\r\n    }\r\n  ],\r\n  context: sequelize.getQueryInterface(),\r\n  logger: console,\r\n});\r\n```\r\n\r\nTo load migrations in another format, you can use the `resolve` function:\r\n\r\n```js\r\nconst { Umzug } = require('umzug')\r\nconst { Sequelize } = require('sequelize')\r\nconst fs = require('fs')\r\n\r\nconst umzug = new Umzug({\r\n  migrations: {\r\n    glob: 'migrations/*.up.sql',\r\n    resolve: ({ name, path, context: sequelize }) => ({\r\n      name,\r\n      up: async () => {\r\n        const sql = fs.readFileSync(path).toString()\r\n        return sequelize.query(sql)\r\n      },\r\n      down: async () => {\r\n        // Get the corresponding `.down.sql` file to undo this migration\r\n        const sql = fs.readFileSync(path.replace('.up.sql', '.down.sql')).toString()\r\n        return sequelize.query(sql)\r\n      }\r\n    })\r\n  },\r\n  context: new Sequelize(...),\r\n  logger: console,\r\n});\r\n```\r\n\r\nYou can support mixed migration file types, and use umzug's default resolver for javascript/typescript:\r\n\r\n```js\r\nconst { Umzug } = require('umzug')\r\nconst { Sequelize } = require('sequelize')\r\nconst fs = require('fs')\r\n\r\nconst umzug = new Umzug({\r\n  migrations: {\r\n    glob: 'migrations/*.{js,ts,up.sql}',\r\n    resolve: (params) => {\r\n      if (!params.path.endsWith('.sql')) {\r\n        return Umzug.defaultResolver(params)\r\n      }\r\n      const { context: sequelize } = params\r\n      return {\r\n        name: params.name,\r\n        up: async () => {\r\n          const sql = fs.readFileSync(params.path).toString()\r\n          return sequelize.query(sql)\r\n        },\r\n        down: async () => {\r\n          // Get the corresponding `.down.sql` file to undo this migration\r\n          const sql = fs.readFileSync(params.path.replace('.up.sql', '.down.sql')).toString()\r\n          return sequelize.query(sql)\r\n        }\r\n      }\r\n    },\r\n  },\r\n  logger: console,\r\n  context: new Sequelize(...),\r\n});\r\n```\r\n\r\nThe glob syntax allows loading migrations from multiple locations:\r\n\r\n```js\r\nconst { Umzug } = require('umzug')\r\nconst { Sequelize } = require('sequelize')\r\n\r\nconst umzug = new Umzug({\r\n  migrations: {\r\n    glob: '{first-folder/*.js,second-folder-with-different-naming-convention/*.js}',\r\n  },\r\n  context: new Sequelize(...),\r\n  logger: console,\r\n});\r\n```\r\n\r\nNote on migration file sorting:\r\n\r\n- file matches, found using [glob](https://npmjs.com/package/glob), will be lexicographically sorted based on their paths\r\n  - so if your migrations are `one/m1.js`, `two/m2.js`, `three/m3.js`, the resultant order will be `one/m1.js`, `three/m3.js`, `two/m2.js`\r\n  - similarly, if your migrations are called `m1.js`, `m2.js`, ... `m10.js`, `m11.js`, the resultant ordering will be `m1.js`, `m10.js`, `m11.js`, ... `m2.js`\r\n- The easiest way to deal with this is to ensure your migrations appear in a single folder, and their paths match lexicographically with the order they should run in\r\n- If this isn't possible, the ordering can be customised using `.extend(...)` (see below)\r\n\r\n### Upgrading from v2.x\r\n\r\nThe Umzug class should be imported as a named import, i.e. `import { Umzug } from 'umzug'`.\r\n\r\nThe `MigrationMeta` type, which is returned by `umzug.executed()` and `umzug.pending()`, no longer has a `file` property - it has a `name` and *optional* `path` - since migrations are not necessarily bound to files on the file system.\r\n\r\nThe `migrations.glob` parameter replaces `path`, `pattern` and `traverseDirectories`. It can be used, in combination with `cwd` and `ignore` to do much more flexible file lookups. See https://npmjs.com/package/glob for more information on the syntax.\r\n\r\nThe `migrations.resolve` parameter replaces `customResolver`. Explicit support for `wrap` and `nameFormatter` has been removed - these can be easily implemented in a `resolve` function.\r\n\r\nThe constructor option `logging` is replaced by `logger` to allow for `warn` and `error` messages in future. NodeJS's global `console` object can be passed to this. To disable logging, replace `logging: false` with `logger: undefined`.\r\n\r\nEvents have moved from the default nodejs `EventEmitter` to [emittery](https://www.npmjs.com/package/emittery). It has better design for async code, a less bloated API surface and strong types. But, it doesn't allow passing multiple arguments to callbacks, so listeners have to change slightly, as well as `.addListener(...)` and `.removeListener(...)` no longer being supported (`.on(...)` and `.off(...)` should now be used):\r\n\r\nBefore:\r\n\r\n```js\r\numzug.on('migrating', (name, m) => console.log({ name, path: m.path }))\r\n```\r\n\r\nAfter:\r\n\r\n```js\r\numzug.on('migrating', ev => console.log({ name: ev.name, path: ev.path }))\r\n```\r\n\r\nThe `Umzug#execute` method is removed. Use `Umzug#up` or `Umzug#down`.\r\n\r\nThe options for `Umguz#up` and `Umzug#down` have changed:\r\n- `umzug.up({ to: 'some-name' })` and `umzug.down({ to: 'some-name' })` are still valid.\r\n- `umzug.up({ from: '...' })` and `umzug.down({ from: '...' })` are no longer supported. To run migrations out-of-order (which is not generally recommended), you can explicitly use `umzug.up({ migrations: ['...'] })` and `umzug.down({ migrations: ['...'] })`.\r\n- name matches must be exact. `umzug.up({ to: 'some-n' })` will no longer match a migration called `some-name`.\r\n- `umzug.down({ to: 0 })` is still valid but `umzug.up({ to: 0 })` is not.\r\n- `umzug.up({ migrations: ['m1', 'm2'] })` is still valid but the shorthand `umzug.up(['m1', 'm2'])` has been removed.\r\n- `umzug.down({ migrations: ['m1', 'm2'] })` is still valid but the shorthand `umzug.down(['m1', 'm2'])` has been removed.\r\n- `umzug.up({ migrations: ['m1', 'already-run'] })` will throw an error, if `already-run` is not found in the list of pending migrations.\r\n- `umzug.down({ migrations: ['m1', 'has-not-been-run'] })` will throw an error, if `has-not-been-run` is not found in the list of executed migrations.\r\n- `umzug.up({ migrations: ['m1', 'm2'], rerun: 'ALLOW' })` will re-apply migrations `m1` and `m2` even if they've already been run.\r\n- `umzug.up({ migrations: ['m1', 'm2'], rerun: 'SKIP' })` will skip migrations `m1` and `m2` if they've already been run.\r\n- `umzug.down({ migrations: ['m1', 'm2'], rerun: 'ALLOW' })` will \"revert\" migrations `m1` and `m2` even if they've never been run.\r\n- `umzug.down({ migrations: ['m1', 'm2'], rerun: 'SKIP' })` will skip reverting migrations `m1` and `m2` if they haven't been run or are already reverted.\r\n- `umzug.up({ migrations: ['m1', 'does-not-exist', 'm2'] })` will throw an error if the migration name is not found. Note that the error will be thrown and no migrations run unless _all_ migration names are found - whether or not `rerun: 'ALLOW'` is added.\r\n\r\nThe `context` parameter replaces `params`, and is passed in as a property to migration functions as an options object, alongs side `name` and `path`. This means the signature for migrations, which in v2 was `(context) => Promise<void>`, has changed slightly in v3, to `({ name, path, context }) => Promise<void>`. The `resolve` function can also be used to upgrade your umzug version to v3 when you have existing v2-compatible migrations:\r\n\r\n```js\r\nconst { Umzug } = require('umzug');\r\n\r\nconst umzug = new Umzug({\r\n  migrations: {\r\n    glob: 'migrations/umzug-v2-format/*.js',\r\n    resolve: ({name, path, context}) => {\r\n      // Adjust the migration from the new signature to the v2 signature, making easier to upgrade to v3\r\n      const migration = require(path)\r\n      return { name, up: async () => migration.up(context), down: async () => migration.down(context) }\r\n    }\r\n  },\r\n  context: sequelize.getQueryInterface(),\r\n  logger: console,\r\n});\r\n```\r\n\r\nSimilarly, you no longer need `migrationSorting`, you can use `Umzug#extend` to manipulate migration lists directly:\r\n\r\n```js\r\nconst { Umzug } = require('umzug');\r\n\r\nconst umzug =\r\n  new Umzug({\r\n    migrations: { glob: 'migrations/**/*.js' },\r\n    context: sequelize.getQueryInterface(),\r\n  })\r\n  .extend(migrations => migrations.sort((a, b) => b.path.localeCompare(a.path)));\r\n```\r\n\r\n### Storages\r\n\r\nStorages define where the migration data is stored.\r\n\r\n#### JSON Storage\r\n\r\nUsing `JSONStorage` will create a JSON file which will contain an array with all the executed migrations. You can specify the path to the file. The default for that is `umzug.json` in the working directory of the process.\r\n\r\nDetailed documentation for the options it can take are in the `JSONStorageConstructorOptions` TypeScript interface, which can be found in [src/storage/json.ts](./src/storage/json.ts).\r\n\r\n#### Memory Storage\r\n\r\nUsing `memoryStorage` will store migrations with an in-memory array. This can be useful for proof-of-concepts or tests, since it doesn't interact with databases or filesystems.\r\n\r\nIt doesn't take any options, just import the `memoryStorage` function and call it to return a storage instance:\r\n\r\n```typescript\r\nimport { Umzug, memoryStorage } from 'umzug'\r\n\r\nconst umzug = new Umzug({\r\n  migrations: ...,\r\n  storage: memoryStorage(),\r\n  logger: console,\r\n})\r\n```\r\n\r\n#### Sequelize Storage\r\n\r\nUsing `SequelizeStorage` will create a table in your SQL database called `SequelizeMeta` containing an entry for each executed migration. You will have to pass a configured instance of Sequelize or an existing Sequelize model. Optionally you can specify the model name, table name, or column name. All major Sequelize versions are supported.\r\n\r\nDetailed documentation for the options it can take are in the `_SequelizeStorageConstructorOptions` TypeScript interface, which can be found in [src/storage/sequelize.ts](./src/storage/sequelize.ts).\r\n\r\n#### MongoDB Storage\r\n\r\nUsing `MongoDBStorage` will create a collection in your MongoDB database called `migrations` containing an entry for each executed migration. You will have either to pass a MongoDB Driver Collection as `collection` property. Alternatively you can pass a established MongoDB Driver connection and a collection name.\r\n\r\nDetailed documentation for the options it can take are in the `MongoDBStorageConstructorOptions` TypeScript interface, which can be found in [src/storage/mongodb.ts](./src/storage/mongodb.ts).\r\n\r\n#### Custom\r\n\r\nIn order to use a custom storage, you can pass your storage instance to Umzug constructor.\r\n\r\n```js\r\nclass CustomStorage {\r\n  constructor(...) {...}\r\n  logMigration(...) {...}\r\n  unlogMigration(...) {...}\r\n  executed(...) {...}\r\n}\r\n\r\nconst umzug = new Umzug({ storage: new CustomStorage(...), logger: console })\r\n```\r\n\r\nYour instance must adhere to the [UmzugStorage](./src/storage/contract.ts) interface. If you're using TypeScript you can ensure this at compile time, and get IDE type hints by importing it:\r\n\r\n```typescript\r\nimport { UmzugStorage } from 'umzug'\r\n\r\nclass CustomStorage implements UmzugStorage {\r\n  /* ... */\r\n}\r\n```\r\n\r\n### Events\r\n\r\nUmzug is an [emittery event emitter](https://www.npmjs.com/package/emittery). Each of the following events will be called with migration parameters as its payload (with `context`, `name`, and nullable `path` properties). Events are a convenient place to implement application-specific logic that must run around each migration:\r\n\r\n* `migrating` - A migration is about to be executed.\r\n* `migrated` - A migration has successfully been executed.\r\n* `reverting` - A migration is about to be reverted.\r\n* `reverted` - A migration has successfully been reverted.\r\n\r\nThese events run at the beginning and end of `up` and `down` calls. They'll receive an object containing a `context` property:\r\n\r\n- `beforeCommand` - Before any command (`'up' | 'down' | 'executed' | 'pending'`) is run.\r\n- `afterCommand` - After any command (`'up' | 'down' | 'executed' | 'pending'`) is run. Note: this will always run, even if the command throws an error.\r\n\r\nThe [`FileLocker` class](./src/file-locker.ts) uses `beforeAll` and `afterAll` to implement a simple filesystem-based locking mechanism.\r\n\r\nAll events are type-safe, so IDEs will prevent typos and supply strong types for the event payloads.\r\n\r\n### Errors\r\n\r\nWhen a migration throws an error, it will be wrapped in a `MigrationError` which captures the migration metadata (name, path etc.) as well as the original error message, and _will be rethrown_. In most cases, this is expected behaviour, and doesn't require any special handling beyond standard error logging setups.\r\n\r\nIf you expect failures and want to try to recover from them, you will need to try-catch the call to `umzug.up()`. You can access the original error from the `.cause` property if necessary:\r\n\r\n```js\r\ntry {\r\n  await umzug.up();\r\n} catch (e) {\r\n  if (e instanceof MigrationError) {\r\n    const original = e.cause;\r\n    // do something with the original error here\r\n  }\r\n  throw e;\r\n}\r\n```\r\n\r\nUnder the hood, [verror](https://npmjs.com/package/verror) is used to wrap errors.\r\n\r\n### CLI\r\n\r\n🚧🚧🚧 The CLI is new to Umzug v3 beta and is not yet stable. Feedback on it is welcome in [discussions](https://github.com/sequelize/umzug/discussions) 🚧🚧🚧\r\n\r\nUmzug instances provide a `.runAsCLI()` method. When called, this method will automatically cause your program to become a complete CLI, with help text and such:\r\n\r\n```js\r\n// migrator.js\r\nconst { Umzug } = require('umzug')\r\n\r\nexports.umzug = new Umzug({ ... })\r\n\r\nif (require.main === module) {\r\n  umzug.runAsCLI()\r\n}\r\n```\r\n\r\n#### CLI Usage\r\n\r\nA script like the one above is now a runnable CLI program. You can run `node migrator.js --help` to see how to use it. It will print something like:\r\n\r\n<!-- codegen:start {preset: custom, source: ./codegen.js, export: cliHelp} -->\r\n```\r\nusage: <script> [-h] <command> ...\r\n\r\nUmzug migrator\r\n\r\nPositional arguments:\r\n  <command>\r\n    up        Applies pending migrations\r\n    down      Revert migrations\r\n    pending   Lists pending migrations\r\n    executed  Lists executed migrations\r\n    create    Create a migration file\r\n\r\nOptional arguments:\r\n  -h, --help  Show this help message and exit.\r\n\r\nFor detailed help about a specific command, use: <script> <command> -h\r\n```\r\n<!-- codegen:end -->\r\n\r\n#### Running migrations\r\n\r\n`node migrator up` and `node migrator down` apply and revert migrations respectively. They're the equivalent of the `.up()` and `.down()` methods.\r\n\r\nUse `node migrator up --help` and `node migrator down --help` for options (running \"to\" a specific migration, passing migration names to be run explicitly, and specifying the rerun behavior):\r\n\r\nUp:\r\n<!-- codegen:start {preset: custom, source: ./codegen.js, export: cliHelp, action: up} -->\r\n```\r\nusage: <script> up [-h] [--to NAME] [--step COUNT] [--name MIGRATION]\r\n                   [--rerun {THROW,SKIP,ALLOW}]\r\n                   \r\n\r\nPerforms all migrations. See --help for more options\r\n\r\nOptional arguments:\r\n  -h, --help            Show this help message and exit.\r\n  --to NAME             All migrations up to and including this one should be \r\n                        applied.\r\n  --step COUNT          Run this many migrations. If not specified, all will \r\n                        be applied.\r\n  --name MIGRATION      Explicity declare migration name(s) to be applied.\r\n  --rerun {THROW,SKIP,ALLOW}\r\n                        Specify what action should be taken when a migration \r\n                        that has already been applied is passed to --name. \r\n                        The default value is \"THROW\".\r\n```\r\n<!-- codegen:end -->\r\n\r\nDown:\r\n<!-- codegen:start {preset: custom, source: ./codegen.js, export: cliHelp, action: down} -->\r\n```\r\nusage: <script> down [-h] [--to NAME] [--step COUNT] [--name MIGRATION]\r\n                     [--rerun {THROW,SKIP,ALLOW}]\r\n                     \r\n\r\nUndoes previously-applied migrations. By default, undoes the most recent \r\nmigration only. Use --help for more options. Useful in development to start \r\nfrom a clean slate. Use with care in production!\r\n\r\nOptional arguments:\r\n  -h, --help            Show this help message and exit.\r\n  --to NAME             All migrations up to and including this one should be \r\n                        reverted. Pass \"0\" to revert all.\r\n  --step COUNT          Run this many migrations. If not specified, one will \r\n                        be reverted.\r\n  --name MIGRATION      Explicity declare migration name(s) to be reverted.\r\n  --rerun {THROW,SKIP,ALLOW}\r\n                        Specify what action should be taken when a migration \r\n                        that has already been reverted is passed to --name. \r\n                        The default value is \"THROW\".\r\n```\r\n<!-- codegen:end -->\r\n\r\n\r\n#### Listing migrations\r\n\r\n```bash\r\nnode migrator pending # list migrations yet to be run\r\nnode migrator executed # list migrations that have already run\r\n\r\nnode migrator pending --json # list pending migrations including names and paths, in a json array format\r\nnode migrator executed --json # list executed migrations including names and paths, in a json array format\r\n\r\nnode migrator pending --help # show help/options\r\nnode migrator executed --help # show help/options\r\n```\r\n\r\n<!-- codegen:start {preset: custom, source: ./codegen.js, export: cliHelp, action: pending} -->\r\n```\r\nusage: <script> pending [-h] [--json]\r\n\r\nPrints migrations returned by `umzug.pending()`. By default, prints migration \r\nnames one per line.\r\n\r\nOptional arguments:\r\n  -h, --help  Show this help message and exit.\r\n  --json      Print pending migrations in a json format including names and \r\n              paths. This allows piping output to tools like jq. Without this \r\n              flag, the migration names will be printed one per line.\r\n```\r\n<!-- codegen:end -->\r\n\r\n<!-- codegen:start {preset: custom, source: ./codegen.js, export: cliHelp, action: executed} -->\r\n```\r\nusage: <script> executed [-h] [--json]\r\n\r\nPrints migrations returned by `umzug.executed()`. By default, prints \r\nmigration names one per line.\r\n\r\nOptional arguments:\r\n  -h, --help  Show this help message and exit.\r\n  --json      Print executed migrations in a json format including names and \r\n              paths. This allows piping output to tools like jq. Without this \r\n              flag, the migration names will be printed one per line.\r\n```\r\n<!-- codegen:end -->\r\n\r\n#### Creating migrations - CLI\r\n\r\nUsually, migrations correspond to files on the filesystem. The CLI exposes a way to create migration files easily:\r\n\r\n```bash\r\nnode migrator create --name my-migration.js\r\n```\r\n\r\nThis will create a file with a name like `2000.12.25T12.34.56.my-migration.js` in the same directory as the most recent migration file. If it's the very first migration file, you need to specify the folder explicitly:\r\n\r\n```bash\r\nnode migrator create --name my-migration.js --folder path/to/directory\r\n```\r\n\r\nThe timestamp prefix can be customized to be date-only or omitted, but be aware that it's strongly recommended to ensure your migrations are lexicographically sortable so it's easy for humans and tools to determine what order they should run in - so the default prefix is recommended.\r\n\r\nThis will generate a migration file called `<<timestamp>>.my-migration.js` with the default migration template for `.js` files that ships with Umzug.\r\n\r\nUmzug also ships with default templates for [`.ts`, `.cjs`, `.mjs` and `.sql` files](./src/templates.ts). Umzug will choose the template based on the extension you provide in `name`.\r\n\r\nYou can specify a custom template for your project when constructing an umzug instance via the `template` option. It should be a function which receives a filepath string, and returns an array of `[filepath, content]` pairs. Usually, just one pair is needed, but a second could be used to include a \"down\" migration in a separate file:\r\n\r\n```js\r\nconst umzug = new Umzug({\r\n  migrations: ...,\r\n  template: filepath => [\r\n    [filepath, fs.readFileSync('path/to/your/template/file').toString()],\r\n  ]\r\n})\r\n```\r\n\r\nThe create command includes some safety checks to make sure migrations aren't created with ambiguous ordering, and that they will be picked up by umzug when applying migrations.\r\n\r\nUse `node migrator create --help` for more options:\r\n\r\n<!-- codegen:start {preset: custom, source: ./codegen.js, export: cliHelp, action: create} -->\r\n```\r\nusage: <script> create [-h] --name NAME [--prefix {TIMESTAMP,DATE,NONE}]\r\n                       [--folder PATH] [--allow-extension EXTENSION]\r\n                       [--skip-verify] [--allow-confusing-ordering]\r\n                       \r\n\r\nGenerates a placeholder migration file using a timestamp as a prefix. By \r\ndefault, mimics the last existing migration, or guesses where to generate the \r\nfile if no migration exists yet.\r\n\r\nOptional arguments:\r\n  -h, --help            Show this help message and exit.\r\n  --name NAME           The name of the migration file. e.g. my-migration.js, \r\n                        my-migration.ts or my-migration.sql. Note - a prefix \r\n                        will be added to this name, usually based on a \r\n                        timestamp. See --prefix\r\n  --prefix {TIMESTAMP,DATE,NONE}\r\n                        The prefix format for generated files. TIMESTAMP uses \r\n                        a second-resolution timestamp, DATE uses a \r\n                        day-resolution timestamp, and NONE removes the prefix \r\n                        completely. The default value is \"TIMESTAMP\".\r\n  --folder PATH         Path on the filesystem where the file should be \r\n                        created. The new migration will be created as a \r\n                        sibling of the last existing one if this is omitted.\r\n  --allow-extension EXTENSION\r\n                        Allowable extension for created files. By default .js,\r\n                         .ts and .sql files can be created. To create txt \r\n                        file migrations, for example, you could use '--name \r\n                        my-migration.txt --allow-extension .txt' This \r\n                        parameter may alternatively be specified via the \r\n                        UMZUG_ALLOW_EXTENSION environment variable.\r\n  --skip-verify         By default, the generated file will be checked after \r\n                        creation to make sure it is detected as a pending \r\n                        migration. This catches problems like creation in the \r\n                        wrong folder, or invalid naming conventions. This \r\n                        flag bypasses that verification step.\r\n  --allow-confusing-ordering\r\n                        By default, an error will be thrown if you try to \r\n                        create a migration that will run before a migration \r\n                        that already exists. This catches errors which can \r\n                        cause problems if you change file naming conventions. \r\n                        If you use a custom ordering system, you can disable \r\n                        this behavior, but it's strongly recommended that you \r\n                        don't! If you're unsure, just ignore this option.\r\n```\r\n<!-- codegen:end -->\r\n\r\n### Creating migrations - API\r\n\r\nUmzug includes an optional helper for generating migration files. It's often most convenient to create files using the [CLI helper](#creating-migrations---cli), but the equivalent API also exists on an umzug instance:\r\n\r\n```js\r\nawait umzug.create({ name: 'my-new-migration.js' })\r\n```\r\n\r\n## License\r\n\r\nSee the [LICENSE file](./LICENSE)\r\n","readmeFilename":"README.md","gitHead":"a1fc011c1ab5ec6a6cdbb3ead3b29f0ddd86cb4e","_id":"umzug@3.0.0-beta.15","_nodeVersion":"12.18.0","_npmVersion":"6.14.8","dist":{"integrity":"sha512-8u3SoFP8CPvzoVHptSpF38wTu0nxTjW8XYD8VI5WvFHA3hYwZsXZoquSIpY6HZo8tF2WHF+aRhb6lqfIpnRdow==","shasum":"56f9223f1b480bbfc6fe73b7cf3581256907229f","tarball":"https://registry.npmjs.org/umzug/-/umzug-3.0.0-beta.15.tgz","fileCount":40,"unpackedSize":131488,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJgIFz/CRA9TVsSAnZWagAAWPYP/0ZeSW0Agyum4ENYXu/F\njKPDHhlJGKyOXa+sp9YaD3KWzLMCcgsf3YKhCOwk0PuINYK+xxi1nTiR2kCA\ncdKPhhpE47Ell9t/BsjGnrrQJFx93IHTiio9ZcPUJft7Yns5Befh1TLzSZ1f\nk5nIaDHpaulUk5bxHVCTmNVq9T6D6XHby9sZ8qQCnrTQPcSARHw3UiL8ZDjO\nxJ8KJmH2Wm2hYmByb9vh60zM10Dlqz9NFtM30sqVTYm2JaOXYv//T5zR/gGE\n6+dz0gMMSlw7rSQXorU3/eQvGlvJ2vNKAD5RMTBVSDFuRQ5c37oFNhu9CoAM\n8gQaoIIHjcXAuLvIanjXW6tktEx/4ZgSYa4RpSlWzQOpTeBNUCbwsmWr57Fy\n0DDIVJ9r0f8LXTt+/QsEU4458qajkYcjNzR5rG2/Zycu6XIB/vMq3uaLZcEb\n5dQaeYUwgNbPL7V4/YvIijl5dOvFoOdlVb5/Uijm8EOXhxrTEIv+Uvv4lZov\nR12G3xSLJ1uu8GWL856CXwuIblIoRu3RwjOqOuu7/WHk4qgTuEUL17ZjHSxJ\nz4zSodk16GOvW1uO5FMpWapuTAvoGBMNXD/3e2MungIM7UTLsGUrxP8tRM/C\nvXeW12U+8dtEYVKm+XmREtNK+Sn9oLx76kKgXtXbyvqPsIaFgNNY2h0ykYgs\npjJm\r\n=xxG1\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIQDJqchD207+5ykkIdIWrsTR/QEPaCdCs301SCii/srs3gIgGX+ZLvUFPPyrDow87PbPuy7J+hh6BVUjLpLbVUS4eFs="}]},"_npmUser":{"name":"mmkale","email":"mmkal1@outlook.com"},"directories":{},"maintainers":[{"name":"pascal.pflaum","email":"mail@pascalpflaum.de"},{"name":"sdepold","email":"sascha@depold.com"},{"name":"sushantdhiman","email":"sushantdhiman@outlook.com"},{"name":"papb","email":"papb1996@gmail.com"},{"name":"mmkale","email":"mmkal1@outlook.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/umzug_3.0.0-beta.15_1612733694651_0.18186703590783337"},"_hasShrinkwrap":false},"3.0.0-beta.16":{"name":"umzug","version":"3.0.0-beta.16","description":"Framework-agnostic migration tool for Node","keywords":["migrate","migration","migrations","sequelize","database"],"main":"lib/index.js","dependencies":{"@rushstack/ts-command-line":"^4.7.7","@types/verror":"^1.10.4","emittery":"^0.8.1","fs-jetpack":"^4.1.0","glob":"^7.1.6","type-fest":"^1.0.0","verror":"^1.10.0"},"devDependencies":{"@types/jest":"26.0.20","@types/lodash":"4.14.168","@types/uuid":"8.3.0","@typescript-eslint/eslint-plugin":"4.15.0","@typescript-eslint/parser":"4.15.0","del-cli":"3.0.1","eslint":"7.20.0","eslint-config-xo":"0.34.0","eslint-config-xo-typescript":"0.37.0","eslint-plugin-codegen":"0.15.0","eslint-plugin-import":"2.22.1","eslint-plugin-jest":"24.1.3","eslint-plugin-mocha":"8.0.0","eslint-plugin-prettier":"3.3.1","eslint-plugin-unicorn":"24.0.0","expect-type":"0.11.0","fs-syncer":"0.3.4","jest":"26.6.3","lodash":"4.17.21","np":"7.4.0","prettier":"2.2.1","sequelize":"5.22.3","sinon":"9.2.4","source-map-support":"0.5.19","sqlite3":"5.0.1","strip-ansi":"6.0.0","ts-jest":"26.5.1","ts-node":"9.1.1","typescript":"4.1.5","uuid":"8.3.2"},"scripts":{"build":"del-cli lib && tsc -p tsconfig.lib.json","eslint":"eslint --ext .js,.ts,.md . --max-warnings 0","lint":"npm run type-check && npm run eslint","prepare":"npm run build","release":"np --no-yarn --no-2fa","pretest":"del-cli test/generated","test":"jest","type-check":"tsc -p ."},"repository":{"type":"git","url":"git+https://github.com/sequelize/umzug.git"},"author":{"name":"Sascha Depold","email":"sascha@depold.com"},"contributors":[{"name":"Jukka Hyytiälä","email":"hyytiala.jukka@gmail.com"},{"name":"Pascal Pflaum","email":"mail@pascalpflaum.de"},{"name":"Pedro Augusto de Paula Barbosa","email":"papb1996@gmail.com"}],"license":"MIT","bugs":{"url":"https://github.com/sequelize/umzug/issues"},"homepage":"https://github.com/sequelize/umzug","engines":{"node":">=10.0.0"},"jest":{"preset":"ts-jest","globals":{"ts-jest":{"diagnostics":false}},"testEnvironment":"node","testMatch":["**/*test.ts"],"collectCoverageFrom":["src/**"]},"readme":"# Umzug\r\n\r\n[![Build Status](https://badgen.net/github/checks/sequelize/umzug/master)](https://github.com/sequelize/umzug/actions?query=workflow%3ACI)\r\n[![npm (stable)](https://badgen.net/npm/v/umzug)](https://www.npmjs.com/package/umzug)\r\n[![npm (beta)](https://badgen.net/npm/v/umzug/beta)](https://www.npmjs.com/package/umzug/v/beta)\r\n[![npm (downloads)](https://badgen.net/npm/dm/umzug)](https://npmjs.com/package/umzug)\r\n\r\nUmzug is a framework-agnostic migration tool for Node. It provides a clean API for running and rolling back tasks.\r\n\r\n_Note: master represents the next major version of umzug - v3 - which is currently in beta. For the stable version, please refer to the [v2.x branch](https://github.com/sequelize/umzug/tree/v2.x)._\r\n\r\nTo install the v3-beta package:\r\n\r\n```\r\nnpm install umzug@beta\r\n```\r\n\r\nTo install the stable package (v2.x):\r\n\r\n```\r\nnpm install umzug\r\n```\r\n\r\n## Highlights\r\n\r\n* Written in TypeScript\r\n\t* Built-in typings\r\n\t* Auto-completion right in your IDE\r\n\t* Documentation right in your IDE\r\n* Programmatic API for migrations\r\n* Built-in [CLI](#cli)\r\n* Database agnostic\r\n* Supports logging of migration process\r\n* Supports multiple storages for migration data\r\n* [Usage examples](./examples)\r\n\r\n## Documentation\r\n\r\n### Minimal Example\r\n\r\nThe following example uses a Sqlite database through sequelize and persists the migration data in the database itself through the sequelize storage. There are several more involved examples covering a few different scenarios in the [examples folder](./examples).\r\n\r\n```js\r\n// index.js\r\nconst { Sequelize } = require('sequelize');\r\nconst { Umzug, SequelizeStorage } = require('umzug');\r\n\r\nconst sequelize = new Sequelize({ dialect: 'sqlite', storage: './db.sqlite' });\r\n\r\nconst umzug = new Umzug({\r\n  migrations: { glob: 'migrations/*.js' },\r\n  context: sequelize.getQueryInterface(),\r\n  storage: new SequelizeStorage({ sequelize }),\r\n  logger: console,\r\n});\r\n\r\n(async () => {\r\n  // Checks migrations and run them if they are not already applied. To keep\r\n  // track of the executed migrations, a table (and sequelize model) called SequelizeMeta\r\n  // will be automatically created (if it doesn't exist already) and parsed.\r\n  await umzug.up();\r\n})();\r\n```\r\n\r\n```js\r\n// migrations/00_initial.js\r\n\r\nconst { Sequelize } = require('sequelize');\r\n\r\nasync function up({ context: queryInterface }) {\r\n\tawait queryInterface.createTable('users', {\r\n\t\tid: {\r\n\t\t\ttype: Sequelize.INTEGER,\r\n\t\t\tallowNull: false,\r\n\t\t\tprimaryKey: true\r\n\t\t},\r\n\t\tname: {\r\n\t\t\ttype: Sequelize.STRING,\r\n\t\t\tallowNull: false\r\n\t\t},\r\n\t\tcreatedAt: {\r\n\t\t\ttype: Sequelize.DATE,\r\n\t\t\tallowNull: false\r\n\t\t},\r\n\t\tupdatedAt: {\r\n\t\t\ttype: Sequelize.DATE,\r\n\t\t\tallowNull: false\r\n\t\t}\r\n\t});\r\n}\r\n\r\nasync function down({ context: queryInterface }) {\r\n\tawait queryInterface.dropTable('users');\r\n}\r\n\r\nmodule.exports = { up, down };\r\n```\r\n\r\nNote that we renamed the `context` argument to `queryInterface` for clarity. The `context` is whatever we specified when creating the Umzug instance in `index.js`.\r\n\r\n<details>\r\n<summary>You can also write your migrations in typescript by using `ts-node` in the entrypoint:</summary>\r\n\r\n```typescript\r\n// index.ts\r\nrequire('ts-node/register')\r\n\r\nimport { Sequelize } from 'sequelize';\r\nimport { Umzug, SequelizeStorage } from 'umzug';\r\n\r\nconst sequelize = new Sequelize({ dialect: 'sqlite', storage: './db.sqlite' });\r\n\r\nconst umzug = new Umzug({\r\n  migrations: { glob: 'migrations/*.ts' },\r\n  context: sequelize.getQueryInterface(),\r\n  storage: new SequelizeStorage({ sequelize }),\r\n  logger: console,\r\n});\r\n\r\n// export the type helper exposed by umzug, which will have the `context` argument typed correctly\r\nexport type Migration = typeof umzug._types.migration;\r\n\r\n(async () => {\r\n  await umzug.up();\r\n})();\r\n```\r\n\r\n```typescript\r\n// migrations/00_initial.ts\r\nimport type { Migration } from '..';\r\n\r\n// types will now be available for `queryInterface`\r\nexport const up: Migration = ({ context: queryInterface }) => queryInterface.createTable(...)\r\nexport const down: Migration = ({ context: queryInterface }) => queryInterface.dropTable(...)\r\n```\r\n</details>\r\n\r\nSee [these tests](./test/umzug.test.ts) for more examples of Umzug usage, including:\r\n\r\n- passing `ignore` and `cwd` parameters to the glob instructions\r\n- customising migrations ordering\r\n- finding migrations from multiple different directories\r\n- using non-js file extensions via a custom resolver, e.g. `.sql`\r\n\r\n### Usage\r\n\r\n#### Installation\r\n\r\nThe beta version of Umzug is available on npm by specifying the correct tag:\r\n\r\n```bash\r\nnpm install umzug@beta\r\n```\r\n\r\n#### Umzug instance\r\n\r\nIt is possible to configure an Umzug instance by passing an object to the constructor.\r\n\r\n```js\r\nconst { Umzug } = require('umzug');\r\nconst umzug = new Umzug({ /* ... options ... */ });\r\n```\r\n\r\nDetailed documentation for these options are in the `UmzugOptions` TypeScript interface, which can be found in [src/types.ts](./src/types.ts).\r\n\r\n#### Getting all pending migrations\r\n\r\nYou can get a list of pending (i.e. not yet executed) migrations with the `pending()` method:\r\n\r\n```js\r\nconst migrations = await umzug.pending();\r\n// returns an array of all pending migrations.\r\n```\r\n\r\n#### Getting all executed migrations\r\n\r\nYou can get a list of already executed migrations with the `executed()` method:\r\n\r\n```js\r\nconst migrations = await umzug.executed();\r\n// returns an array of all already executed migrations\r\n```\r\n\r\n#### Executing pending migrations\r\n\r\nThe `up` method can be used to execute all pending migrations.\r\n\r\n```js\r\nconst migrations = await umzug.up();\r\n// returns an array of all executed migrations\r\n```\r\n\r\nIt is also possible to pass the name of a migration in order to just run the migrations from the current state to the passed migration name (inclusive).\r\n\r\n```js\r\nawait umzug.up({ to: '20141101203500-task' });\r\n```\r\n\r\nTo limit the number of migrations that are run, `step` can be used:\r\n\r\n```js\r\n// This will run the next two migrations\r\nawait umzug.up({ step: 2 })\r\n```\r\n\r\nRunning specific migrations while ignoring the right order, can be done like this:\r\n\r\n```js\r\nawait umzug.up({ migrations: ['20141101203500-task', '20141101203501-task-2'] });\r\n```\r\n\r\n#### Reverting executed migration\r\n\r\nThe `down` method can be used to revert the last executed migration.\r\n\r\n```js\r\nconst migration = await umzug.down();\r\n// reverts the last migration and returns it.\r\n```\r\n\r\nTo revert more than one migration, you can use `step`:\r\n\r\n```js\r\n// This will revert the last two migrations\r\nawait umzug.down({ step: 2 });\r\n```\r\n\r\nIt is possible to pass the name of a migration until which (inclusive) the migrations should be reverted. This allows the reverting of multiple migrations at once.\r\n\r\n```js\r\nconst migrations = await umzug.down({ to: '20141031080000-task' });\r\n// returns an array of all reverted migrations.\r\n```\r\n\r\nTo revert all migrations, you can pass 0 as the `to` parameter:\r\n\r\n```js\r\nawait umzug.down({ to: 0 });\r\n```\r\n\r\nReverting specific migrations while ignoring the right order, can be done like this:\r\n\r\n```js\r\nawait umzug.down({ migrations: ['20141101203500-task', '20141101203501-task-2'] });\r\n```\r\n\r\n### Migrations\r\n\r\nThere are two ways to specify migrations: via files or directly via an array of migrations.\r\n\r\n#### Migration files\r\n\r\nA migration file ideally exposes an `up` and a `down` async functions. They will perform the task of upgrading or downgrading the database.\r\n\r\n```js\r\nmodule.exports = {\r\n  async up() {\r\n    /* ... */\r\n  },\r\n  async down() {\r\n    /* ... */\r\n  }\r\n};\r\n```\r\n\r\nMigration files can be located anywhere - they will typically be loaded according to a glob pattern provided to the `Umzug` constructor.\r\n\r\n#### Direct migrations list\r\n\r\nYou can also specify directly a list of migrations to the `Umzug` constructor:\r\n\r\n```js\r\nconst { Umzug } = require('umzug');\r\n\r\nconst umzug = new Umzug({\r\n  migrations: [\r\n    {\r\n      // the name of the migration is mandatory\r\n      name: '00-first-migration',\r\n      async up({ context }) { /* ... */ },\r\n      async down({ context }) { /* ... */ }\r\n    },\r\n    {\r\n      name: '01-foo-bar-migration',\r\n      async up({ context }) { /* ... */ },\r\n      async down({ context }) { /* ... */ }\r\n    }\r\n  ],\r\n  context: sequelize.getQueryInterface(),\r\n  logger: console,\r\n});\r\n```\r\n\r\nTo load migrations in another format, you can use the `resolve` function:\r\n\r\n```js\r\nconst { Umzug } = require('umzug')\r\nconst { Sequelize } = require('sequelize')\r\nconst fs = require('fs')\r\n\r\nconst umzug = new Umzug({\r\n  migrations: {\r\n    glob: 'migrations/*.up.sql',\r\n    resolve: ({ name, path, context: sequelize }) => ({\r\n      name,\r\n      up: async () => {\r\n        const sql = fs.readFileSync(path).toString()\r\n        return sequelize.query(sql)\r\n      },\r\n      down: async () => {\r\n        // Get the corresponding `.down.sql` file to undo this migration\r\n        const sql = fs.readFileSync(path.replace('.up.sql', '.down.sql')).toString()\r\n        return sequelize.query(sql)\r\n      }\r\n    })\r\n  },\r\n  context: new Sequelize(...),\r\n  logger: console,\r\n});\r\n```\r\n\r\nYou can support mixed migration file types, and use umzug's default resolver for javascript/typescript:\r\n\r\n```js\r\nconst { Umzug } = require('umzug')\r\nconst { Sequelize } = require('sequelize')\r\nconst fs = require('fs')\r\n\r\nconst umzug = new Umzug({\r\n  migrations: {\r\n    glob: 'migrations/*.{js,ts,up.sql}',\r\n    resolve: (params) => {\r\n      if (!params.path.endsWith('.sql')) {\r\n        return Umzug.defaultResolver(params)\r\n      }\r\n      const { context: sequelize } = params\r\n      return {\r\n        name: params.name,\r\n        up: async () => {\r\n          const sql = fs.readFileSync(params.path).toString()\r\n          return sequelize.query(sql)\r\n        },\r\n        down: async () => {\r\n          // Get the corresponding `.down.sql` file to undo this migration\r\n          const sql = fs.readFileSync(params.path.replace('.up.sql', '.down.sql')).toString()\r\n          return sequelize.query(sql)\r\n        }\r\n      }\r\n    },\r\n  },\r\n  logger: console,\r\n  context: new Sequelize(...),\r\n});\r\n```\r\n\r\nThe glob syntax allows loading migrations from multiple locations:\r\n\r\n```js\r\nconst { Umzug } = require('umzug')\r\nconst { Sequelize } = require('sequelize')\r\n\r\nconst umzug = new Umzug({\r\n  migrations: {\r\n    glob: '{first-folder/*.js,second-folder-with-different-naming-convention/*.js}',\r\n  },\r\n  context: new Sequelize(...),\r\n  logger: console,\r\n});\r\n```\r\n\r\nNote on migration file sorting:\r\n\r\n- file matches, found using [glob](https://npmjs.com/package/glob), will be lexicographically sorted based on their paths\r\n  - so if your migrations are `one/m1.js`, `two/m2.js`, `three/m3.js`, the resultant order will be `one/m1.js`, `three/m3.js`, `two/m2.js`\r\n  - similarly, if your migrations are called `m1.js`, `m2.js`, ... `m10.js`, `m11.js`, the resultant ordering will be `m1.js`, `m10.js`, `m11.js`, ... `m2.js`\r\n- The easiest way to deal with this is to ensure your migrations appear in a single folder, and their paths match lexicographically with the order they should run in\r\n- If this isn't possible, the ordering can be customised using `.extend(...)` (see below)\r\n\r\n### Upgrading from v2.x\r\n\r\nThe Umzug class should be imported as a named import, i.e. `import { Umzug } from 'umzug'`.\r\n\r\nThe `MigrationMeta` type, which is returned by `umzug.executed()` and `umzug.pending()`, no longer has a `file` property - it has a `name` and *optional* `path` - since migrations are not necessarily bound to files on the file system.\r\n\r\nThe `migrations.glob` parameter replaces `path`, `pattern` and `traverseDirectories`. It can be used, in combination with `cwd` and `ignore` to do much more flexible file lookups. See https://npmjs.com/package/glob for more information on the syntax.\r\n\r\nThe `migrations.resolve` parameter replaces `customResolver`. Explicit support for `wrap` and `nameFormatter` has been removed - these can be easily implemented in a `resolve` function.\r\n\r\nThe constructor option `logging` is replaced by `logger` to allow for `warn` and `error` messages in future. NodeJS's global `console` object can be passed to this. To disable logging, replace `logging: false` with `logger: undefined`.\r\n\r\nEvents have moved from the default nodejs `EventEmitter` to [emittery](https://www.npmjs.com/package/emittery). It has better design for async code, a less bloated API surface and strong types. But, it doesn't allow passing multiple arguments to callbacks, so listeners have to change slightly, as well as `.addListener(...)` and `.removeListener(...)` no longer being supported (`.on(...)` and `.off(...)` should now be used):\r\n\r\nBefore:\r\n\r\n```js\r\numzug.on('migrating', (name, m) => console.log({ name, path: m.path }))\r\n```\r\n\r\nAfter:\r\n\r\n```js\r\numzug.on('migrating', ev => console.log({ name: ev.name, path: ev.path }))\r\n```\r\n\r\nThe `Umzug#execute` method is removed. Use `Umzug#up` or `Umzug#down`.\r\n\r\nThe options for `Umguz#up` and `Umzug#down` have changed:\r\n- `umzug.up({ to: 'some-name' })` and `umzug.down({ to: 'some-name' })` are still valid.\r\n- `umzug.up({ from: '...' })` and `umzug.down({ from: '...' })` are no longer supported. To run migrations out-of-order (which is not generally recommended), you can explicitly use `umzug.up({ migrations: ['...'] })` and `umzug.down({ migrations: ['...'] })`.\r\n- name matches must be exact. `umzug.up({ to: 'some-n' })` will no longer match a migration called `some-name`.\r\n- `umzug.down({ to: 0 })` is still valid but `umzug.up({ to: 0 })` is not.\r\n- `umzug.up({ migrations: ['m1', 'm2'] })` is still valid but the shorthand `umzug.up(['m1', 'm2'])` has been removed.\r\n- `umzug.down({ migrations: ['m1', 'm2'] })` is still valid but the shorthand `umzug.down(['m1', 'm2'])` has been removed.\r\n- `umzug.up({ migrations: ['m1', 'already-run'] })` will throw an error, if `already-run` is not found in the list of pending migrations.\r\n- `umzug.down({ migrations: ['m1', 'has-not-been-run'] })` will throw an error, if `has-not-been-run` is not found in the list of executed migrations.\r\n- `umzug.up({ migrations: ['m1', 'm2'], rerun: 'ALLOW' })` will re-apply migrations `m1` and `m2` even if they've already been run.\r\n- `umzug.up({ migrations: ['m1', 'm2'], rerun: 'SKIP' })` will skip migrations `m1` and `m2` if they've already been run.\r\n- `umzug.down({ migrations: ['m1', 'm2'], rerun: 'ALLOW' })` will \"revert\" migrations `m1` and `m2` even if they've never been run.\r\n- `umzug.down({ migrations: ['m1', 'm2'], rerun: 'SKIP' })` will skip reverting migrations `m1` and `m2` if they haven't been run or are already reverted.\r\n- `umzug.up({ migrations: ['m1', 'does-not-exist', 'm2'] })` will throw an error if the migration name is not found. Note that the error will be thrown and no migrations run unless _all_ migration names are found - whether or not `rerun: 'ALLOW'` is added.\r\n\r\nThe `context` parameter replaces `params`, and is passed in as a property to migration functions as an options object, alongs side `name` and `path`. This means the signature for migrations, which in v2 was `(context) => Promise<void>`, has changed slightly in v3, to `({ name, path, context }) => Promise<void>`. The `resolve` function can also be used to upgrade your umzug version to v3 when you have existing v2-compatible migrations:\r\n\r\n```js\r\nconst { Umzug } = require('umzug');\r\n\r\nconst umzug = new Umzug({\r\n  migrations: {\r\n    glob: 'migrations/umzug-v2-format/*.js',\r\n    resolve: ({name, path, context}) => {\r\n      // Adjust the migration from the new signature to the v2 signature, making easier to upgrade to v3\r\n      const migration = require(path)\r\n      return { name, up: async () => migration.up(context), down: async () => migration.down(context) }\r\n    }\r\n  },\r\n  context: sequelize.getQueryInterface(),\r\n  logger: console,\r\n});\r\n```\r\n\r\nSimilarly, you no longer need `migrationSorting`, you can use `Umzug#extend` to manipulate migration lists directly:\r\n\r\n```js\r\nconst { Umzug } = require('umzug');\r\n\r\nconst umzug =\r\n  new Umzug({\r\n    migrations: { glob: 'migrations/**/*.js' },\r\n    context: sequelize.getQueryInterface(),\r\n  })\r\n  .extend(migrations => migrations.sort((a, b) => b.path.localeCompare(a.path)));\r\n```\r\n\r\n### Storages\r\n\r\nStorages define where the migration data is stored.\r\n\r\n#### JSON Storage\r\n\r\nUsing `JSONStorage` will create a JSON file which will contain an array with all the executed migrations. You can specify the path to the file. The default for that is `umzug.json` in the working directory of the process.\r\n\r\nDetailed documentation for the options it can take are in the `JSONStorageConstructorOptions` TypeScript interface, which can be found in [src/storage/json.ts](./src/storage/json.ts).\r\n\r\n#### Memory Storage\r\n\r\nUsing `memoryStorage` will store migrations with an in-memory array. This can be useful for proof-of-concepts or tests, since it doesn't interact with databases or filesystems.\r\n\r\nIt doesn't take any options, just import the `memoryStorage` function and call it to return a storage instance:\r\n\r\n```typescript\r\nimport { Umzug, memoryStorage } from 'umzug'\r\n\r\nconst umzug = new Umzug({\r\n  migrations: ...,\r\n  storage: memoryStorage(),\r\n  logger: console,\r\n})\r\n```\r\n\r\n#### Sequelize Storage\r\n\r\nUsing `SequelizeStorage` will create a table in your SQL database called `SequelizeMeta` containing an entry for each executed migration. You will have to pass a configured instance of Sequelize or an existing Sequelize model. Optionally you can specify the model name, table name, or column name. All major Sequelize versions are supported.\r\n\r\nDetailed documentation for the options it can take are in the `_SequelizeStorageConstructorOptions` TypeScript interface, which can be found in [src/storage/sequelize.ts](./src/storage/sequelize.ts).\r\n\r\n#### MongoDB Storage\r\n\r\nUsing `MongoDBStorage` will create a collection in your MongoDB database called `migrations` containing an entry for each executed migration. You will have either to pass a MongoDB Driver Collection as `collection` property. Alternatively you can pass a established MongoDB Driver connection and a collection name.\r\n\r\nDetailed documentation for the options it can take are in the `MongoDBStorageConstructorOptions` TypeScript interface, which can be found in [src/storage/mongodb.ts](./src/storage/mongodb.ts).\r\n\r\n#### Custom\r\n\r\nIn order to use a custom storage, you can pass your storage instance to Umzug constructor.\r\n\r\n```js\r\nclass CustomStorage {\r\n  constructor(...) {...}\r\n  logMigration(...) {...}\r\n  unlogMigration(...) {...}\r\n  executed(...) {...}\r\n}\r\n\r\nconst umzug = new Umzug({ storage: new CustomStorage(...), logger: console })\r\n```\r\n\r\nYour instance must adhere to the [UmzugStorage](./src/storage/contract.ts) interface. If you're using TypeScript you can ensure this at compile time, and get IDE type hints by importing it:\r\n\r\n```typescript\r\nimport { UmzugStorage } from 'umzug'\r\n\r\nclass CustomStorage implements UmzugStorage {\r\n  /* ... */\r\n}\r\n```\r\n\r\n### Events\r\n\r\nUmzug is an [emittery event emitter](https://www.npmjs.com/package/emittery). Each of the following events will be called with migration parameters as its payload (with `context`, `name`, and nullable `path` properties). Events are a convenient place to implement application-specific logic that must run around each migration:\r\n\r\n* `migrating` - A migration is about to be executed.\r\n* `migrated` - A migration has successfully been executed.\r\n* `reverting` - A migration is about to be reverted.\r\n* `reverted` - A migration has successfully been reverted.\r\n\r\nThese events run at the beginning and end of `up` and `down` calls. They'll receive an object containing a `context` property:\r\n\r\n- `beforeCommand` - Before any command (`'up' | 'down' | 'executed' | 'pending'`) is run.\r\n- `afterCommand` - After any command (`'up' | 'down' | 'executed' | 'pending'`) is run. Note: this will always run, even if the command throws an error.\r\n\r\nThe [`FileLocker` class](./src/file-locker.ts) uses `beforeAll` and `afterAll` to implement a simple filesystem-based locking mechanism.\r\n\r\nAll events are type-safe, so IDEs will prevent typos and supply strong types for the event payloads.\r\n\r\n### Errors\r\n\r\nWhen a migration throws an error, it will be wrapped in a `MigrationError` which captures the migration metadata (name, path etc.) as well as the original error message, and _will be rethrown_. In most cases, this is expected behaviour, and doesn't require any special handling beyond standard error logging setups.\r\n\r\nIf you expect failures and want to try to recover from them, you will need to try-catch the call to `umzug.up()`. You can access the original error from the `.cause` property if necessary:\r\n\r\n```js\r\ntry {\r\n  await umzug.up();\r\n} catch (e) {\r\n  if (e instanceof MigrationError) {\r\n    const original = e.cause;\r\n    // do something with the original error here\r\n  }\r\n  throw e;\r\n}\r\n```\r\n\r\nUnder the hood, [verror](https://npmjs.com/package/verror) is used to wrap errors.\r\n\r\n### CLI\r\n\r\n🚧🚧🚧 The CLI is new to Umzug v3 beta and is not yet stable. Feedback on it is welcome in [discussions](https://github.com/sequelize/umzug/discussions) 🚧🚧🚧\r\n\r\nUmzug instances provide a `.runAsCLI()` method. When called, this method will automatically cause your program to become a complete CLI, with help text and such:\r\n\r\n```js\r\n// migrator.js\r\nconst { Umzug } = require('umzug')\r\n\r\nexports.umzug = new Umzug({ ... })\r\n\r\nif (require.main === module) {\r\n  umzug.runAsCLI()\r\n}\r\n```\r\n\r\n#### CLI Usage\r\n\r\nA script like the one above is now a runnable CLI program. You can run `node migrator.js --help` to see how to use it. It will print something like:\r\n\r\n<!-- codegen:start {preset: custom, source: ./codegen.js, export: cliHelp} -->\r\n```\r\nusage: <script> [-h] <command> ...\r\n\r\nUmzug migrator\r\n\r\nPositional arguments:\r\n  <command>\r\n    up        Applies pending migrations\r\n    down      Revert migrations\r\n    pending   Lists pending migrations\r\n    executed  Lists executed migrations\r\n    create    Create a migration file\r\n\r\nOptional arguments:\r\n  -h, --help  Show this help message and exit.\r\n\r\nFor detailed help about a specific command, use: <script> <command> -h\r\n```\r\n<!-- codegen:end -->\r\n\r\n#### Running migrations\r\n\r\n`node migrator up` and `node migrator down` apply and revert migrations respectively. They're the equivalent of the `.up()` and `.down()` methods.\r\n\r\nUse `node migrator up --help` and `node migrator down --help` for options (running \"to\" a specific migration, passing migration names to be run explicitly, and specifying the rerun behavior):\r\n\r\nUp:\r\n<!-- codegen:start {preset: custom, source: ./codegen.js, export: cliHelp, action: up} -->\r\n```\r\nusage: <script> up [-h] [--to NAME] [--step COUNT] [--name MIGRATION]\r\n                   [--rerun {THROW,SKIP,ALLOW}]\r\n                   \r\n\r\nPerforms all migrations. See --help for more options\r\n\r\nOptional arguments:\r\n  -h, --help            Show this help message and exit.\r\n  --to NAME             All migrations up to and including this one should be \r\n                        applied.\r\n  --step COUNT          Run this many migrations. If not specified, all will \r\n                        be applied.\r\n  --name MIGRATION      Explicity declare migration name(s) to be applied.\r\n  --rerun {THROW,SKIP,ALLOW}\r\n                        Specify what action should be taken when a migration \r\n                        that has already been applied is passed to --name. \r\n                        The default value is \"THROW\".\r\n```\r\n<!-- codegen:end -->\r\n\r\nDown:\r\n<!-- codegen:start {preset: custom, source: ./codegen.js, export: cliHelp, action: down} -->\r\n```\r\nusage: <script> down [-h] [--to NAME] [--step COUNT] [--name MIGRATION]\r\n                     [--rerun {THROW,SKIP,ALLOW}]\r\n                     \r\n\r\nUndoes previously-applied migrations. By default, undoes the most recent \r\nmigration only. Use --help for more options. Useful in development to start \r\nfrom a clean slate. Use with care in production!\r\n\r\nOptional arguments:\r\n  -h, --help            Show this help message and exit.\r\n  --to NAME             All migrations up to and including this one should be \r\n                        reverted. Pass \"0\" to revert all.\r\n  --step COUNT          Run this many migrations. If not specified, one will \r\n                        be reverted.\r\n  --name MIGRATION      Explicity declare migration name(s) to be reverted.\r\n  --rerun {THROW,SKIP,ALLOW}\r\n                        Specify what action should be taken when a migration \r\n                        that has already been reverted is passed to --name. \r\n                        The default value is \"THROW\".\r\n```\r\n<!-- codegen:end -->\r\n\r\n\r\n#### Listing migrations\r\n\r\n```bash\r\nnode migrator pending # list migrations yet to be run\r\nnode migrator executed # list migrations that have already run\r\n\r\nnode migrator pending --json # list pending migrations including names and paths, in a json array format\r\nnode migrator executed --json # list executed migrations including names and paths, in a json array format\r\n\r\nnode migrator pending --help # show help/options\r\nnode migrator executed --help # show help/options\r\n```\r\n\r\n<!-- codegen:start {preset: custom, source: ./codegen.js, export: cliHelp, action: pending} -->\r\n```\r\nusage: <script> pending [-h] [--json]\r\n\r\nPrints migrations returned by `umzug.pending()`. By default, prints migration \r\nnames one per line.\r\n\r\nOptional arguments:\r\n  -h, --help  Show this help message and exit.\r\n  --json      Print pending migrations in a json format including names and \r\n              paths. This allows piping output to tools like jq. Without this \r\n              flag, the migration names will be printed one per line.\r\n```\r\n<!-- codegen:end -->\r\n\r\n<!-- codegen:start {preset: custom, source: ./codegen.js, export: cliHelp, action: executed} -->\r\n```\r\nusage: <script> executed [-h] [--json]\r\n\r\nPrints migrations returned by `umzug.executed()`. By default, prints \r\nmigration names one per line.\r\n\r\nOptional arguments:\r\n  -h, --help  Show this help message and exit.\r\n  --json      Print executed migrations in a json format including names and \r\n              paths. This allows piping output to tools like jq. Without this \r\n              flag, the migration names will be printed one per line.\r\n```\r\n<!-- codegen:end -->\r\n\r\n#### Creating migrations - CLI\r\n\r\nUsually, migrations correspond to files on the filesystem. The CLI exposes a way to create migration files easily:\r\n\r\n```bash\r\nnode migrator create --name my-migration.js\r\n```\r\n\r\nThis will create a file with a name like `2000.12.25T12.34.56.my-migration.js` in the same directory as the most recent migration file. If it's the very first migration file, you need to specify the folder explicitly:\r\n\r\n```bash\r\nnode migrator create --name my-migration.js --folder path/to/directory\r\n```\r\n\r\nThe timestamp prefix can be customized to be date-only or omitted, but be aware that it's strongly recommended to ensure your migrations are lexicographically sortable so it's easy for humans and tools to determine what order they should run in - so the default prefix is recommended.\r\n\r\nThis will generate a migration file called `<<timestamp>>.my-migration.js` with the default migration template for `.js` files that ships with Umzug.\r\n\r\nUmzug also ships with default templates for [`.ts`, `.cjs`, `.mjs` and `.sql` files](./src/templates.ts). Umzug will choose the template based on the extension you provide in `name`.\r\n\r\nYou can specify a custom template for your project when constructing an umzug instance via the `template` option. It should be a function which receives a filepath string, and returns an array of `[filepath, content]` pairs. Usually, just one pair is needed, but a second could be used to include a \"down\" migration in a separate file:\r\n\r\n```js\r\nconst umzug = new Umzug({\r\n  migrations: ...,\r\n  template: filepath => [\r\n    [filepath, fs.readFileSync('path/to/your/template/file').toString()],\r\n  ]\r\n})\r\n```\r\n\r\nThe create command includes some safety checks to make sure migrations aren't created with ambiguous ordering, and that they will be picked up by umzug when applying migrations.\r\n\r\nUse `node migrator create --help` for more options:\r\n\r\n<!-- codegen:start {preset: custom, source: ./codegen.js, export: cliHelp, action: create} -->\r\n```\r\nusage: <script> create [-h] --name NAME [--prefix {TIMESTAMP,DATE,NONE}]\r\n                       [--folder PATH] [--allow-extension EXTENSION]\r\n                       [--skip-verify] [--allow-confusing-ordering]\r\n                       \r\n\r\nGenerates a placeholder migration file using a timestamp as a prefix. By \r\ndefault, mimics the last existing migration, or guesses where to generate the \r\nfile if no migration exists yet.\r\n\r\nOptional arguments:\r\n  -h, --help            Show this help message and exit.\r\n  --name NAME           The name of the migration file. e.g. my-migration.js, \r\n                        my-migration.ts or my-migration.sql. Note - a prefix \r\n                        will be added to this name, usually based on a \r\n                        timestamp. See --prefix\r\n  --prefix {TIMESTAMP,DATE,NONE}\r\n                        The prefix format for generated files. TIMESTAMP uses \r\n                        a second-resolution timestamp, DATE uses a \r\n                        day-resolution timestamp, and NONE removes the prefix \r\n                        completely. The default value is \"TIMESTAMP\".\r\n  --folder PATH         Path on the filesystem where the file should be \r\n                        created. The new migration will be created as a \r\n                        sibling of the last existing one if this is omitted.\r\n  --allow-extension EXTENSION\r\n                        Allowable extension for created files. By default .js,\r\n                         .ts and .sql files can be created. To create txt \r\n                        file migrations, for example, you could use '--name \r\n                        my-migration.txt --allow-extension .txt' This \r\n                        parameter may alternatively be specified via the \r\n                        UMZUG_ALLOW_EXTENSION environment variable.\r\n  --skip-verify         By default, the generated file will be checked after \r\n                        creation to make sure it is detected as a pending \r\n                        migration. This catches problems like creation in the \r\n                        wrong folder, or invalid naming conventions. This \r\n                        flag bypasses that verification step.\r\n  --allow-confusing-ordering\r\n                        By default, an error will be thrown if you try to \r\n                        create a migration that will run before a migration \r\n                        that already exists. This catches errors which can \r\n                        cause problems if you change file naming conventions. \r\n                        If you use a custom ordering system, you can disable \r\n                        this behavior, but it's strongly recommended that you \r\n                        don't! If you're unsure, just ignore this option.\r\n```\r\n<!-- codegen:end -->\r\n\r\n### Creating migrations - API\r\n\r\nUmzug includes an optional helper for generating migration files. It's often most convenient to create files using the [CLI helper](#creating-migrations---cli), but the equivalent API also exists on an umzug instance:\r\n\r\n```js\r\nawait umzug.create({ name: 'my-new-migration.js' })\r\n```\r\n\r\n## License\r\n\r\nSee the [LICENSE file](./LICENSE)\r\n","readmeFilename":"README.md","gitHead":"d69596b7caa9eed46faab9cedb956f5b358467d1","_id":"umzug@3.0.0-beta.16","_nodeVersion":"12.18.0","_npmVersion":"6.14.8","dist":{"integrity":"sha512-4m3wddPhKo3C5zHGtbmN9odt1wlqitPNTZFEZ6tn5Ihi7TcxEaUe4trEeP3UxIftFB15sdvDzLoYkGBQCGtXHg==","shasum":"fd64f99e080f3c05faa9adae2f0e3320fc66416d","tarball":"https://registry.npmjs.org/umzug/-/umzug-3.0.0-beta.16.tgz","fileCount":40,"unpackedSize":131568,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJgqt0BCRA9TVsSAnZWagAA404P+QA+jqDGWjlnR9ciADF9\nAuyxpN352JO3VS72ZRDv5pS2nPM0XR2gC6+/spyUrQjozRnxQOPCToLPtQ/Z\nPS8HdEfFJQKOw6EO0hDZuzIb4Ym09t2GLn0654it0rDBrBI7YpCnEcTRtqwV\ntfy2U7HQqAOnSrUAK9hL1N1mghidcioSSxjg+b7v61ZvhxN74Gw92SWFUia4\nwTMGp5EOYawIQ214EyOWq3s/W8a8dmhNxjE2rDp6c4MyScES8zP8rI4ZAC7q\n+/z5fwROOAuZ3+L0VNjrpx25x+NqEJcAdEGYuEbwH+EjZr6Lise1Jj7HJFA2\neN8bHEhGWkRn2e1WW8vJGK2jJUdTSRsl6GCHPLq3wwyF/X2erkenigxvyKGP\nLFTQaY2h7LpqCwcWGauKRkw8O7byCMv9LWgDS1AdP61gQsdQtMn4pzVryCzh\nX+2jslTEqgA2pc3luIJOyrrl98+9zLW8VjmPuBS4Nbmjf04cXnqpWz1LTzl/\nQh7ZccL4ufcrnG3k5EWlV28Nhxi7XvUX7rxrLZav0apfo45duAIhdJH9kycu\nhRN4T3GQl6DpPxnZx/HYCxASBtGWjMvPMRhMa5XYcVj5BylslifW1earQaE4\nnNBnAFxLNInUBrIVwN6+pnIL2V72R/MXLzaoeKQ6OYZnQqjiW8f8Grp08wTo\nwl15\r\n=jqxj\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIQDeI+RUoPwrJpLtLJFDlAJMqomG2Ug9iq1z70d9txOGyQIgY35RCZSPKB81+wTTMMBAeT6BqCj2+v+FOfju86KllFU="}]},"_npmUser":{"name":"mmkale","email":"mmkal1@outlook.com"},"directories":{},"maintainers":[{"name":"pascal.pflaum","email":"mail@pascalpflaum.de"},{"name":"sdepold","email":"sascha@depold.com"},{"name":"sushantdhiman","email":"sushantdhiman@outlook.com"},{"name":"papb","email":"papb1996@gmail.com"},{"name":"mmkale","email":"mmkal1@outlook.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/umzug_3.0.0-beta.16_1621810432815_0.6279057764922749"},"_hasShrinkwrap":false},"3.0.0-beta-cli.17":{"name":"umzug","version":"3.0.0-beta-cli.17","description":"Framework-agnostic migration tool for Node","keywords":["migrate","migration","migrations","sequelize","database"],"main":"lib/index.js","dependencies":{"@rushstack/ts-command-line":"^4.7.7","@types/verror":"^1.10.4","emittery":"^0.8.1","fs-jetpack":"^4.1.0","glob":"^7.1.6","type-fest":"^1.0.0","verror":"^1.10.0"},"devDependencies":{"@types/jest":"26.0.20","@types/lodash":"4.14.168","@types/uuid":"8.3.0","@typescript-eslint/eslint-plugin":"4.15.0","@typescript-eslint/parser":"4.15.0","del-cli":"3.0.1","eslint":"7.20.0","eslint-config-xo":"0.34.0","eslint-config-xo-typescript":"0.37.0","eslint-plugin-codegen":"0.15.0","eslint-plugin-import":"2.22.1","eslint-plugin-jest":"24.1.3","eslint-plugin-mocha":"8.0.0","eslint-plugin-prettier":"3.3.1","eslint-plugin-unicorn":"24.0.0","expect-type":"0.11.0","fs-syncer":"0.3.4","jest":"26.6.3","lodash":"4.17.21","np":"7.4.0","prettier":"2.2.1","sequelize":"5.22.3","sinon":"9.2.4","source-map-support":"0.5.19","sqlite3":"5.0.1","strip-ansi":"6.0.0","ts-jest":"26.5.1","ts-node":"9.1.1","typescript":"4.1.5","uuid":"8.3.2"},"scripts":{"build":"del-cli lib && tsc -p tsconfig.lib.json","eslint":"eslint --ext .js,.ts,.md . --max-warnings 0","lint":"npm run type-check && npm run eslint","prepare":"npm run build","release":"np --no-yarn --no-2fa","pretest":"del-cli test/generated","test":"jest","type-check":"tsc -p ."},"repository":{"type":"git","url":"git+https://github.com/sequelize/umzug.git"},"author":{"name":"Sascha Depold","email":"sascha@depold.com"},"contributors":[{"name":"Jukka Hyytiälä","email":"hyytiala.jukka@gmail.com"},{"name":"Pascal Pflaum","email":"mail@pascalpflaum.de"},{"name":"Pedro Augusto de Paula Barbosa","email":"papb1996@gmail.com"}],"license":"MIT","bugs":{"url":"https://github.com/sequelize/umzug/issues"},"homepage":"https://github.com/sequelize/umzug","engines":{"node":">=10.0.0"},"jest":{"preset":"ts-jest","globals":{"ts-jest":{"diagnostics":false}},"testEnvironment":"node","testMatch":["**/*test.ts"],"collectCoverageFrom":["src/**"]},"readme":"# Umzug\r\n\r\n[![Build Status](https://badgen.net/github/checks/sequelize/umzug/master)](https://github.com/sequelize/umzug/actions?query=workflow%3ACI)\r\n[![npm (stable)](https://badgen.net/npm/v/umzug)](https://www.npmjs.com/package/umzug)\r\n[![npm (beta)](https://badgen.net/npm/v/umzug/beta)](https://www.npmjs.com/package/umzug/v/beta)\r\n[![npm (downloads)](https://badgen.net/npm/dm/umzug)](https://npmjs.com/package/umzug)\r\n\r\nUmzug is a framework-agnostic migration tool for Node. It provides a clean API for running and rolling back tasks.\r\n\r\n_Note: master represents the next major version of umzug - v3 - which is currently in beta. For the stable version, please refer to the [v2.x branch](https://github.com/sequelize/umzug/tree/v2.x)._\r\n\r\nTo install the v3-beta package:\r\n\r\n```\r\nnpm install umzug@beta\r\n```\r\n\r\nTo install the stable package (v2.x):\r\n\r\n```\r\nnpm install umzug\r\n```\r\n\r\n## Highlights\r\n\r\n* Written in TypeScript\r\n\t* Built-in typings\r\n\t* Auto-completion right in your IDE\r\n\t* Documentation right in your IDE\r\n* Programmatic API for migrations\r\n* Built-in [CLI](#cli)\r\n* Database agnostic\r\n* Supports logging of migration process\r\n* Supports multiple storages for migration data\r\n* [Usage examples](./examples)\r\n\r\n## Documentation\r\n\r\n### Minimal Example\r\n\r\nThe following example uses a Sqlite database through sequelize and persists the migration data in the database itself through the sequelize storage. There are several more involved examples covering a few different scenarios in the [examples folder](./examples).\r\n\r\n```js\r\n// index.js\r\nconst { Sequelize } = require('sequelize');\r\nconst { Umzug, SequelizeStorage } = require('umzug');\r\n\r\nconst sequelize = new Sequelize({ dialect: 'sqlite', storage: './db.sqlite' });\r\n\r\nconst umzug = new Umzug({\r\n  migrations: { glob: 'migrations/*.js' },\r\n  context: sequelize.getQueryInterface(),\r\n  storage: new SequelizeStorage({ sequelize }),\r\n  logger: console,\r\n});\r\n\r\n(async () => {\r\n  // Checks migrations and run them if they are not already applied. To keep\r\n  // track of the executed migrations, a table (and sequelize model) called SequelizeMeta\r\n  // will be automatically created (if it doesn't exist already) and parsed.\r\n  await umzug.up();\r\n})();\r\n```\r\n\r\n```js\r\n// migrations/00_initial.js\r\n\r\nconst { Sequelize } = require('sequelize');\r\n\r\nasync function up({ context: queryInterface }) {\r\n\tawait queryInterface.createTable('users', {\r\n\t\tid: {\r\n\t\t\ttype: Sequelize.INTEGER,\r\n\t\t\tallowNull: false,\r\n\t\t\tprimaryKey: true\r\n\t\t},\r\n\t\tname: {\r\n\t\t\ttype: Sequelize.STRING,\r\n\t\t\tallowNull: false\r\n\t\t},\r\n\t\tcreatedAt: {\r\n\t\t\ttype: Sequelize.DATE,\r\n\t\t\tallowNull: false\r\n\t\t},\r\n\t\tupdatedAt: {\r\n\t\t\ttype: Sequelize.DATE,\r\n\t\t\tallowNull: false\r\n\t\t}\r\n\t});\r\n}\r\n\r\nasync function down({ context: queryInterface }) {\r\n\tawait queryInterface.dropTable('users');\r\n}\r\n\r\nmodule.exports = { up, down };\r\n```\r\n\r\nNote that we renamed the `context` argument to `queryInterface` for clarity. The `context` is whatever we specified when creating the Umzug instance in `index.js`.\r\n\r\n<details>\r\n<summary>You can also write your migrations in typescript by using `ts-node` in the entrypoint:</summary>\r\n\r\n```typescript\r\n// index.ts\r\nrequire('ts-node/register')\r\n\r\nimport { Sequelize } from 'sequelize';\r\nimport { Umzug, SequelizeStorage } from 'umzug';\r\n\r\nconst sequelize = new Sequelize({ dialect: 'sqlite', storage: './db.sqlite' });\r\n\r\nconst umzug = new Umzug({\r\n  migrations: { glob: 'migrations/*.ts' },\r\n  context: sequelize.getQueryInterface(),\r\n  storage: new SequelizeStorage({ sequelize }),\r\n  logger: console,\r\n});\r\n\r\n// export the type helper exposed by umzug, which will have the `context` argument typed correctly\r\nexport type Migration = typeof umzug._types.migration;\r\n\r\n(async () => {\r\n  await umzug.up();\r\n})();\r\n```\r\n\r\n```typescript\r\n// migrations/00_initial.ts\r\nimport type { Migration } from '..';\r\n\r\n// types will now be available for `queryInterface`\r\nexport const up: Migration = ({ context: queryInterface }) => queryInterface.createTable(...)\r\nexport const down: Migration = ({ context: queryInterface }) => queryInterface.dropTable(...)\r\n```\r\n</details>\r\n\r\nSee [these tests](./test/umzug.test.ts) for more examples of Umzug usage, including:\r\n\r\n- passing `ignore` and `cwd` parameters to the glob instructions\r\n- customising migrations ordering\r\n- finding migrations from multiple different directories\r\n- using non-js file extensions via a custom resolver, e.g. `.sql`\r\n\r\n### Usage\r\n\r\n#### Installation\r\n\r\nThe beta version of Umzug is available on npm by specifying the correct tag:\r\n\r\n```bash\r\nnpm install umzug@beta\r\n```\r\n\r\n#### Umzug instance\r\n\r\nIt is possible to configure an Umzug instance by passing an object to the constructor.\r\n\r\n```js\r\nconst { Umzug } = require('umzug');\r\nconst umzug = new Umzug({ /* ... options ... */ });\r\n```\r\n\r\nDetailed documentation for these options are in the `UmzugOptions` TypeScript interface, which can be found in [src/types.ts](./src/types.ts).\r\n\r\n#### Getting all pending migrations\r\n\r\nYou can get a list of pending (i.e. not yet executed) migrations with the `pending()` method:\r\n\r\n```js\r\nconst migrations = await umzug.pending();\r\n// returns an array of all pending migrations.\r\n```\r\n\r\n#### Getting all executed migrations\r\n\r\nYou can get a list of already executed migrations with the `executed()` method:\r\n\r\n```js\r\nconst migrations = await umzug.executed();\r\n// returns an array of all already executed migrations\r\n```\r\n\r\n#### Executing pending migrations\r\n\r\nThe `up` method can be used to execute all pending migrations.\r\n\r\n```js\r\nconst migrations = await umzug.up();\r\n// returns an array of all executed migrations\r\n```\r\n\r\nIt is also possible to pass the name of a migration in order to just run the migrations from the current state to the passed migration name (inclusive).\r\n\r\n```js\r\nawait umzug.up({ to: '20141101203500-task' });\r\n```\r\n\r\nTo limit the number of migrations that are run, `step` can be used:\r\n\r\n```js\r\n// This will run the next two migrations\r\nawait umzug.up({ step: 2 })\r\n```\r\n\r\nRunning specific migrations while ignoring the right order, can be done like this:\r\n\r\n```js\r\nawait umzug.up({ migrations: ['20141101203500-task', '20141101203501-task-2'] });\r\n```\r\n\r\n#### Reverting executed migration\r\n\r\nThe `down` method can be used to revert the last executed migration.\r\n\r\n```js\r\nconst migration = await umzug.down();\r\n// reverts the last migration and returns it.\r\n```\r\n\r\nTo revert more than one migration, you can use `step`:\r\n\r\n```js\r\n// This will revert the last two migrations\r\nawait umzug.down({ step: 2 });\r\n```\r\n\r\nIt is possible to pass the name of a migration until which (inclusive) the migrations should be reverted. This allows the reverting of multiple migrations at once.\r\n\r\n```js\r\nconst migrations = await umzug.down({ to: '20141031080000-task' });\r\n// returns an array of all reverted migrations.\r\n```\r\n\r\nTo revert all migrations, you can pass 0 as the `to` parameter:\r\n\r\n```js\r\nawait umzug.down({ to: 0 });\r\n```\r\n\r\nReverting specific migrations while ignoring the right order, can be done like this:\r\n\r\n```js\r\nawait umzug.down({ migrations: ['20141101203500-task', '20141101203501-task-2'] });\r\n```\r\n\r\n### Migrations\r\n\r\nThere are two ways to specify migrations: via files or directly via an array of migrations.\r\n\r\n#### Migration files\r\n\r\nA migration file ideally exposes an `up` and a `down` async functions. They will perform the task of upgrading or downgrading the database.\r\n\r\n```js\r\nmodule.exports = {\r\n  async up() {\r\n    /* ... */\r\n  },\r\n  async down() {\r\n    /* ... */\r\n  }\r\n};\r\n```\r\n\r\nMigration files can be located anywhere - they will typically be loaded according to a glob pattern provided to the `Umzug` constructor.\r\n\r\n#### Direct migrations list\r\n\r\nYou can also specify directly a list of migrations to the `Umzug` constructor:\r\n\r\n```js\r\nconst { Umzug } = require('umzug');\r\n\r\nconst umzug = new Umzug({\r\n  migrations: [\r\n    {\r\n      // the name of the migration is mandatory\r\n      name: '00-first-migration',\r\n      async up({ context }) { /* ... */ },\r\n      async down({ context }) { /* ... */ }\r\n    },\r\n    {\r\n      name: '01-foo-bar-migration',\r\n      async up({ context }) { /* ... */ },\r\n      async down({ context }) { /* ... */ }\r\n    }\r\n  ],\r\n  context: sequelize.getQueryInterface(),\r\n  logger: console,\r\n});\r\n```\r\n\r\nTo load migrations in another format, you can use the `resolve` function:\r\n\r\n```js\r\nconst { Umzug } = require('umzug')\r\nconst { Sequelize } = require('sequelize')\r\nconst fs = require('fs')\r\n\r\nconst umzug = new Umzug({\r\n  migrations: {\r\n    glob: 'migrations/*.up.sql',\r\n    resolve: ({ name, path, context: sequelize }) => ({\r\n      name,\r\n      up: async () => {\r\n        const sql = fs.readFileSync(path).toString()\r\n        return sequelize.query(sql)\r\n      },\r\n      down: async () => {\r\n        // Get the corresponding `.down.sql` file to undo this migration\r\n        const sql = fs.readFileSync(path.replace('.up.sql', '.down.sql')).toString()\r\n        return sequelize.query(sql)\r\n      }\r\n    })\r\n  },\r\n  context: new Sequelize(...),\r\n  logger: console,\r\n});\r\n```\r\n\r\nYou can support mixed migration file types, and use umzug's default resolver for javascript/typescript:\r\n\r\n```js\r\nconst { Umzug } = require('umzug')\r\nconst { Sequelize } = require('sequelize')\r\nconst fs = require('fs')\r\n\r\nconst umzug = new Umzug({\r\n  migrations: {\r\n    glob: 'migrations/*.{js,ts,up.sql}',\r\n    resolve: (params) => {\r\n      if (!params.path.endsWith('.sql')) {\r\n        return Umzug.defaultResolver(params)\r\n      }\r\n      const { context: sequelize } = params\r\n      return {\r\n        name: params.name,\r\n        up: async () => {\r\n          const sql = fs.readFileSync(params.path).toString()\r\n          return sequelize.query(sql)\r\n        },\r\n        down: async () => {\r\n          // Get the corresponding `.down.sql` file to undo this migration\r\n          const sql = fs.readFileSync(params.path.replace('.up.sql', '.down.sql')).toString()\r\n          return sequelize.query(sql)\r\n        }\r\n      }\r\n    },\r\n  },\r\n  logger: console,\r\n  context: new Sequelize(...),\r\n});\r\n```\r\n\r\nThe glob syntax allows loading migrations from multiple locations:\r\n\r\n```js\r\nconst { Umzug } = require('umzug')\r\nconst { Sequelize } = require('sequelize')\r\n\r\nconst umzug = new Umzug({\r\n  migrations: {\r\n    glob: '{first-folder/*.js,second-folder-with-different-naming-convention/*.js}',\r\n  },\r\n  context: new Sequelize(...),\r\n  logger: console,\r\n});\r\n```\r\n\r\nNote on migration file sorting:\r\n\r\n- file matches, found using [glob](https://npmjs.com/package/glob), will be lexicographically sorted based on their paths\r\n  - so if your migrations are `one/m1.js`, `two/m2.js`, `three/m3.js`, the resultant order will be `one/m1.js`, `three/m3.js`, `two/m2.js`\r\n  - similarly, if your migrations are called `m1.js`, `m2.js`, ... `m10.js`, `m11.js`, the resultant ordering will be `m1.js`, `m10.js`, `m11.js`, ... `m2.js`\r\n- The easiest way to deal with this is to ensure your migrations appear in a single folder, and their paths match lexicographically with the order they should run in\r\n- If this isn't possible, the ordering can be customised using `.extend(...)` (see below)\r\n\r\n### Upgrading from v2.x\r\n\r\nThe Umzug class should be imported as a named import, i.e. `import { Umzug } from 'umzug'`.\r\n\r\nThe `MigrationMeta` type, which is returned by `umzug.executed()` and `umzug.pending()`, no longer has a `file` property - it has a `name` and *optional* `path` - since migrations are not necessarily bound to files on the file system.\r\n\r\nThe `migrations.glob` parameter replaces `path`, `pattern` and `traverseDirectories`. It can be used, in combination with `cwd` and `ignore` to do much more flexible file lookups. See https://npmjs.com/package/glob for more information on the syntax.\r\n\r\nThe `migrations.resolve` parameter replaces `customResolver`. Explicit support for `wrap` and `nameFormatter` has been removed - these can be easily implemented in a `resolve` function.\r\n\r\nThe constructor option `logging` is replaced by `logger` to allow for `warn` and `error` messages in future. NodeJS's global `console` object can be passed to this. To disable logging, replace `logging: false` with `logger: undefined`.\r\n\r\nEvents have moved from the default nodejs `EventEmitter` to [emittery](https://www.npmjs.com/package/emittery). It has better design for async code, a less bloated API surface and strong types. But, it doesn't allow passing multiple arguments to callbacks, so listeners have to change slightly, as well as `.addListener(...)` and `.removeListener(...)` no longer being supported (`.on(...)` and `.off(...)` should now be used):\r\n\r\nBefore:\r\n\r\n```js\r\numzug.on('migrating', (name, m) => console.log({ name, path: m.path }))\r\n```\r\n\r\nAfter:\r\n\r\n```js\r\numzug.on('migrating', ev => console.log({ name: ev.name, path: ev.path }))\r\n```\r\n\r\nThe `Umzug#execute` method is removed. Use `Umzug#up` or `Umzug#down`.\r\n\r\nThe options for `Umguz#up` and `Umzug#down` have changed:\r\n- `umzug.up({ to: 'some-name' })` and `umzug.down({ to: 'some-name' })` are still valid.\r\n- `umzug.up({ from: '...' })` and `umzug.down({ from: '...' })` are no longer supported. To run migrations out-of-order (which is not generally recommended), you can explicitly use `umzug.up({ migrations: ['...'] })` and `umzug.down({ migrations: ['...'] })`.\r\n- name matches must be exact. `umzug.up({ to: 'some-n' })` will no longer match a migration called `some-name`.\r\n- `umzug.down({ to: 0 })` is still valid but `umzug.up({ to: 0 })` is not.\r\n- `umzug.up({ migrations: ['m1', 'm2'] })` is still valid but the shorthand `umzug.up(['m1', 'm2'])` has been removed.\r\n- `umzug.down({ migrations: ['m1', 'm2'] })` is still valid but the shorthand `umzug.down(['m1', 'm2'])` has been removed.\r\n- `umzug.up({ migrations: ['m1', 'already-run'] })` will throw an error, if `already-run` is not found in the list of pending migrations.\r\n- `umzug.down({ migrations: ['m1', 'has-not-been-run'] })` will throw an error, if `has-not-been-run` is not found in the list of executed migrations.\r\n- `umzug.up({ migrations: ['m1', 'm2'], rerun: 'ALLOW' })` will re-apply migrations `m1` and `m2` even if they've already been run.\r\n- `umzug.up({ migrations: ['m1', 'm2'], rerun: 'SKIP' })` will skip migrations `m1` and `m2` if they've already been run.\r\n- `umzug.down({ migrations: ['m1', 'm2'], rerun: 'ALLOW' })` will \"revert\" migrations `m1` and `m2` even if they've never been run.\r\n- `umzug.down({ migrations: ['m1', 'm2'], rerun: 'SKIP' })` will skip reverting migrations `m1` and `m2` if they haven't been run or are already reverted.\r\n- `umzug.up({ migrations: ['m1', 'does-not-exist', 'm2'] })` will throw an error if the migration name is not found. Note that the error will be thrown and no migrations run unless _all_ migration names are found - whether or not `rerun: 'ALLOW'` is added.\r\n\r\nThe `context` parameter replaces `params`, and is passed in as a property to migration functions as an options object, alongs side `name` and `path`. This means the signature for migrations, which in v2 was `(context) => Promise<void>`, has changed slightly in v3, to `({ name, path, context }) => Promise<void>`. The `resolve` function can also be used to upgrade your umzug version to v3 when you have existing v2-compatible migrations:\r\n\r\n```js\r\nconst { Umzug } = require('umzug');\r\n\r\nconst umzug = new Umzug({\r\n  migrations: {\r\n    glob: 'migrations/umzug-v2-format/*.js',\r\n    resolve: ({name, path, context}) => {\r\n      // Adjust the migration from the new signature to the v2 signature, making easier to upgrade to v3\r\n      const migration = require(path)\r\n      return { name, up: async () => migration.up(context), down: async () => migration.down(context) }\r\n    }\r\n  },\r\n  context: sequelize.getQueryInterface(),\r\n  logger: console,\r\n});\r\n```\r\n\r\nSimilarly, you no longer need `migrationSorting`, you can use `Umzug#extend` to manipulate migration lists directly:\r\n\r\n```js\r\nconst { Umzug } = require('umzug');\r\n\r\nconst umzug =\r\n  new Umzug({\r\n    migrations: { glob: 'migrations/**/*.js' },\r\n    context: sequelize.getQueryInterface(),\r\n  })\r\n  .extend(migrations => migrations.sort((a, b) => b.path.localeCompare(a.path)));\r\n```\r\n\r\n### Storages\r\n\r\nStorages define where the migration data is stored.\r\n\r\n#### JSON Storage\r\n\r\nUsing `JSONStorage` will create a JSON file which will contain an array with all the executed migrations. You can specify the path to the file. The default for that is `umzug.json` in the working directory of the process.\r\n\r\nDetailed documentation for the options it can take are in the `JSONStorageConstructorOptions` TypeScript interface, which can be found in [src/storage/json.ts](./src/storage/json.ts).\r\n\r\n#### Memory Storage\r\n\r\nUsing `memoryStorage` will store migrations with an in-memory array. This can be useful for proof-of-concepts or tests, since it doesn't interact with databases or filesystems.\r\n\r\nIt doesn't take any options, just import the `memoryStorage` function and call it to return a storage instance:\r\n\r\n```typescript\r\nimport { Umzug, memoryStorage } from 'umzug'\r\n\r\nconst umzug = new Umzug({\r\n  migrations: ...,\r\n  storage: memoryStorage(),\r\n  logger: console,\r\n})\r\n```\r\n\r\n#### Sequelize Storage\r\n\r\nUsing `SequelizeStorage` will create a table in your SQL database called `SequelizeMeta` containing an entry for each executed migration. You will have to pass a configured instance of Sequelize or an existing Sequelize model. Optionally you can specify the model name, table name, or column name. All major Sequelize versions are supported.\r\n\r\nDetailed documentation for the options it can take are in the `_SequelizeStorageConstructorOptions` TypeScript interface, which can be found in [src/storage/sequelize.ts](./src/storage/sequelize.ts).\r\n\r\n#### MongoDB Storage\r\n\r\nUsing `MongoDBStorage` will create a collection in your MongoDB database called `migrations` containing an entry for each executed migration. You will have either to pass a MongoDB Driver Collection as `collection` property. Alternatively you can pass a established MongoDB Driver connection and a collection name.\r\n\r\nDetailed documentation for the options it can take are in the `MongoDBStorageConstructorOptions` TypeScript interface, which can be found in [src/storage/mongodb.ts](./src/storage/mongodb.ts).\r\n\r\n#### Custom\r\n\r\nIn order to use a custom storage, you can pass your storage instance to Umzug constructor.\r\n\r\n```js\r\nclass CustomStorage {\r\n  constructor(...) {...}\r\n  logMigration(...) {...}\r\n  unlogMigration(...) {...}\r\n  executed(...) {...}\r\n}\r\n\r\nconst umzug = new Umzug({ storage: new CustomStorage(...), logger: console })\r\n```\r\n\r\nYour instance must adhere to the [UmzugStorage](./src/storage/contract.ts) interface. If you're using TypeScript you can ensure this at compile time, and get IDE type hints by importing it:\r\n\r\n```typescript\r\nimport { UmzugStorage } from 'umzug'\r\n\r\nclass CustomStorage implements UmzugStorage {\r\n  /* ... */\r\n}\r\n```\r\n\r\n### Events\r\n\r\nUmzug is an [emittery event emitter](https://www.npmjs.com/package/emittery). Each of the following events will be called with migration parameters as its payload (with `context`, `name`, and nullable `path` properties). Events are a convenient place to implement application-specific logic that must run around each migration:\r\n\r\n* `migrating` - A migration is about to be executed.\r\n* `migrated` - A migration has successfully been executed.\r\n* `reverting` - A migration is about to be reverted.\r\n* `reverted` - A migration has successfully been reverted.\r\n\r\nThese events run at the beginning and end of `up` and `down` calls. They'll receive an object containing a `context` property:\r\n\r\n- `beforeCommand` - Before any command (`'up' | 'down' | 'executed' | 'pending'`) is run.\r\n- `afterCommand` - After any command (`'up' | 'down' | 'executed' | 'pending'`) is run. Note: this will always run, even if the command throws an error.\r\n\r\nThe [`FileLocker` class](./src/file-locker.ts) uses `beforeAll` and `afterAll` to implement a simple filesystem-based locking mechanism.\r\n\r\nAll events are type-safe, so IDEs will prevent typos and supply strong types for the event payloads.\r\n\r\n### Errors\r\n\r\nWhen a migration throws an error, it will be wrapped in a `MigrationError` which captures the migration metadata (name, path etc.) as well as the original error message, and _will be rethrown_. In most cases, this is expected behaviour, and doesn't require any special handling beyond standard error logging setups.\r\n\r\nIf you expect failures and want to try to recover from them, you will need to try-catch the call to `umzug.up()`. You can access the original error from the `.cause` property if necessary:\r\n\r\n```js\r\ntry {\r\n  await umzug.up();\r\n} catch (e) {\r\n  if (e instanceof MigrationError) {\r\n    const original = e.cause;\r\n    // do something with the original error here\r\n  }\r\n  throw e;\r\n}\r\n```\r\n\r\nUnder the hood, [verror](https://npmjs.com/package/verror) is used to wrap errors.\r\n\r\n### CLI\r\n\r\n🚧🚧🚧 The CLI is new to Umzug v3 beta and is not yet stable. Feedback on it is welcome in [discussions](https://github.com/sequelize/umzug/discussions) 🚧🚧🚧\r\n\r\nUmzug instances provide a `.runAsCLI()` method. When called, this method will automatically cause your program to become a complete CLI, with help text and such:\r\n\r\n```js\r\n// migrator.js\r\nconst { Umzug } = require('umzug')\r\n\r\nexports.umzug = new Umzug({ ... })\r\n\r\nif (require.main === module) {\r\n  umzug.runAsCLI()\r\n}\r\n```\r\n\r\n#### CLI Usage\r\n\r\nA script like the one above is now a runnable CLI program. You can run `node migrator.js --help` to see how to use it. It will print something like:\r\n\r\n<!-- codegen:start {preset: custom, source: ./codegen.js, export: cliHelp} -->\r\n```\r\nusage: <script> [-h] <command> ...\r\n\r\nUmzug migrator\r\n\r\nPositional arguments:\r\n  <command>\r\n    up        Applies pending migrations\r\n    down      Revert migrations\r\n    pending   Lists pending migrations\r\n    executed  Lists executed migrations\r\n    create    Create a migration file\r\n\r\nOptional arguments:\r\n  -h, --help  Show this help message and exit.\r\n\r\nFor detailed help about a specific command, use: <script> <command> -h\r\n```\r\n<!-- codegen:end -->\r\n\r\n#### Running migrations\r\n\r\n`node migrator up` and `node migrator down` apply and revert migrations respectively. They're the equivalent of the `.up()` and `.down()` methods.\r\n\r\nUse `node migrator up --help` and `node migrator down --help` for options (running \"to\" a specific migration, passing migration names to be run explicitly, and specifying the rerun behavior):\r\n\r\nUp:\r\n<!-- codegen:start {preset: custom, source: ./codegen.js, export: cliHelp, action: up} -->\r\n```\r\nusage: <script> up [-h] [--to NAME] [--step COUNT] [--name MIGRATION]\r\n                   [--rerun {THROW,SKIP,ALLOW}]\r\n                   \r\n\r\nPerforms all migrations. See --help for more options\r\n\r\nOptional arguments:\r\n  -h, --help            Show this help message and exit.\r\n  --to NAME             All migrations up to and including this one should be \r\n                        applied.\r\n  --step COUNT          Run this many migrations. If not specified, all will \r\n                        be applied.\r\n  --name MIGRATION      Explicity declare migration name(s) to be applied.\r\n  --rerun {THROW,SKIP,ALLOW}\r\n                        Specify what action should be taken when a migration \r\n                        that has already been applied is passed to --name. \r\n                        The default value is \"THROW\".\r\n```\r\n<!-- codegen:end -->\r\n\r\nDown:\r\n<!-- codegen:start {preset: custom, source: ./codegen.js, export: cliHelp, action: down} -->\r\n```\r\nusage: <script> down [-h] [--to NAME] [--step COUNT] [--name MIGRATION]\r\n                     [--rerun {THROW,SKIP,ALLOW}]\r\n                     \r\n\r\nUndoes previously-applied migrations. By default, undoes the most recent \r\nmigration only. Use --help for more options. Useful in development to start \r\nfrom a clean slate. Use with care in production!\r\n\r\nOptional arguments:\r\n  -h, --help            Show this help message and exit.\r\n  --to NAME             All migrations up to and including this one should be \r\n                        reverted. Pass \"0\" to revert all.\r\n  --step COUNT          Run this many migrations. If not specified, one will \r\n                        be reverted.\r\n  --name MIGRATION      Explicity declare migration name(s) to be reverted.\r\n  --rerun {THROW,SKIP,ALLOW}\r\n                        Specify what action should be taken when a migration \r\n                        that has already been reverted is passed to --name. \r\n                        The default value is \"THROW\".\r\n```\r\n<!-- codegen:end -->\r\n\r\n\r\n#### Listing migrations\r\n\r\n```bash\r\nnode migrator pending # list migrations yet to be run\r\nnode migrator executed # list migrations that have already run\r\n\r\nnode migrator pending --json # list pending migrations including names and paths, in a json array format\r\nnode migrator executed --json # list executed migrations including names and paths, in a json array format\r\n\r\nnode migrator pending --help # show help/options\r\nnode migrator executed --help # show help/options\r\n```\r\n\r\n<!-- codegen:start {preset: custom, source: ./codegen.js, export: cliHelp, action: pending} -->\r\n```\r\nusage: <script> pending [-h] [--json]\r\n\r\nPrints migrations returned by `umzug.pending()`. By default, prints migration \r\nnames one per line.\r\n\r\nOptional arguments:\r\n  -h, --help  Show this help message and exit.\r\n  --json      Print pending migrations in a json format including names and \r\n              paths. This allows piping output to tools like jq. Without this \r\n              flag, the migration names will be printed one per line.\r\n```\r\n<!-- codegen:end -->\r\n\r\n<!-- codegen:start {preset: custom, source: ./codegen.js, export: cliHelp, action: executed} -->\r\n```\r\nusage: <script> executed [-h] [--json]\r\n\r\nPrints migrations returned by `umzug.executed()`. By default, prints \r\nmigration names one per line.\r\n\r\nOptional arguments:\r\n  -h, --help  Show this help message and exit.\r\n  --json      Print executed migrations in a json format including names and \r\n              paths. This allows piping output to tools like jq. Without this \r\n              flag, the migration names will be printed one per line.\r\n```\r\n<!-- codegen:end -->\r\n\r\n#### Creating migrations - CLI\r\n\r\nUsually, migrations correspond to files on the filesystem. The CLI exposes a way to create migration files easily:\r\n\r\n```bash\r\nnode migrator create --name my-migration.js\r\n```\r\n\r\nThis will create a file with a name like `2000.12.25T12.34.56.my-migration.js` in the same directory as the most recent migration file. If it's the very first migration file, you need to specify the folder explicitly:\r\n\r\n```bash\r\nnode migrator create --name my-migration.js --folder path/to/directory\r\n```\r\n\r\nThe timestamp prefix can be customized to be date-only or omitted, but be aware that it's strongly recommended to ensure your migrations are lexicographically sortable so it's easy for humans and tools to determine what order they should run in - so the default prefix is recommended.\r\n\r\nThis will generate a migration file called `<<timestamp>>.my-migration.js` with the default migration template for `.js` files that ships with Umzug.\r\n\r\nUmzug also ships with default templates for [`.ts`, `.cjs`, `.mjs` and `.sql` files](./src/templates.ts). Umzug will choose the template based on the extension you provide in `name`.\r\n\r\nYou can specify a custom template for your project when constructing an umzug instance via the `template` option. It should be a function which receives a filepath string, and returns an array of `[filepath, content]` pairs. Usually, just one pair is needed, but a second could be used to include a \"down\" migration in a separate file:\r\n\r\n```js\r\nconst umzug = new Umzug({\r\n  migrations: ...,\r\n  template: filepath => [\r\n    [filepath, fs.readFileSync('path/to/your/template/file').toString()],\r\n  ]\r\n})\r\n```\r\n\r\nThe create command includes some safety checks to make sure migrations aren't created with ambiguous ordering, and that they will be picked up by umzug when applying migrations.\r\n\r\nUse `node migrator create --help` for more options:\r\n\r\n<!-- codegen:start {preset: custom, source: ./codegen.js, export: cliHelp, action: create} -->\r\n```\r\nusage: <script> create [-h] --name NAME [--prefix {TIMESTAMP,DATE,NONE}]\r\n                       [--folder PATH] [--allow-extension EXTENSION]\r\n                       [--skip-verify] [--allow-confusing-ordering]\r\n                       \r\n\r\nGenerates a placeholder migration file using a timestamp as a prefix. By \r\ndefault, mimics the last existing migration, or guesses where to generate the \r\nfile if no migration exists yet.\r\n\r\nOptional arguments:\r\n  -h, --help            Show this help message and exit.\r\n  --name NAME           The name of the migration file. e.g. my-migration.js, \r\n                        my-migration.ts or my-migration.sql. Note - a prefix \r\n                        will be added to this name, usually based on a \r\n                        timestamp. See --prefix\r\n  --prefix {TIMESTAMP,DATE,NONE}\r\n                        The prefix format for generated files. TIMESTAMP uses \r\n                        a second-resolution timestamp, DATE uses a \r\n                        day-resolution timestamp, and NONE removes the prefix \r\n                        completely. The default value is \"TIMESTAMP\".\r\n  --folder PATH         Path on the filesystem where the file should be \r\n                        created. The new migration will be created as a \r\n                        sibling of the last existing one if this is omitted.\r\n  --allow-extension EXTENSION\r\n                        Allowable extension for created files. By default .js,\r\n                         .ts and .sql files can be created. To create txt \r\n                        file migrations, for example, you could use '--name \r\n                        my-migration.txt --allow-extension .txt' This \r\n                        parameter may alternatively be specified via the \r\n                        UMZUG_ALLOW_EXTENSION environment variable.\r\n  --skip-verify         By default, the generated file will be checked after \r\n                        creation to make sure it is detected as a pending \r\n                        migration. This catches problems like creation in the \r\n                        wrong folder, or invalid naming conventions. This \r\n                        flag bypasses that verification step.\r\n  --allow-confusing-ordering\r\n                        By default, an error will be thrown if you try to \r\n                        create a migration that will run before a migration \r\n                        that already exists. This catches errors which can \r\n                        cause problems if you change file naming conventions. \r\n                        If you use a custom ordering system, you can disable \r\n                        this behavior, but it's strongly recommended that you \r\n                        don't! If you're unsure, just ignore this option.\r\n```\r\n<!-- codegen:end -->\r\n\r\n### Creating migrations - API\r\n\r\nUmzug includes an optional helper for generating migration files. It's often most convenient to create files using the [CLI helper](#creating-migrations---cli), but the equivalent API also exists on an umzug instance:\r\n\r\n```js\r\nawait umzug.create({ name: 'my-new-migration.js' })\r\n```\r\n\r\n## License\r\n\r\nSee the [LICENSE file](./LICENSE)\r\n","readmeFilename":"README.md","gitHead":"88375345c81edb09044a93443813cb0cc6e3496f","_id":"umzug@3.0.0-beta-cli.17","_nodeVersion":"14.17.3","_npmVersion":"6.14.8","dist":{"integrity":"sha512-ka2yK6jTjZVkMzVudJmb+RzHHEl+CeZTIvKYQ0XqmBxNKdsp626h5V44QFz30nqIh0wrU4+bZ6I2qp64xOud/A==","shasum":"08c54aed10f248683f51c6e2f62dc31c52c6e645","tarball":"https://registry.npmjs.org/umzug/-/umzug-3.0.0-beta-cli.17.tgz","fileCount":40,"unpackedSize":131594,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJhAb6wCRA9TVsSAnZWagAAiyUP/2uZ98bv7RhqPDAmG3rD\n6Y5XQ7B/O6cTpN4jHO6jSG/7KMEEQSaqF7H7EUsEaDGVuTa3NCXoJGIEaEK6\n5GrmEjZJfkL99Yr93zzQhleVPQ6QJ1w+I8QN+vmBj6X6shiD3tEbi/nFub0u\nOAxFP92yQLEw1H4kZJCqPXo4uKpOfqoqPFh6hAsBf5s4mRFws0dr4kxQdHve\nGVWOBjVc5TU8t8prlsIt/USQwd1fq8RXAJQiyjTHTwbXz9Lv8QXM15d7HAll\njLARfmTLO3QCddM6Hgp1L+GRfZMXR/lwc+i2yRjqTTCtWaMFfZxpqKED4Lps\nAFbnJVlAKhAxfvy3GojpXzheYHpndroTk1W+eM4zLnVZyyatXXOVSSMFD1gx\nVNP6kJ6RKUt0MqbqD5Dxq+6YH5CjVySvIgsPCFslKYRGKGtMGVSQeGjehgfA\n2jEJFW1Fjc8veggZCTyvDGGlr87BXIKyiQug4spRqg0CYwJyUzHz7dZJVgL5\nHmn2XBwyNEPdFRROLCHm5DQwFUCTwsRpe+Z1JywV+ssRUa7QtP6qh9/i2Imj\n4D3bqtfmzSaAP6SyW3OmQTQKlHwwmj03GFa5hRkp+OS+JJLpPKb8AWEbwHP3\nnks8Z8Q2dEw4LomoJl2Kp0LRLDZfdVk8pQ3AzYCEBtREcejvQnZ6MwMs+Fpz\ncGjo\r\n=Tsxq\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIBq3BWO9H+YKw9uT35LP+l0q4F5t+hGmEsgxf6YPFu2IAiEA29wm8ezCLWy51RqkefLDVlDQpolaaYiWUKWrmYCicTY="}]},"_npmUser":{"name":"mmkale","email":"mmkal1@outlook.com"},"directories":{},"maintainers":[{"name":"pascal.pflaum","email":"mail@pascalpflaum.de"},{"name":"sdepold","email":"sascha@depold.com"},{"name":"sushantdhiman","email":"sushantdhiman@outlook.com"},{"name":"papb","email":"papb1996@gmail.com"},{"name":"mmkale","email":"mmkal1@outlook.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/umzug_3.0.0-beta-cli.17_1627504304302_0.981614497991057"},"_hasShrinkwrap":false},"3.0.0-beta-cli.18":{"name":"umzug","version":"3.0.0-beta-cli.18","description":"Framework-agnostic migration tool for Node","keywords":["migrate","migration","migrations","sequelize","database"],"main":"lib/index.js","dependencies":{"@rushstack/ts-command-line":"^4.7.7","@types/verror":"^1.10.4","emittery":"^0.10.0","fs-jetpack":"^4.1.0","glob":"^7.1.6","type-fest":"^2.0.0","verror":"^1.10.0"},"devDependencies":{"@types/glob":"7.2.0","@types/jest":"27.0.3","@types/lodash":"4.14.178","@types/uuid":"8.3.3","@typescript-eslint/eslint-plugin":"5.7.0","@typescript-eslint/parser":"5.7.0","del-cli":"4.0.1","eslint":"8.4.1","eslint-config-xo":"0.39.0","eslint-config-xo-typescript":"0.47.1","eslint-plugin-codegen":"0.16.1","eslint-plugin-import":"2.25.3","eslint-plugin-jest":"25.3.0","eslint-plugin-mocha":"10.0.3","eslint-plugin-prettier":"4.0.0","eslint-plugin-unicorn":"39.0.0","expect-type":"0.13.0","fs-syncer":"0.4.0","jest":"27.4.5","lodash":"4.17.21","np":"7.6.0","prettier":"2.5.1","sequelize":"6.11.0","sinon":"12.0.1","source-map-support":"0.5.21","sqlite3":"5.0.2","strip-ansi":"6.0.1","ts-jest":"27.1.1","ts-node":"10.4.0","typescript":"4.5.4","uuid":"8.3.2"},"scripts":{"build":"del-cli lib && tsc -p tsconfig.lib.json","eslint":"eslint --ext .js,.ts,.md . --max-warnings 0","lint":"npm run type-check && npm run eslint","prepare":"npm run build","release":"np --no-yarn --no-2fa","pretest":"del-cli test/generated","test":"jest","type-check":"tsc -p ."},"repository":{"type":"git","url":"git+https://github.com/sequelize/umzug.git"},"author":{"name":"Sascha Depold","email":"sascha@depold.com"},"contributors":[{"name":"Jukka Hyytiälä","email":"hyytiala.jukka@gmail.com"},{"name":"Pascal Pflaum","email":"mail@pascalpflaum.de"},{"name":"Pedro Augusto de Paula Barbosa","email":"papb1996@gmail.com"}],"license":"MIT","bugs":{"url":"https://github.com/sequelize/umzug/issues"},"homepage":"https://github.com/sequelize/umzug","engines":{"node":">=12"},"jest":{"preset":"ts-jest","globals":{"ts-jest":{"diagnostics":false}},"testEnvironment":"node","testMatch":["**/*test.ts"],"collectCoverageFrom":["src/**"]},"readme":"# Umzug\n\n[![Build Status](https://badgen.net/github/checks/sequelize/umzug/master)](https://github.com/sequelize/umzug/actions?query=workflow%3ACI)\n[![npm (stable)](https://badgen.net/npm/v/umzug)](https://www.npmjs.com/package/umzug)\n[![npm (beta)](https://badgen.net/npm/v/umzug/beta)](https://www.npmjs.com/package/umzug/v/beta)\n[![npm (downloads)](https://badgen.net/npm/dm/umzug)](https://npmjs.com/package/umzug)\n\nUmzug is a framework-agnostic migration tool for Node. It provides a clean API for running and rolling back tasks.\n\n_Note: master represents the next major version of umzug - v3 - which is currently in beta. For the stable version, please refer to the [v2.x branch](https://github.com/sequelize/umzug/tree/v2.x)._\n\nTo install the v3-beta package:\n\n```\nnpm install umzug@beta\n```\n\nTo install the stable package (v2.x):\n\n```\nnpm install umzug\n```\n\n## Highlights\n\n* Written in TypeScript\n\t* Built-in typings\n\t* Auto-completion right in your IDE\n\t* Documentation right in your IDE\n* Programmatic API for migrations\n* Built-in [CLI](#cli)\n* Database agnostic\n* Supports logging of migration process\n* Supports multiple storages for migration data\n* [Usage examples](./examples)\n\n## Documentation\n\n### Minimal Example\n\nThe following example uses a Sqlite database through sequelize and persists the migration data in the database itself through the sequelize storage. There are several more involved examples covering a few different scenarios in the [examples folder](./examples).\n\n```js\n// index.js\nconst { Sequelize } = require('sequelize');\nconst { Umzug, SequelizeStorage } = require('umzug');\n\nconst sequelize = new Sequelize({ dialect: 'sqlite', storage: './db.sqlite' });\n\nconst umzug = new Umzug({\n  migrations: { glob: 'migrations/*.js' },\n  context: sequelize.getQueryInterface(),\n  storage: new SequelizeStorage({ sequelize }),\n  logger: console,\n});\n\n(async () => {\n  // Checks migrations and run them if they are not already applied. To keep\n  // track of the executed migrations, a table (and sequelize model) called SequelizeMeta\n  // will be automatically created (if it doesn't exist already) and parsed.\n  await umzug.up();\n})();\n```\n\n```js\n// migrations/00_initial.js\n\nconst { Sequelize } = require('sequelize');\n\nasync function up({ context: queryInterface }) {\n\tawait queryInterface.createTable('users', {\n\t\tid: {\n\t\t\ttype: Sequelize.INTEGER,\n\t\t\tallowNull: false,\n\t\t\tprimaryKey: true\n\t\t},\n\t\tname: {\n\t\t\ttype: Sequelize.STRING,\n\t\t\tallowNull: false\n\t\t},\n\t\tcreatedAt: {\n\t\t\ttype: Sequelize.DATE,\n\t\t\tallowNull: false\n\t\t},\n\t\tupdatedAt: {\n\t\t\ttype: Sequelize.DATE,\n\t\t\tallowNull: false\n\t\t}\n\t});\n}\n\nasync function down({ context: queryInterface }) {\n\tawait queryInterface.dropTable('users');\n}\n\nmodule.exports = { up, down };\n```\n\nNote that we renamed the `context` argument to `queryInterface` for clarity. The `context` is whatever we specified when creating the Umzug instance in `index.js`.\n\n<details>\n<summary>You can also write your migrations in typescript by using `ts-node` in the entrypoint:</summary>\n\n```typescript\n// index.ts\nrequire('ts-node/register')\n\nimport { Sequelize } from 'sequelize';\nimport { Umzug, SequelizeStorage } from 'umzug';\n\nconst sequelize = new Sequelize({ dialect: 'sqlite', storage: './db.sqlite' });\n\nconst umzug = new Umzug({\n  migrations: { glob: 'migrations/*.ts' },\n  context: sequelize.getQueryInterface(),\n  storage: new SequelizeStorage({ sequelize }),\n  logger: console,\n});\n\n// export the type helper exposed by umzug, which will have the `context` argument typed correctly\nexport type Migration = typeof umzug._types.migration;\n\n(async () => {\n  await umzug.up();\n})();\n```\n\n```typescript\n// migrations/00_initial.ts\nimport type { Migration } from '..';\n\n// types will now be available for `queryInterface`\nexport const up: Migration = ({ context: queryInterface }) => queryInterface.createTable(...)\nexport const down: Migration = ({ context: queryInterface }) => queryInterface.dropTable(...)\n```\n</details>\n\nSee [these tests](./test/umzug.test.ts) for more examples of Umzug usage, including:\n\n- passing `ignore` and `cwd` parameters to the glob instructions\n- customising migrations ordering\n- finding migrations from multiple different directories\n- using non-js file extensions via a custom resolver, e.g. `.sql`\n\n### Usage\n\n#### Installation\n\nThe beta version of Umzug is available on npm by specifying the correct tag:\n\n```bash\nnpm install umzug@beta\n```\n\n#### Umzug instance\n\nIt is possible to configure an Umzug instance by passing an object to the constructor.\n\n```js\nconst { Umzug } = require('umzug');\nconst umzug = new Umzug({ /* ... options ... */ });\n```\n\nDetailed documentation for these options are in the `UmzugOptions` TypeScript interface, which can be found in [src/types.ts](./src/types.ts).\n\n#### Getting all pending migrations\n\nYou can get a list of pending (i.e. not yet executed) migrations with the `pending()` method:\n\n```js\nconst migrations = await umzug.pending();\n// returns an array of all pending migrations.\n```\n\n#### Getting all executed migrations\n\nYou can get a list of already executed migrations with the `executed()` method:\n\n```js\nconst migrations = await umzug.executed();\n// returns an array of all already executed migrations\n```\n\n#### Executing pending migrations\n\nThe `up` method can be used to execute all pending migrations.\n\n```js\nconst migrations = await umzug.up();\n// returns an array of all executed migrations\n```\n\nIt is also possible to pass the name of a migration in order to just run the migrations from the current state to the passed migration name (inclusive).\n\n```js\nawait umzug.up({ to: '20141101203500-task' });\n```\n\nTo limit the number of migrations that are run, `step` can be used:\n\n```js\n// This will run the next two migrations\nawait umzug.up({ step: 2 })\n```\n\nRunning specific migrations while ignoring the right order, can be done like this:\n\n```js\nawait umzug.up({ migrations: ['20141101203500-task', '20141101203501-task-2'] });\n```\n\n#### Reverting executed migration\n\nThe `down` method can be used to revert the last executed migration.\n\n```js\nconst migration = await umzug.down();\n// reverts the last migration and returns it.\n```\n\nTo revert more than one migration, you can use `step`:\n\n```js\n// This will revert the last two migrations\nawait umzug.down({ step: 2 });\n```\n\nIt is possible to pass the name of a migration until which (inclusive) the migrations should be reverted. This allows the reverting of multiple migrations at once.\n\n```js\nconst migrations = await umzug.down({ to: '20141031080000-task' });\n// returns an array of all reverted migrations.\n```\n\nTo revert all migrations, you can pass 0 as the `to` parameter:\n\n```js\nawait umzug.down({ to: 0 });\n```\n\nReverting specific migrations while ignoring the right order, can be done like this:\n\n```js\nawait umzug.down({ migrations: ['20141101203500-task', '20141101203501-task-2'] });\n```\n\n### Migrations\n\nThere are two ways to specify migrations: via files or directly via an array of migrations.\n\n#### Migration files\n\nA migration file ideally exposes an `up` and a `down` async functions. They will perform the task of upgrading or downgrading the database.\n\n```js\nmodule.exports = {\n  async up() {\n    /* ... */\n  },\n  async down() {\n    /* ... */\n  }\n};\n```\n\nMigration files can be located anywhere - they will typically be loaded according to a glob pattern provided to the `Umzug` constructor.\n\n#### Direct migrations list\n\nYou can also specify directly a list of migrations to the `Umzug` constructor:\n\n```js\nconst { Umzug } = require('umzug');\n\nconst umzug = new Umzug({\n  migrations: [\n    {\n      // the name of the migration is mandatory\n      name: '00-first-migration',\n      async up({ context }) { /* ... */ },\n      async down({ context }) { /* ... */ }\n    },\n    {\n      name: '01-foo-bar-migration',\n      async up({ context }) { /* ... */ },\n      async down({ context }) { /* ... */ }\n    }\n  ],\n  context: sequelize.getQueryInterface(),\n  logger: console,\n});\n```\n\n#### Modifying the parameters passed to your migration methods\n\nSometimes it's necessary to modify the parameters `umzug` will pass to your migration methods when the library calls the `up` and `down` methods for each migration. This is the case when using migrations currently generated using `sequilize-cli`. In this case you can use the `resolve` fuction during migration configuration to determine which parameters will be passed to the relevant method\n\n```js\nimport { Sequelize } from 'sequelize'\nimport { Umzug, SequelizeStorage } from 'umzug'\n\nconst sequelize = new Sequelize(\n    ...\n)\n\nconst umzug = new Umzug({\n    migrations: {\n        glob: 'migrations/*.js',\n        resolve: ({ name, path, context }) => {\n            const migration = require(path)\n            return {\n                // adjust the parameters Umzug will\n                // pass to migration methods when called\n                name,\n                up: async () => migration.up(context, Sequelize),\n                down: async () => migration.down(context, Sequelize),\n            }\n        },\n    },\n    context: sequelize.getQueryInterface(),\n    storage: new SequelizeStorage({ sequelize }),\n    logger: console,\n});\n```\n\n#### Additional migration configuration options\n\nTo load migrations in another format, you can use the `resolve` function:\n\n```js\nconst { Umzug } = require('umzug')\nconst { Sequelize } = require('sequelize')\nconst fs = require('fs')\n\nconst umzug = new Umzug({\n  migrations: {\n    glob: 'migrations/*.up.sql',\n    resolve: ({ name, path, context: sequelize }) => ({\n      name,\n      up: async () => {\n        const sql = fs.readFileSync(path).toString()\n        return sequelize.query(sql)\n      },\n      down: async () => {\n        // Get the corresponding `.down.sql` file to undo this migration\n        const sql = fs.readFileSync(path.replace('.up.sql', '.down.sql')).toString()\n        return sequelize.query(sql)\n      }\n    })\n  },\n  context: new Sequelize(...),\n  logger: console,\n});\n```\n\nYou can support mixed migration file types, and use umzug's default resolver for javascript/typescript:\n\n```js\nconst { Umzug } = require('umzug')\nconst { Sequelize } = require('sequelize')\nconst fs = require('fs')\n\nconst umzug = new Umzug({\n  migrations: {\n    glob: 'migrations/*.{js,ts,up.sql}',\n    resolve: (params) => {\n      if (!params.path.endsWith('.sql')) {\n        return Umzug.defaultResolver(params)\n      }\n      const { context: sequelize } = params\n      return {\n        name: params.name,\n        up: async () => {\n          const sql = fs.readFileSync(params.path).toString()\n          return sequelize.query(sql)\n        },\n        down: async () => {\n          // Get the corresponding `.down.sql` file to undo this migration\n          const sql = fs.readFileSync(params.path.replace('.up.sql', '.down.sql')).toString()\n          return sequelize.query(sql)\n        }\n      }\n    },\n  },\n  logger: console,\n  context: new Sequelize(...),\n});\n```\n\nThe glob syntax allows loading migrations from multiple locations:\n\n```js\nconst { Umzug } = require('umzug')\nconst { Sequelize } = require('sequelize')\n\nconst umzug = new Umzug({\n  migrations: {\n    glob: '{first-folder/*.js,second-folder-with-different-naming-convention/*.js}',\n  },\n  context: new Sequelize(...),\n  logger: console,\n});\n```\n\nNote on migration file sorting:\n\n- file matches, found using [glob](https://npmjs.com/package/glob), will be lexicographically sorted based on their paths\n  - so if your migrations are `one/m1.js`, `two/m2.js`, `three/m3.js`, the resultant order will be `one/m1.js`, `three/m3.js`, `two/m2.js`\n  - similarly, if your migrations are called `m1.js`, `m2.js`, ... `m10.js`, `m11.js`, the resultant ordering will be `m1.js`, `m10.js`, `m11.js`, ... `m2.js`\n- The easiest way to deal with this is to ensure your migrations appear in a single folder, and their paths match lexicographically with the order they should run in\n- If this isn't possible, the ordering can be customised using a new instance (previously, in the beta release for v3, this could be done with `.extend(...)` - see below for example using a new instance)\n\n### Upgrading from v2.x\n\nThe Umzug class should be imported as a named import, i.e. `import { Umzug } from 'umzug'`.\n\nThe `MigrationMeta` type, which is returned by `umzug.executed()` and `umzug.pending()`, no longer has a `file` property - it has a `name` and *optional* `path` - since migrations are not necessarily bound to files on the file system.\n\nThe `migrations.glob` parameter replaces `path`, `pattern` and `traverseDirectories`. It can be used, in combination with `cwd` and `ignore` to do much more flexible file lookups. See https://npmjs.com/package/glob for more information on the syntax.\n\nThe `migrations.resolve` parameter replaces `customResolver`. Explicit support for `wrap` and `nameFormatter` has been removed - these can be easily implemented in a `resolve` function.\n\nThe constructor option `logging` is replaced by `logger` to allow for `warn` and `error` messages in future. NodeJS's global `console` object can be passed to this. To disable logging, replace `logging: false` with `logger: undefined`.\n\nEvents have moved from the default nodejs `EventEmitter` to [emittery](https://www.npmjs.com/package/emittery). It has better design for async code, a less bloated API surface and strong types. But, it doesn't allow passing multiple arguments to callbacks, so listeners have to change slightly, as well as `.addListener(...)` and `.removeListener(...)` no longer being supported (`.on(...)` and `.off(...)` should now be used):\n\nBefore:\n\n```js\numzug.on('migrating', (name, m) => console.log({ name, path: m.path }))\n```\n\nAfter:\n\n```js\numzug.on('migrating', ev => console.log({ name: ev.name, path: ev.path }))\n```\n\nThe `Umzug#execute` method is removed. Use `Umzug#up` or `Umzug#down`.\n\nThe options for `Umguz#up` and `Umzug#down` have changed:\n- `umzug.up({ to: 'some-name' })` and `umzug.down({ to: 'some-name' })` are still valid.\n- `umzug.up({ from: '...' })` and `umzug.down({ from: '...' })` are no longer supported. To run migrations out-of-order (which is not generally recommended), you can explicitly use `umzug.up({ migrations: ['...'] })` and `umzug.down({ migrations: ['...'] })`.\n- name matches must be exact. `umzug.up({ to: 'some-n' })` will no longer match a migration called `some-name`.\n- `umzug.down({ to: 0 })` is still valid but `umzug.up({ to: 0 })` is not.\n- `umzug.up({ migrations: ['m1', 'm2'] })` is still valid but the shorthand `umzug.up(['m1', 'm2'])` has been removed.\n- `umzug.down({ migrations: ['m1', 'm2'] })` is still valid but the shorthand `umzug.down(['m1', 'm2'])` has been removed.\n- `umzug.up({ migrations: ['m1', 'already-run'] })` will throw an error, if `already-run` is not found in the list of pending migrations.\n- `umzug.down({ migrations: ['m1', 'has-not-been-run'] })` will throw an error, if `has-not-been-run` is not found in the list of executed migrations.\n- `umzug.up({ migrations: ['m1', 'm2'], rerun: 'ALLOW' })` will re-apply migrations `m1` and `m2` even if they've already been run.\n- `umzug.up({ migrations: ['m1', 'm2'], rerun: 'SKIP' })` will skip migrations `m1` and `m2` if they've already been run.\n- `umzug.down({ migrations: ['m1', 'm2'], rerun: 'ALLOW' })` will \"revert\" migrations `m1` and `m2` even if they've never been run.\n- `umzug.down({ migrations: ['m1', 'm2'], rerun: 'SKIP' })` will skip reverting migrations `m1` and `m2` if they haven't been run or are already reverted.\n- `umzug.up({ migrations: ['m1', 'does-not-exist', 'm2'] })` will throw an error if the migration name is not found. Note that the error will be thrown and no migrations run unless _all_ migration names are found - whether or not `rerun: 'ALLOW'` is added.\n\nThe `context` parameter replaces `params`, and is passed in as a property to migration functions as an options object, alongs side `name` and `path`. This means the signature for migrations, which in v2 was `(context) => Promise<void>`, has changed slightly in v3, to `({ name, path, context }) => Promise<void>`. The `resolve` function can also be used to upgrade your umzug version to v3 when you have existing v2-compatible migrations:\n\n```js\nconst { Umzug } = require('umzug');\n\nconst umzug = new Umzug({\n  migrations: {\n    glob: 'migrations/umzug-v2-format/*.js',\n    resolve: ({name, path, context}) => {\n      // Adjust the migration from the new signature to the v2 signature, making easier to upgrade to v3\n      const migration = require(path)\n      return { name, up: async () => migration.up(context), down: async () => migration.down(context) }\n    }\n  },\n  context: sequelize.getQueryInterface(),\n  logger: console,\n});\n```\n\nSimilarly, you no longer need `migrationSorting`, you can instantiate a new `Umzug` instance to manipulate migration lists directly:\n\n```js\nconst { Umzug } = require('umzug');\n\nconst parent = new Umzug({\n  migrations: { glob: 'migrations/**/*.js' },\n  context: sequelize.getQueryInterface(),\n})\n\nconst umzug = new Umzug({\n  ...parent.options,\n  migrations: ctx => (await parent.migrations()).sort((a, b) => b.path.localeCompare(a.path))\n})\n```\n\n### Storages\n\nStorages define where the migration data is stored.\n\n#### JSON Storage\n\nUsing `JSONStorage` will create a JSON file which will contain an array with all the executed migrations. You can specify the path to the file. The default for that is `umzug.json` in the working directory of the process.\n\nDetailed documentation for the options it can take are in the `JSONStorageConstructorOptions` TypeScript interface, which can be found in [src/storage/json.ts](./src/storage/json.ts).\n\n#### Memory Storage\n\nUsing `memoryStorage` will store migrations with an in-memory array. This can be useful for proof-of-concepts or tests, since it doesn't interact with databases or filesystems.\n\nIt doesn't take any options, just import the `memoryStorage` function and call it to return a storage instance:\n\n```typescript\nimport { Umzug, memoryStorage } from 'umzug'\n\nconst umzug = new Umzug({\n  migrations: ...,\n  storage: memoryStorage(),\n  logger: console,\n})\n```\n\n#### Sequelize Storage\n\nUsing `SequelizeStorage` will create a table in your SQL database called `SequelizeMeta` containing an entry for each executed migration. You will have to pass a configured instance of Sequelize or an existing Sequelize model. Optionally you can specify the model name, table name, or column name. All major Sequelize versions are supported.\n\nDetailed documentation for the options it can take are in the `_SequelizeStorageConstructorOptions` TypeScript interface, which can be found in [src/storage/sequelize.ts](./src/storage/sequelize.ts).\n\nThis library has been tested with sequelize v6. It may or may not work with lower versions - use at your own risk.\n\n#### MongoDB Storage\n\nUsing `MongoDBStorage` will create a collection in your MongoDB database called `migrations` containing an entry for each executed migration. You will have either to pass a MongoDB Driver Collection as `collection` property. Alternatively you can pass a established MongoDB Driver connection and a collection name.\n\nDetailed documentation for the options it can take are in the `MongoDBStorageConstructorOptions` TypeScript interface, which can be found in [src/storage/mongodb.ts](./src/storage/mongodb.ts).\n\n#### Custom\n\nIn order to use a custom storage, you can pass your storage instance to Umzug constructor.\n\n```js\nclass CustomStorage {\n  constructor(...) {...}\n  logMigration(...) {...}\n  unlogMigration(...) {...}\n  executed(...) {...}\n}\n\nconst umzug = new Umzug({ storage: new CustomStorage(...), logger: console })\n```\n\nYour instance must adhere to the [UmzugStorage](./src/storage/contract.ts) interface. If you're using TypeScript you can ensure this at compile time, and get IDE type hints by importing it:\n\n```typescript\nimport { UmzugStorage } from 'umzug'\n\nclass CustomStorage implements UmzugStorage {\n  /* ... */\n}\n```\n\n### Events\n\nUmzug is an [emittery event emitter](https://www.npmjs.com/package/emittery). Each of the following events will be called with migration parameters as its payload (with `context`, `name`, and nullable `path` properties). Events are a convenient place to implement application-specific logic that must run around each migration:\n\n* `migrating` - A migration is about to be executed.\n* `migrated` - A migration has successfully been executed.\n* `reverting` - A migration is about to be reverted.\n* `reverted` - A migration has successfully been reverted.\n\nThese events run at the beginning and end of `up` and `down` calls. They'll receive an object containing a `context` property:\n\n- `beforeCommand` - Before any command (`'up' | 'down' | 'executed' | 'pending'`) is run.\n- `afterCommand` - After any command (`'up' | 'down' | 'executed' | 'pending'`) is run. Note: this will always run, even if the command throws an error.\n\nThe [`FileLocker` class](./src/file-locker.ts) uses `beforeAll` and `afterAll` to implement a simple filesystem-based locking mechanism.\n\nAll events are type-safe, so IDEs will prevent typos and supply strong types for the event payloads.\n\n### Errors\n\nWhen a migration throws an error, it will be wrapped in a `MigrationError` which captures the migration metadata (name, path etc.) as well as the original error message, and _will be rethrown_. In most cases, this is expected behaviour, and doesn't require any special handling beyond standard error logging setups.\n\nIf you expect failures and want to try to recover from them, you will need to try-catch the call to `umzug.up()`. You can access the original error from the `.cause` property if necessary:\n\n```js\ntry {\n  await umzug.up();\n} catch (e) {\n  if (e instanceof MigrationError) {\n    const original = e.cause;\n    // do something with the original error here\n  }\n  throw e;\n}\n```\n\nUnder the hood, [verror](https://npmjs.com/package/verror) is used to wrap errors.\n\n### CLI\n\n🚧🚧🚧 The CLI is new to Umzug v3 beta and is not yet stable. Feedback on it is welcome in [discussions](https://github.com/sequelize/umzug/discussions) 🚧🚧🚧\n\nUmzug instances provide a `.runAsCLI()` method. When called, this method will automatically cause your program to become a complete CLI, with help text and such:\n\n```js\n// migrator.js\nconst { Umzug } = require('umzug')\n\nconst umzug = new Umzug({ ... })\n\nexports.umzug = umzug\n\nif (require.main === module) {\n  umzug.runAsCLI()\n}\n```\n\n#### CLI Usage\n\nA script like the one above is now a runnable CLI program. You can run `node migrator.js --help` to see how to use it. It will print something like:\n\n<!-- codegen:start {preset: custom, source: ./codegen.js, export: cliHelp} -->\n```\nusage: <script> [-h] <command> ...\n\nUmzug migrator\n\nPositional arguments:\n  <command>\n    up        Applies pending migrations\n    down      Revert migrations\n    pending   Lists pending migrations\n    executed  Lists executed migrations\n    create    Create a migration file\n\nOptional arguments:\n  -h, --help  Show this help message and exit.\n\nFor detailed help about a specific command, use: <script> <command> -h\n```\n<!-- codegen:end -->\n\n#### Running migrations\n\n`node migrator up` and `node migrator down` apply and revert migrations respectively. They're the equivalent of the `.up()` and `.down()` methods.\n\nUse `node migrator up --help` and `node migrator down --help` for options (running \"to\" a specific migration, passing migration names to be run explicitly, and specifying the rerun behavior):\n\nUp:\n<!-- codegen:start {preset: custom, source: ./codegen.js, export: cliHelp, action: up} -->\n```\nusage: <script> up [-h] [--to NAME] [--step COUNT] [--name MIGRATION]\n                   [--rerun {THROW,SKIP,ALLOW}]\n                   \n\nPerforms all migrations. See --help for more options\n\nOptional arguments:\n  -h, --help            Show this help message and exit.\n  --to NAME             All migrations up to and including this one should be \n                        applied.\n  --step COUNT          Run this many migrations. If not specified, all will \n                        be applied.\n  --name MIGRATION      Explicity declare migration name(s) to be applied.\n  --rerun {THROW,SKIP,ALLOW}\n                        Specify what action should be taken when a migration \n                        that has already been applied is passed to --name. \n                        The default value is \"THROW\".\n```\n<!-- codegen:end -->\n\nDown:\n<!-- codegen:start {preset: custom, source: ./codegen.js, export: cliHelp, action: down} -->\n```\nusage: <script> down [-h] [--to NAME] [--step COUNT] [--name MIGRATION]\n                     [--rerun {THROW,SKIP,ALLOW}]\n                     \n\nUndoes previously-applied migrations. By default, undoes the most recent \nmigration only. Use --help for more options. Useful in development to start \nfrom a clean slate. Use with care in production!\n\nOptional arguments:\n  -h, --help            Show this help message and exit.\n  --to NAME             All migrations up to and including this one should be \n                        reverted. Pass \"0\" to revert all.\n  --step COUNT          Run this many migrations. If not specified, one will \n                        be reverted.\n  --name MIGRATION      Explicity declare migration name(s) to be reverted.\n  --rerun {THROW,SKIP,ALLOW}\n                        Specify what action should be taken when a migration \n                        that has already been reverted is passed to --name. \n                        The default value is \"THROW\".\n```\n<!-- codegen:end -->\n\n\n#### Listing migrations\n\n```bash\nnode migrator pending # list migrations yet to be run\nnode migrator executed # list migrations that have already run\n\nnode migrator pending --json # list pending migrations including names and paths, in a json array format\nnode migrator executed --json # list executed migrations including names and paths, in a json array format\n\nnode migrator pending --help # show help/options\nnode migrator executed --help # show help/options\n```\n\n<!-- codegen:start {preset: custom, source: ./codegen.js, export: cliHelp, action: pending} -->\n```\nusage: <script> pending [-h] [--json]\n\nPrints migrations returned by `umzug.pending()`. By default, prints migration \nnames one per line.\n\nOptional arguments:\n  -h, --help  Show this help message and exit.\n  --json      Print pending migrations in a json format including names and \n              paths. This allows piping output to tools like jq. Without this \n              flag, the migration names will be printed one per line.\n```\n<!-- codegen:end -->\n\n<!-- codegen:start {preset: custom, source: ./codegen.js, export: cliHelp, action: executed} -->\n```\nusage: <script> executed [-h] [--json]\n\nPrints migrations returned by `umzug.executed()`. By default, prints \nmigration names one per line.\n\nOptional arguments:\n  -h, --help  Show this help message and exit.\n  --json      Print executed migrations in a json format including names and \n              paths. This allows piping output to tools like jq. Without this \n              flag, the migration names will be printed one per line.\n```\n<!-- codegen:end -->\n\n#### Creating migrations - CLI\n\nUsually, migrations correspond to files on the filesystem. The CLI exposes a way to create migration files easily:\n\n```bash\nnode migrator create --name my-migration.js\n```\n\nThis will create a file with a name like `2000.12.25T12.34.56.my-migration.js` in the same directory as the most recent migration file. If it's the very first migration file, you need to specify the folder explicitly:\n\n```bash\nnode migrator create --name my-migration.js --folder path/to/directory\n```\n\nThe timestamp prefix can be customized to be date-only or omitted, but be aware that it's strongly recommended to ensure your migrations are lexicographically sortable so it's easy for humans and tools to determine what order they should run in - so the default prefix is recommended.\n\nThis will generate a migration file called `<<timestamp>>.my-migration.js` with the default migration template for `.js` files that ships with Umzug.\n\nUmzug also ships with default templates for [`.ts`, `.cjs`, `.mjs` and `.sql` files](./src/templates.ts). Umzug will choose the template based on the extension you provide in `name`.\n\nYou can specify a custom template for your project when constructing an umzug instance via the `template` option. It should be a function which receives a filepath string, and returns an array of `[filepath, content]` pairs. Usually, just one pair is needed, but a second could be used to include a \"down\" migration in a separate file:\n\n```js\nconst umzug = new Umzug({\n  migrations: ...,\n\tcreate: {\n\t\ttemplate: filepath => [\n\t\t\t[filepath, fs.readFileSync('path/to/your/template/file').toString()],\n\t\t]\n\t}\n})\n```\n\nThe create command includes some safety checks to make sure migrations aren't created with ambiguous ordering, and that they will be picked up by umzug when applying migrations.\n\nUse `node migrator create --help` for more options:\n\n<!-- codegen:start {preset: custom, source: ./codegen.js, export: cliHelp, action: create} -->\n```\nusage: <script> create [-h] --name NAME [--prefix {TIMESTAMP,DATE,NONE}]\n                       [--folder PATH] [--allow-extension EXTENSION]\n                       [--skip-verify] [--allow-confusing-ordering]\n                       \n\nGenerates a placeholder migration file using a timestamp as a prefix. By \ndefault, mimics the last existing migration, or guesses where to generate the \nfile if no migration exists yet.\n\nOptional arguments:\n  -h, --help            Show this help message and exit.\n  --name NAME           The name of the migration file. e.g. my-migration.js, \n                        my-migration.ts or my-migration.sql. Note - a prefix \n                        will be added to this name, usually based on a \n                        timestamp. See --prefix\n  --prefix {TIMESTAMP,DATE,NONE}\n                        The prefix format for generated files. TIMESTAMP uses \n                        a second-resolution timestamp, DATE uses a \n                        day-resolution timestamp, and NONE removes the prefix \n                        completely. The default value is \"TIMESTAMP\".\n  --folder PATH         Path on the filesystem where the file should be \n                        created. The new migration will be created as a \n                        sibling of the last existing one if this is omitted.\n  --allow-extension EXTENSION\n                        Allowable extension for created files. By default .js,\n                         .ts and .sql files can be created. To create txt \n                        file migrations, for example, you could use '--name \n                        my-migration.txt --allow-extension .txt' This \n                        parameter may alternatively be specified via the \n                        UMZUG_ALLOW_EXTENSION environment variable.\n  --skip-verify         By default, the generated file will be checked after \n                        creation to make sure it is detected as a pending \n                        migration. This catches problems like creation in the \n                        wrong folder, or invalid naming conventions. This \n                        flag bypasses that verification step.\n  --allow-confusing-ordering\n                        By default, an error will be thrown if you try to \n                        create a migration that will run before a migration \n                        that already exists. This catches errors which can \n                        cause problems if you change file naming conventions. \n                        If you use a custom ordering system, you can disable \n                        this behavior, but it's strongly recommended that you \n                        don't! If you're unsure, just ignore this option.\n```\n<!-- codegen:end -->\n\n### Creating migrations - API\n\nUmzug includes an optional helper for generating migration files. It's often most convenient to create files using the [CLI helper](#creating-migrations---cli), but the equivalent API also exists on an umzug instance:\n\n```js\nawait umzug.create({ name: 'my-new-migration.js' })\n```\n\n## License\n\nSee the [LICENSE file](./LICENSE)\n","readmeFilename":"README.md","gitHead":"b62ebb4d7b8404331f78073ac9ea8b81ac024b21","_id":"umzug@3.0.0-beta-cli.18","_nodeVersion":"14.17.0","_npmVersion":"6.14.13","dist":{"integrity":"sha512-CzXhjOZdz/KtpMq90bsR6hI7m2ZZMgm4uPr7mvqEhGZ0HTUoNHvmYlG0YsgLnvgb9r2mflkwa3T+VdfF2viqBA==","shasum":"22c9b65a6d114196eb95e3035314bc985da3623e","tarball":"https://registry.npmjs.org/umzug/-/umzug-3.0.0-beta-cli.18.tgz","fileCount":40,"unpackedSize":131216,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJhuqrhCRA9TVsSAnZWagAAcigP/ihSkmLJoHXlVhPsDiad\ny1qQZfoetsG9NawKDtggUoZz8J7BW9yNMRDySfw1xXZQFaBiyQc3fN4iRsGN\nqvSRaDZtsC6J9mkkzqv9QZBQai9yRhgK7bc66bi2uwAkb9Z9w7wT3c3uIrgw\nkSw7584uOUl0iM69oG8VUGYAY0RvinXb4hNeyB04MGWJvEZxSoD4Jv2burm0\nkT77mnM/Zra2McaN8o9Cwc11Xfb1FtzggeKzVfLUSWecJGgaM4HcEzWCqKJE\nQIOu0Sk5hDoUh2fJ0tKTIunOn9I9iTWdUCYfxVLMg7DoPYk/Zl0Lr5A+nSE/\nqwJK35sSb/XHsuSmihIhpzyJ48f4mia8NrmUxTCKlln5aXUC+tMzFa6a40/d\n/f/d054LETamGXj+SNIxdzR8bk5r1ai+DvMBEZPbx2/rUP22SXylUhTJyJT6\nBHnGz0wUIo57N+kt62sSqfG+ORqN/4oX/eYb/hyOlkS99QgkviEMkLCqfaau\nlEPX24fNvNNJay9ePv08pnZdbuMCWG+nGdhgEqHh9gECgh0iGVYExgmpcS6+\ntZEfaahQzOdAONzYzOipSa5Xrdy+U1Qq3N6QOc4FYArebtToJWVVtsZ4Dg0y\nvw27IfCQppWP+8JPhxtaBw82afqJ4A8KF42dfAI8DyGpFgHtXCZbgCp1xWtg\nQDNB\r\n=+3dF\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIBPfS/VPDPpJQo8dHNHBKGoEarBDxU4ONlNm2uJAmLQgAiEA6u/BGUhzsHZmBVqj1AkmUrsd4JHkLe/unhJe09jmEm0="}]},"_npmUser":{"name":"mmkale","email":"mmkal1@outlook.com"},"directories":{},"maintainers":[{"name":"pascal.pflaum","email":"mail@pascalpflaum.de"},{"name":"sdepold","email":"sascha@depold.com"},{"name":"sushantdhiman","email":"sushantdhiman@outlook.com"},{"name":"papb","email":"papb1996@gmail.com"},{"name":"mmkale","email":"mmkal1@outlook.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/umzug_3.0.0-beta-cli.18_1639623393612_0.3397818141596698"},"_hasShrinkwrap":false},"3.0.0-beta-cli.19":{"name":"umzug","version":"3.0.0-beta-cli.19","description":"Framework-agnostic migration tool for Node","keywords":["migrate","migration","migrations","sequelize","database"],"main":"lib/index.js","dependencies":{"@rushstack/ts-command-line":"^4.7.7","@types/verror":"^1.10.4","emittery":"^0.10.0","fs-jetpack":"^4.1.0","glob":"^7.1.6","type-fest":"^2.0.0","verror":"^1.10.0"},"devDependencies":{"@types/glob":"7.2.0","@types/jest":"27.0.3","@types/lodash":"4.14.178","@types/uuid":"8.3.3","@typescript-eslint/eslint-plugin":"5.7.0","@typescript-eslint/parser":"5.7.0","del-cli":"4.0.1","eslint":"8.4.1","eslint-config-xo":"0.39.0","eslint-config-xo-typescript":"0.47.1","eslint-plugin-codegen":"0.16.1","eslint-plugin-import":"2.25.3","eslint-plugin-jest":"25.3.0","eslint-plugin-mocha":"10.0.3","eslint-plugin-prettier":"4.0.0","eslint-plugin-unicorn":"39.0.0","expect-type":"0.13.0","fs-syncer":"0.4.0","jest":"27.4.5","lodash":"4.17.21","np":"7.6.0","prettier":"2.5.1","sequelize":"6.11.0","sinon":"12.0.1","source-map-support":"0.5.21","sqlite3":"5.0.2","strip-ansi":"6.0.1","ts-jest":"27.1.1","ts-node":"10.4.0","typescript":"4.5.4","uuid":"8.3.2"},"scripts":{"build":"del-cli lib && tsc -p tsconfig.lib.json","eslint":"eslint --ext .js,.ts,.md . --max-warnings 0","lint":"npm run type-check && npm run eslint","prepare":"npm run build","release":"np --no-yarn --no-2fa","pretest":"del-cli test/generated","test":"jest","type-check":"tsc -p ."},"repository":{"type":"git","url":"git+https://github.com/sequelize/umzug.git"},"author":{"name":"Sascha Depold","email":"sascha@depold.com"},"contributors":[{"name":"Jukka Hyytiälä","email":"hyytiala.jukka@gmail.com"},{"name":"Pascal Pflaum","email":"mail@pascalpflaum.de"},{"name":"Pedro Augusto de Paula Barbosa","email":"papb1996@gmail.com"}],"license":"MIT","bugs":{"url":"https://github.com/sequelize/umzug/issues"},"homepage":"https://github.com/sequelize/umzug","engines":{"node":">=12"},"jest":{"preset":"ts-jest","globals":{"ts-jest":{"diagnostics":false}},"testEnvironment":"node","testMatch":["**/*test.ts"],"collectCoverageFrom":["src/**"]},"readme":"# Umzug\n\n[![Build Status](https://badgen.net/github/checks/sequelize/umzug/master)](https://github.com/sequelize/umzug/actions?query=workflow%3ACI)\n[![npm (stable)](https://badgen.net/npm/v/umzug)](https://www.npmjs.com/package/umzug)\n[![npm (beta)](https://badgen.net/npm/v/umzug/beta)](https://www.npmjs.com/package/umzug/v/beta)\n[![npm (downloads)](https://badgen.net/npm/dm/umzug)](https://npmjs.com/package/umzug)\n\nUmzug is a framework-agnostic migration tool for Node. It provides a clean API for running and rolling back tasks.\n\n_Note: master represents the next major version of umzug - v3 - which is currently in beta. For the stable version, please refer to the [v2.x branch](https://github.com/sequelize/umzug/tree/v2.x)._\n\nTo install the v3-beta package:\n\n```\nnpm install umzug@beta\n```\n\nTo install the stable package (v2.x):\n\n```\nnpm install umzug\n```\n\n## Highlights\n\n* Written in TypeScript\n\t* Built-in typings\n\t* Auto-completion right in your IDE\n\t* Documentation right in your IDE\n* Programmatic API for migrations\n* Built-in [CLI](#cli)\n* Database agnostic\n* Supports logging of migration process\n* Supports multiple storages for migration data\n* [Usage examples](./examples)\n\n## Documentation\n\n### Minimal Example\n\nThe following example uses a Sqlite database through sequelize and persists the migration data in the database itself through the sequelize storage. There are several more involved examples covering a few different scenarios in the [examples folder](./examples).\n\n```js\n// index.js\nconst { Sequelize } = require('sequelize');\nconst { Umzug, SequelizeStorage } = require('umzug');\n\nconst sequelize = new Sequelize({ dialect: 'sqlite', storage: './db.sqlite' });\n\nconst umzug = new Umzug({\n  migrations: { glob: 'migrations/*.js' },\n  context: sequelize.getQueryInterface(),\n  storage: new SequelizeStorage({ sequelize }),\n  logger: console,\n});\n\n(async () => {\n  // Checks migrations and run them if they are not already applied. To keep\n  // track of the executed migrations, a table (and sequelize model) called SequelizeMeta\n  // will be automatically created (if it doesn't exist already) and parsed.\n  await umzug.up();\n})();\n```\n\n```js\n// migrations/00_initial.js\n\nconst { Sequelize } = require('sequelize');\n\nasync function up({ context: queryInterface }) {\n\tawait queryInterface.createTable('users', {\n\t\tid: {\n\t\t\ttype: Sequelize.INTEGER,\n\t\t\tallowNull: false,\n\t\t\tprimaryKey: true\n\t\t},\n\t\tname: {\n\t\t\ttype: Sequelize.STRING,\n\t\t\tallowNull: false\n\t\t},\n\t\tcreatedAt: {\n\t\t\ttype: Sequelize.DATE,\n\t\t\tallowNull: false\n\t\t},\n\t\tupdatedAt: {\n\t\t\ttype: Sequelize.DATE,\n\t\t\tallowNull: false\n\t\t}\n\t});\n}\n\nasync function down({ context: queryInterface }) {\n\tawait queryInterface.dropTable('users');\n}\n\nmodule.exports = { up, down };\n```\n\nNote that we renamed the `context` argument to `queryInterface` for clarity. The `context` is whatever we specified when creating the Umzug instance in `index.js`.\n\n<details>\n<summary>You can also write your migrations in typescript by using `ts-node` in the entrypoint:</summary>\n\n```typescript\n// index.ts\nrequire('ts-node/register')\n\nimport { Sequelize } from 'sequelize';\nimport { Umzug, SequelizeStorage } from 'umzug';\n\nconst sequelize = new Sequelize({ dialect: 'sqlite', storage: './db.sqlite' });\n\nconst umzug = new Umzug({\n  migrations: { glob: 'migrations/*.ts' },\n  context: sequelize.getQueryInterface(),\n  storage: new SequelizeStorage({ sequelize }),\n  logger: console,\n});\n\n// export the type helper exposed by umzug, which will have the `context` argument typed correctly\nexport type Migration = typeof umzug._types.migration;\n\n(async () => {\n  await umzug.up();\n})();\n```\n\n```typescript\n// migrations/00_initial.ts\nimport type { Migration } from '..';\n\n// types will now be available for `queryInterface`\nexport const up: Migration = ({ context: queryInterface }) => queryInterface.createTable(...)\nexport const down: Migration = ({ context: queryInterface }) => queryInterface.dropTable(...)\n```\n</details>\n\nSee [these tests](./test/umzug.test.ts) for more examples of Umzug usage, including:\n\n- passing `ignore` and `cwd` parameters to the glob instructions\n- customising migrations ordering\n- finding migrations from multiple different directories\n- using non-js file extensions via a custom resolver, e.g. `.sql`\n\n### Usage\n\n#### Installation\n\nThe beta version of Umzug is available on npm by specifying the correct tag:\n\n```bash\nnpm install umzug@beta\n```\n\n#### Umzug instance\n\nIt is possible to configure an Umzug instance by passing an object to the constructor.\n\n```js\nconst { Umzug } = require('umzug');\nconst umzug = new Umzug({ /* ... options ... */ });\n```\n\nDetailed documentation for these options are in the `UmzugOptions` TypeScript interface, which can be found in [src/types.ts](./src/types.ts).\n\n#### Getting all pending migrations\n\nYou can get a list of pending (i.e. not yet executed) migrations with the `pending()` method:\n\n```js\nconst migrations = await umzug.pending();\n// returns an array of all pending migrations.\n```\n\n#### Getting all executed migrations\n\nYou can get a list of already executed migrations with the `executed()` method:\n\n```js\nconst migrations = await umzug.executed();\n// returns an array of all already executed migrations\n```\n\n#### Executing pending migrations\n\nThe `up` method can be used to execute all pending migrations.\n\n```js\nconst migrations = await umzug.up();\n// returns an array of all executed migrations\n```\n\nIt is also possible to pass the name of a migration in order to just run the migrations from the current state to the passed migration name (inclusive).\n\n```js\nawait umzug.up({ to: '20141101203500-task' });\n```\n\nTo limit the number of migrations that are run, `step` can be used:\n\n```js\n// This will run the next two migrations\nawait umzug.up({ step: 2 })\n```\n\nRunning specific migrations while ignoring the right order, can be done like this:\n\n```js\nawait umzug.up({ migrations: ['20141101203500-task', '20141101203501-task-2'] });\n```\n\n#### Reverting executed migration\n\nThe `down` method can be used to revert the last executed migration.\n\n```js\nconst migration = await umzug.down();\n// reverts the last migration and returns it.\n```\n\nTo revert more than one migration, you can use `step`:\n\n```js\n// This will revert the last two migrations\nawait umzug.down({ step: 2 });\n```\n\nIt is possible to pass the name of a migration until which (inclusive) the migrations should be reverted. This allows the reverting of multiple migrations at once.\n\n```js\nconst migrations = await umzug.down({ to: '20141031080000-task' });\n// returns an array of all reverted migrations.\n```\n\nTo revert all migrations, you can pass 0 as the `to` parameter:\n\n```js\nawait umzug.down({ to: 0 });\n```\n\nReverting specific migrations while ignoring the right order, can be done like this:\n\n```js\nawait umzug.down({ migrations: ['20141101203500-task', '20141101203501-task-2'] });\n```\n\n### Migrations\n\nThere are two ways to specify migrations: via files or directly via an array of migrations.\n\n#### Migration files\n\nA migration file ideally exposes an `up` and a `down` async functions. They will perform the task of upgrading or downgrading the database.\n\n```js\nmodule.exports = {\n  async up() {\n    /* ... */\n  },\n  async down() {\n    /* ... */\n  }\n};\n```\n\nMigration files can be located anywhere - they will typically be loaded according to a glob pattern provided to the `Umzug` constructor.\n\n#### Direct migrations list\n\nYou can also specify directly a list of migrations to the `Umzug` constructor:\n\n```js\nconst { Umzug } = require('umzug');\n\nconst umzug = new Umzug({\n  migrations: [\n    {\n      // the name of the migration is mandatory\n      name: '00-first-migration',\n      async up({ context }) { /* ... */ },\n      async down({ context }) { /* ... */ }\n    },\n    {\n      name: '01-foo-bar-migration',\n      async up({ context }) { /* ... */ },\n      async down({ context }) { /* ... */ }\n    }\n  ],\n  context: sequelize.getQueryInterface(),\n  logger: console,\n});\n```\n\n#### Modifying the parameters passed to your migration methods\n\nSometimes it's necessary to modify the parameters `umzug` will pass to your migration methods when the library calls the `up` and `down` methods for each migration. This is the case when using migrations currently generated using `sequilize-cli`. In this case you can use the `resolve` fuction during migration configuration to determine which parameters will be passed to the relevant method\n\n```js\nimport { Sequelize } from 'sequelize'\nimport { Umzug, SequelizeStorage } from 'umzug'\n\nconst sequelize = new Sequelize(\n    ...\n)\n\nconst umzug = new Umzug({\n    migrations: {\n        glob: 'migrations/*.js',\n        resolve: ({ name, path, context }) => {\n            const migration = require(path)\n            return {\n                // adjust the parameters Umzug will\n                // pass to migration methods when called\n                name,\n                up: async () => migration.up(context, Sequelize),\n                down: async () => migration.down(context, Sequelize),\n            }\n        },\n    },\n    context: sequelize.getQueryInterface(),\n    storage: new SequelizeStorage({ sequelize }),\n    logger: console,\n});\n```\n\n#### Additional migration configuration options\n\nTo load migrations in another format, you can use the `resolve` function:\n\n```js\nconst { Umzug } = require('umzug')\nconst { Sequelize } = require('sequelize')\nconst fs = require('fs')\n\nconst umzug = new Umzug({\n  migrations: {\n    glob: 'migrations/*.up.sql',\n    resolve: ({ name, path, context: sequelize }) => ({\n      name,\n      up: async () => {\n        const sql = fs.readFileSync(path).toString()\n        return sequelize.query(sql)\n      },\n      down: async () => {\n        // Get the corresponding `.down.sql` file to undo this migration\n        const sql = fs.readFileSync(path.replace('.up.sql', '.down.sql')).toString()\n        return sequelize.query(sql)\n      }\n    })\n  },\n  context: new Sequelize(...),\n  logger: console,\n});\n```\n\nYou can support mixed migration file types, and use umzug's default resolver for javascript/typescript:\n\n```js\nconst { Umzug } = require('umzug')\nconst { Sequelize } = require('sequelize')\nconst fs = require('fs')\n\nconst umzug = new Umzug({\n  migrations: {\n    glob: 'migrations/*.{js,ts,up.sql}',\n    resolve: (params) => {\n      if (!params.path.endsWith('.sql')) {\n        return Umzug.defaultResolver(params)\n      }\n      const { context: sequelize } = params\n      return {\n        name: params.name,\n        up: async () => {\n          const sql = fs.readFileSync(params.path).toString()\n          return sequelize.query(sql)\n        },\n        down: async () => {\n          // Get the corresponding `.down.sql` file to undo this migration\n          const sql = fs.readFileSync(params.path.replace('.up.sql', '.down.sql')).toString()\n          return sequelize.query(sql)\n        }\n      }\n    },\n  },\n  logger: console,\n  context: new Sequelize(...),\n});\n```\n\nThe glob syntax allows loading migrations from multiple locations:\n\n```js\nconst { Umzug } = require('umzug')\nconst { Sequelize } = require('sequelize')\n\nconst umzug = new Umzug({\n  migrations: {\n    glob: '{first-folder/*.js,second-folder-with-different-naming-convention/*.js}',\n  },\n  context: new Sequelize(...),\n  logger: console,\n});\n```\n\nNote on migration file sorting:\n\n- file matches, found using [glob](https://npmjs.com/package/glob), will be lexicographically sorted based on their paths\n  - so if your migrations are `one/m1.js`, `two/m2.js`, `three/m3.js`, the resultant order will be `one/m1.js`, `three/m3.js`, `two/m2.js`\n  - similarly, if your migrations are called `m1.js`, `m2.js`, ... `m10.js`, `m11.js`, the resultant ordering will be `m1.js`, `m10.js`, `m11.js`, ... `m2.js`\n- The easiest way to deal with this is to ensure your migrations appear in a single folder, and their paths match lexicographically with the order they should run in\n- If this isn't possible, the ordering can be customised using a new instance (previously, in the beta release for v3, this could be done with `.extend(...)` - see below for example using a new instance)\n\n### Upgrading from v2.x\n\nThe Umzug class should be imported as a named import, i.e. `import { Umzug } from 'umzug'`.\n\nThe `MigrationMeta` type, which is returned by `umzug.executed()` and `umzug.pending()`, no longer has a `file` property - it has a `name` and *optional* `path` - since migrations are not necessarily bound to files on the file system.\n\nThe `migrations.glob` parameter replaces `path`, `pattern` and `traverseDirectories`. It can be used, in combination with `cwd` and `ignore` to do much more flexible file lookups. See https://npmjs.com/package/glob for more information on the syntax.\n\nThe `migrations.resolve` parameter replaces `customResolver`. Explicit support for `wrap` and `nameFormatter` has been removed - these can be easily implemented in a `resolve` function.\n\nThe constructor option `logging` is replaced by `logger` to allow for `warn` and `error` messages in future. NodeJS's global `console` object can be passed to this. To disable logging, replace `logging: false` with `logger: undefined`.\n\nEvents have moved from the default nodejs `EventEmitter` to [emittery](https://www.npmjs.com/package/emittery). It has better design for async code, a less bloated API surface and strong types. But, it doesn't allow passing multiple arguments to callbacks, so listeners have to change slightly, as well as `.addListener(...)` and `.removeListener(...)` no longer being supported (`.on(...)` and `.off(...)` should now be used):\n\nBefore:\n\n```js\numzug.on('migrating', (name, m) => console.log({ name, path: m.path }))\n```\n\nAfter:\n\n```js\numzug.on('migrating', ev => console.log({ name: ev.name, path: ev.path }))\n```\n\nThe `Umzug#execute` method is removed. Use `Umzug#up` or `Umzug#down`.\n\nThe options for `Umguz#up` and `Umzug#down` have changed:\n- `umzug.up({ to: 'some-name' })` and `umzug.down({ to: 'some-name' })` are still valid.\n- `umzug.up({ from: '...' })` and `umzug.down({ from: '...' })` are no longer supported. To run migrations out-of-order (which is not generally recommended), you can explicitly use `umzug.up({ migrations: ['...'] })` and `umzug.down({ migrations: ['...'] })`.\n- name matches must be exact. `umzug.up({ to: 'some-n' })` will no longer match a migration called `some-name`.\n- `umzug.down({ to: 0 })` is still valid but `umzug.up({ to: 0 })` is not.\n- `umzug.up({ migrations: ['m1', 'm2'] })` is still valid but the shorthand `umzug.up(['m1', 'm2'])` has been removed.\n- `umzug.down({ migrations: ['m1', 'm2'] })` is still valid but the shorthand `umzug.down(['m1', 'm2'])` has been removed.\n- `umzug.up({ migrations: ['m1', 'already-run'] })` will throw an error, if `already-run` is not found in the list of pending migrations.\n- `umzug.down({ migrations: ['m1', 'has-not-been-run'] })` will throw an error, if `has-not-been-run` is not found in the list of executed migrations.\n- `umzug.up({ migrations: ['m1', 'm2'], rerun: 'ALLOW' })` will re-apply migrations `m1` and `m2` even if they've already been run.\n- `umzug.up({ migrations: ['m1', 'm2'], rerun: 'SKIP' })` will skip migrations `m1` and `m2` if they've already been run.\n- `umzug.down({ migrations: ['m1', 'm2'], rerun: 'ALLOW' })` will \"revert\" migrations `m1` and `m2` even if they've never been run.\n- `umzug.down({ migrations: ['m1', 'm2'], rerun: 'SKIP' })` will skip reverting migrations `m1` and `m2` if they haven't been run or are already reverted.\n- `umzug.up({ migrations: ['m1', 'does-not-exist', 'm2'] })` will throw an error if the migration name is not found. Note that the error will be thrown and no migrations run unless _all_ migration names are found - whether or not `rerun: 'ALLOW'` is added.\n\nThe `context` parameter replaces `params`, and is passed in as a property to migration functions as an options object, alongs side `name` and `path`. This means the signature for migrations, which in v2 was `(context) => Promise<void>`, has changed slightly in v3, to `({ name, path, context }) => Promise<void>`. The `resolve` function can also be used to upgrade your umzug version to v3 when you have existing v2-compatible migrations:\n\n```js\nconst { Umzug } = require('umzug');\n\nconst umzug = new Umzug({\n  migrations: {\n    glob: 'migrations/umzug-v2-format/*.js',\n    resolve: ({name, path, context}) => {\n      // Adjust the migration from the new signature to the v2 signature, making easier to upgrade to v3\n      const migration = require(path)\n      return { name, up: async () => migration.up(context), down: async () => migration.down(context) }\n    }\n  },\n  context: sequelize.getQueryInterface(),\n  logger: console,\n});\n```\n\nSimilarly, you no longer need `migrationSorting`, you can instantiate a new `Umzug` instance to manipulate migration lists directly:\n\n```js\nconst { Umzug } = require('umzug');\n\nconst parent = new Umzug({\n  migrations: { glob: 'migrations/**/*.js' },\n  context: sequelize.getQueryInterface(),\n})\n\nconst umzug = new Umzug({\n  ...parent.options,\n  migrations: ctx => (await parent.migrations()).sort((a, b) => b.path.localeCompare(a.path))\n})\n```\n\n### Storages\n\nStorages define where the migration data is stored.\n\n#### JSON Storage\n\nUsing `JSONStorage` will create a JSON file which will contain an array with all the executed migrations. You can specify the path to the file. The default for that is `umzug.json` in the working directory of the process.\n\nDetailed documentation for the options it can take are in the `JSONStorageConstructorOptions` TypeScript interface, which can be found in [src/storage/json.ts](./src/storage/json.ts).\n\n#### Memory Storage\n\nUsing `memoryStorage` will store migrations with an in-memory array. This can be useful for proof-of-concepts or tests, since it doesn't interact with databases or filesystems.\n\nIt doesn't take any options, just import the `memoryStorage` function and call it to return a storage instance:\n\n```typescript\nimport { Umzug, memoryStorage } from 'umzug'\n\nconst umzug = new Umzug({\n  migrations: ...,\n  storage: memoryStorage(),\n  logger: console,\n})\n```\n\n#### Sequelize Storage\n\nUsing `SequelizeStorage` will create a table in your SQL database called `SequelizeMeta` containing an entry for each executed migration. You will have to pass a configured instance of Sequelize or an existing Sequelize model. Optionally you can specify the model name, table name, or column name. All major Sequelize versions are supported.\n\nDetailed documentation for the options it can take are in the `_SequelizeStorageConstructorOptions` TypeScript interface, which can be found in [src/storage/sequelize.ts](./src/storage/sequelize.ts).\n\nThis library has been tested with sequelize v6. It may or may not work with lower versions - use at your own risk.\n\n#### MongoDB Storage\n\nUsing `MongoDBStorage` will create a collection in your MongoDB database called `migrations` containing an entry for each executed migration. You will have either to pass a MongoDB Driver Collection as `collection` property. Alternatively you can pass a established MongoDB Driver connection and a collection name.\n\nDetailed documentation for the options it can take are in the `MongoDBStorageConstructorOptions` TypeScript interface, which can be found in [src/storage/mongodb.ts](./src/storage/mongodb.ts).\n\n#### Custom\n\nIn order to use a custom storage, you can pass your storage instance to Umzug constructor.\n\n```js\nclass CustomStorage {\n  constructor(...) {...}\n  logMigration(...) {...}\n  unlogMigration(...) {...}\n  executed(...) {...}\n}\n\nconst umzug = new Umzug({ storage: new CustomStorage(...), logger: console })\n```\n\nYour instance must adhere to the [UmzugStorage](./src/storage/contract.ts) interface. If you're using TypeScript you can ensure this at compile time, and get IDE type hints by importing it:\n\n```typescript\nimport { UmzugStorage } from 'umzug'\n\nclass CustomStorage implements UmzugStorage {\n  /* ... */\n}\n```\n\n### Events\n\nUmzug is an [emittery event emitter](https://www.npmjs.com/package/emittery). Each of the following events will be called with migration parameters as its payload (with `context`, `name`, and nullable `path` properties). Events are a convenient place to implement application-specific logic that must run around each migration:\n\n* `migrating` - A migration is about to be executed.\n* `migrated` - A migration has successfully been executed.\n* `reverting` - A migration is about to be reverted.\n* `reverted` - A migration has successfully been reverted.\n\nThese events run at the beginning and end of `up` and `down` calls. They'll receive an object containing a `context` property:\n\n- `beforeCommand` - Before any command (`'up' | 'down' | 'executed' | 'pending'`) is run.\n- `afterCommand` - After any command (`'up' | 'down' | 'executed' | 'pending'`) is run. Note: this will always run, even if the command throws an error.\n\nThe [`FileLocker` class](./src/file-locker.ts) uses `beforeAll` and `afterAll` to implement a simple filesystem-based locking mechanism.\n\nAll events are type-safe, so IDEs will prevent typos and supply strong types for the event payloads.\n\n### Errors\n\nWhen a migration throws an error, it will be wrapped in a `MigrationError` which captures the migration metadata (name, path etc.) as well as the original error message, and _will be rethrown_. In most cases, this is expected behaviour, and doesn't require any special handling beyond standard error logging setups.\n\nIf you expect failures and want to try to recover from them, you will need to try-catch the call to `umzug.up()`. You can access the original error from the `.cause` property if necessary:\n\n```js\ntry {\n  await umzug.up();\n} catch (e) {\n  if (e instanceof MigrationError) {\n    const original = e.cause;\n    // do something with the original error here\n  }\n  throw e;\n}\n```\n\nUnder the hood, [verror](https://npmjs.com/package/verror) is used to wrap errors.\n\n### CLI\n\n🚧🚧🚧 The CLI is new to Umzug v3 beta and is not yet stable. Feedback on it is welcome in [discussions](https://github.com/sequelize/umzug/discussions) 🚧🚧🚧\n\nUmzug instances provide a `.runAsCLI()` method. When called, this method will automatically cause your program to become a complete CLI, with help text and such:\n\n```js\n// migrator.js\nconst { Umzug } = require('umzug')\n\nconst umzug = new Umzug({ ... })\n\nexports.umzug = umzug\n\nif (require.main === module) {\n  umzug.runAsCLI()\n}\n```\n\n#### CLI Usage\n\nA script like the one above is now a runnable CLI program. You can run `node migrator.js --help` to see how to use it. It will print something like:\n\n<!-- codegen:start {preset: custom, source: ./codegen.js, export: cliHelp} -->\n```\nusage: <script> [-h] <command> ...\n\nUmzug migrator\n\nPositional arguments:\n  <command>\n    up        Applies pending migrations\n    down      Revert migrations\n    pending   Lists pending migrations\n    executed  Lists executed migrations\n    create    Create a migration file\n\nOptional arguments:\n  -h, --help  Show this help message and exit.\n\nFor detailed help about a specific command, use: <script> <command> -h\n```\n<!-- codegen:end -->\n\n#### Running migrations\n\n`node migrator up` and `node migrator down` apply and revert migrations respectively. They're the equivalent of the `.up()` and `.down()` methods.\n\nUse `node migrator up --help` and `node migrator down --help` for options (running \"to\" a specific migration, passing migration names to be run explicitly, and specifying the rerun behavior):\n\nUp:\n<!-- codegen:start {preset: custom, source: ./codegen.js, export: cliHelp, action: up} -->\n```\nusage: <script> up [-h] [--to NAME] [--step COUNT] [--name MIGRATION]\n                   [--rerun {THROW,SKIP,ALLOW}]\n                   \n\nPerforms all migrations. See --help for more options\n\nOptional arguments:\n  -h, --help            Show this help message and exit.\n  --to NAME             All migrations up to and including this one should be \n                        applied.\n  --step COUNT          Run this many migrations. If not specified, all will \n                        be applied.\n  --name MIGRATION      Explicity declare migration name(s) to be applied.\n  --rerun {THROW,SKIP,ALLOW}\n                        Specify what action should be taken when a migration \n                        that has already been applied is passed to --name. \n                        The default value is \"THROW\".\n```\n<!-- codegen:end -->\n\nDown:\n<!-- codegen:start {preset: custom, source: ./codegen.js, export: cliHelp, action: down} -->\n```\nusage: <script> down [-h] [--to NAME] [--step COUNT] [--name MIGRATION]\n                     [--rerun {THROW,SKIP,ALLOW}]\n                     \n\nUndoes previously-applied migrations. By default, undoes the most recent \nmigration only. Use --help for more options. Useful in development to start \nfrom a clean slate. Use with care in production!\n\nOptional arguments:\n  -h, --help            Show this help message and exit.\n  --to NAME             All migrations up to and including this one should be \n                        reverted. Pass \"0\" to revert all.\n  --step COUNT          Run this many migrations. If not specified, one will \n                        be reverted.\n  --name MIGRATION      Explicity declare migration name(s) to be reverted.\n  --rerun {THROW,SKIP,ALLOW}\n                        Specify what action should be taken when a migration \n                        that has already been reverted is passed to --name. \n                        The default value is \"THROW\".\n```\n<!-- codegen:end -->\n\n\n#### Listing migrations\n\n```bash\nnode migrator pending # list migrations yet to be run\nnode migrator executed # list migrations that have already run\n\nnode migrator pending --json # list pending migrations including names and paths, in a json array format\nnode migrator executed --json # list executed migrations including names and paths, in a json array format\n\nnode migrator pending --help # show help/options\nnode migrator executed --help # show help/options\n```\n\n<!-- codegen:start {preset: custom, source: ./codegen.js, export: cliHelp, action: pending} -->\n```\nusage: <script> pending [-h] [--json]\n\nPrints migrations returned by `umzug.pending()`. By default, prints migration \nnames one per line.\n\nOptional arguments:\n  -h, --help  Show this help message and exit.\n  --json      Print pending migrations in a json format including names and \n              paths. This allows piping output to tools like jq. Without this \n              flag, the migration names will be printed one per line.\n```\n<!-- codegen:end -->\n\n<!-- codegen:start {preset: custom, source: ./codegen.js, export: cliHelp, action: executed} -->\n```\nusage: <script> executed [-h] [--json]\n\nPrints migrations returned by `umzug.executed()`. By default, prints \nmigration names one per line.\n\nOptional arguments:\n  -h, --help  Show this help message and exit.\n  --json      Print executed migrations in a json format including names and \n              paths. This allows piping output to tools like jq. Without this \n              flag, the migration names will be printed one per line.\n```\n<!-- codegen:end -->\n\n#### Creating migrations - CLI\n\nUsually, migrations correspond to files on the filesystem. The CLI exposes a way to create migration files easily:\n\n```bash\nnode migrator create --name my-migration.js\n```\n\nThis will create a file with a name like `2000.12.25T12.34.56.my-migration.js` in the same directory as the most recent migration file. If it's the very first migration file, you need to specify the folder explicitly:\n\n```bash\nnode migrator create --name my-migration.js --folder path/to/directory\n```\n\nThe timestamp prefix can be customized to be date-only or omitted, but be aware that it's strongly recommended to ensure your migrations are lexicographically sortable so it's easy for humans and tools to determine what order they should run in - so the default prefix is recommended.\n\nThis will generate a migration file called `<<timestamp>>.my-migration.js` with the default migration template for `.js` files that ships with Umzug.\n\nUmzug also ships with default templates for [`.ts`, `.cjs`, `.mjs` and `.sql` files](./src/templates.ts). Umzug will choose the template based on the extension you provide in `name`.\n\nYou can specify a custom template for your project when constructing an umzug instance via the `template` option. It should be a function which receives a filepath string, and returns an array of `[filepath, content]` pairs. Usually, just one pair is needed, but a second could be used to include a \"down\" migration in a separate file:\n\n```js\nconst umzug = new Umzug({\n  migrations: ...,\n\tcreate: {\n\t\ttemplate: filepath => [\n\t\t\t[filepath, fs.readFileSync('path/to/your/template/file').toString()],\n\t\t]\n\t}\n})\n```\n\nThe create command includes some safety checks to make sure migrations aren't created with ambiguous ordering, and that they will be picked up by umzug when applying migrations.\n\nUse `node migrator create --help` for more options:\n\n<!-- codegen:start {preset: custom, source: ./codegen.js, export: cliHelp, action: create} -->\n```\nusage: <script> create [-h] --name NAME [--prefix {TIMESTAMP,DATE,NONE}]\n                       [--folder PATH] [--allow-extension EXTENSION]\n                       [--skip-verify] [--allow-confusing-ordering]\n                       \n\nGenerates a placeholder migration file using a timestamp as a prefix. By \ndefault, mimics the last existing migration, or guesses where to generate the \nfile if no migration exists yet.\n\nOptional arguments:\n  -h, --help            Show this help message and exit.\n  --name NAME           The name of the migration file. e.g. my-migration.js, \n                        my-migration.ts or my-migration.sql. Note - a prefix \n                        will be added to this name, usually based on a \n                        timestamp. See --prefix\n  --prefix {TIMESTAMP,DATE,NONE}\n                        The prefix format for generated files. TIMESTAMP uses \n                        a second-resolution timestamp, DATE uses a \n                        day-resolution timestamp, and NONE removes the prefix \n                        completely. The default value is \"TIMESTAMP\".\n  --folder PATH         Path on the filesystem where the file should be \n                        created. The new migration will be created as a \n                        sibling of the last existing one if this is omitted.\n  --allow-extension EXTENSION\n                        Allowable extension for created files. By default .js,\n                         .ts and .sql files can be created. To create txt \n                        file migrations, for example, you could use '--name \n                        my-migration.txt --allow-extension .txt' This \n                        parameter may alternatively be specified via the \n                        UMZUG_ALLOW_EXTENSION environment variable.\n  --skip-verify         By default, the generated file will be checked after \n                        creation to make sure it is detected as a pending \n                        migration. This catches problems like creation in the \n                        wrong folder, or invalid naming conventions. This \n                        flag bypasses that verification step.\n  --allow-confusing-ordering\n                        By default, an error will be thrown if you try to \n                        create a migration that will run before a migration \n                        that already exists. This catches errors which can \n                        cause problems if you change file naming conventions. \n                        If you use a custom ordering system, you can disable \n                        this behavior, but it's strongly recommended that you \n                        don't! If you're unsure, just ignore this option.\n```\n<!-- codegen:end -->\n\n### Creating migrations - API\n\nUmzug includes an optional helper for generating migration files. It's often most convenient to create files using the [CLI helper](#creating-migrations---cli), but the equivalent API also exists on an umzug instance:\n\n```js\nawait umzug.create({ name: 'my-new-migration.js' })\n```\n\n## License\n\nSee the [LICENSE file](./LICENSE)\n","readmeFilename":"README.md","gitHead":"c8d011ee958feb94436722d1d21d886e21040097","_id":"umzug@3.0.0-beta-cli.19","_nodeVersion":"14.17.0","_npmVersion":"6.14.13","dist":{"integrity":"sha512-8+fxTfekjziQ/2hlCcrnmbZrkwZn1dcldRE1t72qQJQK+KXPdbzyfoV8U9WDXSzPJ6zklDRl/PpFZcZ4y6zwNQ==","shasum":"f522084c521abc0380f3ad4c43af75784d20a432","tarball":"https://registry.npmjs.org/umzug/-/umzug-3.0.0-beta-cli.19.tgz","fileCount":40,"unpackedSize":131216,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJhuqvgCRA9TVsSAnZWagAAFPQQAJx01iApmMYWnxkeE+S5\nnUVRmfIq/cWQMt4tgkH6xX1iVSn2t2c/RXPjrGmtek5KUcGQO/RUGjqDKfRT\nXfLs2SSmnRVgRNPRv1B9s7W5aE9aRz2fDb9PUucvxS/81N5rW+cP1GYXLAsc\nJFb58Fu6xZgMTdL1ovRG/kiTvkEWRlAkvY5jJzoQm7Ghhglk1serrTxKoZUA\nyr4UmRNgB/gmPLZz/WKe2mocxa4Az9HtYEvtnM1xgBLR+AMklSanhzbVwRdz\nNSB+x10RvOMA2m3sxtXsAnMxyChiCkjPeWEjOee4k+nf6UIk3Tz893GZScbb\n5dsPIm8TcdMDPAP8nuIiQ7dVn+bw3Ga3WQyziQXnGIZ6dZoMQnRg7XZlqY7n\nAZu/beSSqrxxN/o2+ob4wTkv1qwMrlTiuSWfzhTltseCCHZM88a7f8wc64rB\nW4hZ1oF+2mJOQK22oNunWzgfNsLXVzb06tIpuJOzsSDMMXMOS5nkyRcM6IWZ\nrfaRCAOiAKYFKDN4qD+J/IOjwsJhbrRRU5DDePUEB5EyENvqm1pQ44HLcGQU\ndGfcbdB8v66xU3VEKiNAdhpP032CVAkO9QxE1Uff1tP/Jji0jDrh2oQQJ2TN\nGWO3L/1OL7xUaTDP5G8JeXJUC7M5a/kd/Hmm9LmG/6iIaEt2hm5HPuJCQ0Ki\nQiVl\r\n=emLI\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEYCIQDM5XogIFjS6H7659LGsn69RTUi67W/T0Yzamwo08jLEgIhAM/jdQPITIoYkk3B6QXDRY29lbnQSbw1MPNEwSmKJyFI"}]},"_npmUser":{"name":"mmkale","email":"mmkal1@outlook.com"},"directories":{},"maintainers":[{"name":"pascal.pflaum","email":"mail@pascalpflaum.de"},{"name":"sdepold","email":"sascha@depold.com"},{"name":"sushantdhiman","email":"sushantdhiman@outlook.com"},{"name":"papb","email":"papb1996@gmail.com"},{"name":"mmkale","email":"mmkal1@outlook.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/umzug_3.0.0-beta-cli.19_1639623648842_0.5032421740697812"},"_hasShrinkwrap":false},"3.0.0-beta.19":{"name":"umzug","version":"3.0.0-beta.19","description":"Framework-agnostic migration tool for Node","keywords":["migrate","migration","migrations","sequelize","database"],"main":"lib/index.js","dependencies":{"@rushstack/ts-command-line":"^4.7.7","@types/verror":"^1.10.4","emittery":"^0.10.0","fs-jetpack":"^4.1.0","glob":"^7.1.6","type-fest":"^2.0.0","verror":"^1.10.0"},"devDependencies":{"@types/glob":"7.2.0","@types/jest":"27.0.3","@types/lodash":"4.14.178","@types/uuid":"8.3.3","@typescript-eslint/eslint-plugin":"5.7.0","@typescript-eslint/parser":"5.7.0","del-cli":"4.0.1","eslint":"8.4.1","eslint-config-xo":"0.39.0","eslint-config-xo-typescript":"0.47.1","eslint-plugin-codegen":"0.16.1","eslint-plugin-import":"2.25.3","eslint-plugin-jest":"25.3.0","eslint-plugin-mocha":"10.0.3","eslint-plugin-prettier":"4.0.0","eslint-plugin-unicorn":"39.0.0","expect-type":"0.13.0","fs-syncer":"0.4.0","jest":"27.4.5","lodash":"4.17.21","np":"7.6.0","prettier":"2.5.1","sequelize":"6.11.0","sinon":"12.0.1","source-map-support":"0.5.21","sqlite3":"5.0.2","strip-ansi":"6.0.1","ts-jest":"27.1.1","ts-node":"10.4.0","typescript":"4.5.4","uuid":"8.3.2"},"scripts":{"build":"del-cli lib && tsc -p tsconfig.lib.json","eslint":"eslint --ext .js,.ts,.md . --max-warnings 0","lint":"npm run type-check && npm run eslint","prepare":"npm run build","release":"np --no-yarn --no-2fa","pretest":"del-cli test/generated","test":"jest","type-check":"tsc -p ."},"repository":{"type":"git","url":"git+https://github.com/sequelize/umzug.git"},"author":{"name":"Sascha Depold","email":"sascha@depold.com"},"contributors":[{"name":"Jukka Hyytiälä","email":"hyytiala.jukka@gmail.com"},{"name":"Pascal Pflaum","email":"mail@pascalpflaum.de"},{"name":"Pedro Augusto de Paula Barbosa","email":"papb1996@gmail.com"}],"license":"MIT","bugs":{"url":"https://github.com/sequelize/umzug/issues"},"homepage":"https://github.com/sequelize/umzug","engines":{"node":">=12"},"jest":{"preset":"ts-jest","globals":{"ts-jest":{"diagnostics":false}},"testEnvironment":"node","testMatch":["**/*test.ts"],"collectCoverageFrom":["src/**"]},"gitHead":"c8d011ee958feb94436722d1d21d886e21040097","_id":"umzug@3.0.0-beta.19","_nodeVersion":"14.17.0","_npmVersion":"6.14.13","dist":{"integrity":"sha512-oZ16QeFT0U5rkUI356eXvwlNl4JR3nooVD0Dn+xSd8Qbbm2vvLdmyOEzXOnMFJAB5DJagLIUmlis+ulFY/EziQ==","shasum":"4862003f7ce263c9a44216cb4df4df9ec298e5d1","tarball":"https://registry.npmjs.org/umzug/-/umzug-3.0.0-beta.19.tgz","fileCount":40,"unpackedSize":131211,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJhuqwfCRA9TVsSAnZWagAAbZkP/jykhedsP3nxRmFlTWpn\nZ1xtIjUQf+nrETOT5h2xK/090/qAYFDIbvZIQDfHwJ5gEqhCUj01PPVpC8N8\n85T11ipBvM7U4V7rkIYm6iLNP/3lFx0vZJLurv3MnrW2wqXC7FtKl628iEFa\n3g6/COXU9iYFm7+vP/ZzmKsPNAz6ihaDc7A/dEMoACxANEYZstOW8+yrjY6L\nCTPG9BYRUrQfATv+hjV7wS8pSHdKrMZ6QLC8z9RTyqYX72F77RAmO2+YOnTC\n9+CXUMtT92kO5OMxOCLpzRRSYU91Nu18OXlzEWYA6eGyGiI+bBeQcCT+GGr/\njFZ3Lorfq60V8YACOVTpfe6i5mwyc3gJ+DtJLEmaaaL5nwLk0yU5DbV9CEi8\nA63Lpo3yaJmRW+QpCPxzAxavrIyGO8XRzGoVrvQmn3W8v70CmR3Yf+a90Kj7\nhBZNBy0MebePFtz8swKeDnzgos92M0Ly7CYpGn+lM116PbVpn664P0WNLVcF\nBF93705apzZSKVRCABjPsbPud55aALjA1HbiTopz9Toz8JTLajM4HrIjeRwe\nKUrQCF9wkM18V/u4HcMWmgIf20EYHRihzzRom63uaFIpqDjJ/UtdSQvXNyzZ\n5BoeRGxgMGgODYkzAWlme5fjU4meURanWoL1cPwxSaucVxnciIKIvvcRVP+a\nUc2q\r\n=/GbR\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEQCIAFShY9w3R0WFfRmJ68aJQR38mz2jpIIr+SOV6EzCszKAiA1Y6Na6Nbjh+/AHeGkMe1+lyKKzP4uQyETCT6p9uzqgw=="}]},"_npmUser":{"name":"mmkale","email":"mmkal1@outlook.com"},"directories":{},"maintainers":[{"name":"pascal.pflaum","email":"mail@pascalpflaum.de"},{"name":"sdepold","email":"sascha@depold.com"},{"name":"sushantdhiman","email":"sushantdhiman@outlook.com"},{"name":"papb","email":"papb1996@gmail.com"},{"name":"mmkale","email":"mmkal1@outlook.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/umzug_3.0.0-beta.19_1639623711702_0.4641809539133759"},"_hasShrinkwrap":false},"3.0.0":{"name":"umzug","version":"3.0.0","description":"Framework-agnostic migration tool for Node","keywords":["migrate","migration","migrations","sequelize","database"],"main":"lib/index.js","dependencies":{"@rushstack/ts-command-line":"^4.7.7","@types/verror":"^1.10.4","emittery":"^0.10.0","fs-jetpack":"^4.1.0","glob":"^7.1.6","type-fest":"^2.0.0","verror":"^1.10.0"},"devDependencies":{"@types/glob":"7.2.0","@types/jest":"27.0.3","@types/lodash":"4.14.178","@types/uuid":"8.3.3","@typescript-eslint/eslint-plugin":"5.7.0","@typescript-eslint/parser":"5.7.0","del-cli":"4.0.1","eslint":"8.4.1","eslint-config-xo":"0.39.0","eslint-config-xo-typescript":"0.47.1","eslint-plugin-codegen":"0.16.1","eslint-plugin-import":"2.25.3","eslint-plugin-jest":"25.3.0","eslint-plugin-mocha":"10.0.3","eslint-plugin-prettier":"4.0.0","eslint-plugin-unicorn":"39.0.0","expect-type":"0.13.0","fs-syncer":"0.4.0","jest":"27.4.5","lodash":"4.17.21","np":"7.6.0","prettier":"2.5.1","sequelize":"6.11.0","sinon":"12.0.1","source-map-support":"0.5.21","sqlite3":"npm:@vscode/sqlite3@^5.0.7","strip-ansi":"6.0.1","ts-jest":"27.1.1","ts-node":"10.4.0","typescript":"4.5.4","uuid":"8.3.2"},"scripts":{"build":"del-cli lib && tsc -p tsconfig.lib.json","eslint":"eslint --ext .js,.ts,.md . --max-warnings 0","lint":"npm run type-check && npm run eslint","prepare":"npm run build","release":"np --no-yarn --no-2fa","pretest":"del-cli test/generated","test":"jest","type-check":"tsc -p ."},"repository":{"type":"git","url":"git+https://github.com/sequelize/umzug.git"},"author":{"name":"Sascha Depold","email":"sascha@depold.com"},"contributors":[{"name":"Misha Kaletsky","email":"mmkal@kaletsky.com"},{"name":"Jukka Hyytiälä","email":"hyytiala.jukka@gmail.com"},{"name":"Pascal Pflaum","email":"mail@pascalpflaum.de"},{"name":"Pedro Augusto de Paula Barbosa","email":"papb1996@gmail.com"}],"license":"MIT","bugs":{"url":"https://github.com/sequelize/umzug/issues"},"homepage":"https://github.com/sequelize/umzug","engines":{"node":">=12"},"jest":{"preset":"ts-jest","globals":{"ts-jest":{"diagnostics":false}},"testEnvironment":"node","testMatch":["**/*test.ts"],"collectCoverageFrom":["src/**"]},"gitHead":"534f16a9b975579d30aeaad3eed80544480ce20f","_id":"umzug@3.0.0","_nodeVersion":"14.17.0","_npmVersion":"6.14.13","dist":{"integrity":"sha512-uHeJsOJ7qtoIkZmtknpg+iSlI25m7glBA237pYp5fMsEKnRfRY+F4FP8eGx28g6b0VujkniC6Zlz09lbDFuBbw==","shasum":"de19183c0bce7e79d432f746ad423b68b38d485a","tarball":"https://registry.npmjs.org/umzug/-/umzug-3.0.0.tgz","fileCount":40,"unpackedSize":131283,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJhvIhHCRA9TVsSAnZWagAA/noQAJWi2lZCg1oClm5hKLWJ\nHjZEfBsfi14OP0dkYOFOCj4s9t0LKD5Xl3Nq7wC4PGz2qcQorGlG6rFNAX4D\nCUSV2a9AFG/wdOeppSd/Fjsju39/nDgTRqgGCseg/ltZuy5pXDQqoFTYQPCg\nZa+LX1tn67xHYt/iEONhT22lLyU/3TEgIyqdBkyqsg8VWtWQsslNSTkEWZjx\nikhmCXuIbzr/J2JD+yOSg+wAYCvt52T54GAnHbqiMb0JRRY8aUavC7GPpl2J\nNi2PxfnBnZKQe9wTj0aoId7cfx4bDKbbDC/r0m/ikxBgB73Rw4nVvkEmOYsB\n23xzfzTC/usMZ2944oLyEI+YXIrv4JZ+c265yi3/b6U4exCttiGcjv8wtNWN\n5CeE7bQxVoVr4hy2ouM4/5zAzMQRcKGZfT2nG2Jw6bJLSi3OJvBdeyW0eSDh\nqZAfKLY8Juy6fPnZIieQTHlUVAOcnW3OCcUx8mV/xo3YX5MnFWpyORESmp6r\nnDEXhcrXXP2Y4NoUvZ1dpBx4pWHgvRQF575dizWb3lBiaSBjB0fFqrsxha03\nqOO/7qWRRcDvFY+U5kfhJ/aqHOc8S3uIoZHeVX6TVPYg7IF6KbVmh6qZNb4/\ns18rhfAwYXu1jgCbq941ADojubV6Acfxhcj8k6XxAZjTeEOSumwzwCPUgWSA\noiGg\r\n=QmbV\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEQCIHjLjq2AHWrb+mKY2KDuodNPyKZ8ctcIfSuluPC8v2weAiBIa6dGktqZ6ZeOVIa7b+pikAXxUOOWyOvZZYaiQhVwNg=="}]},"_npmUser":{"name":"mmkale","email":"mmkal1@outlook.com"},"directories":{},"maintainers":[{"name":"pascal.pflaum","email":"mail@pascalpflaum.de"},{"name":"sdepold","email":"sascha@depold.com"},{"name":"sushantdhiman","email":"sushantdhiman@outlook.com"},{"name":"papb","email":"papb1996@gmail.com"},{"name":"mmkale","email":"mmkal1@outlook.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/umzug_3.0.0_1639745607609_0.9123409178739212"},"_hasShrinkwrap":false},"3.1.0":{"name":"umzug","version":"3.1.0","description":"Framework-agnostic migration tool for Node","keywords":["migrate","migration","migrations","sequelize","database"],"main":"lib/index.js","dependencies":{"@rushstack/ts-command-line":"^4.7.7","emittery":"^0.10.0","fs-jetpack":"^4.1.0","glob":"^7.1.6","pony-cause":"^1.1.1","type-fest":"^2.0.0"},"devDependencies":{"@types/glob":"7.2.0","@types/jest":"27.0.3","@types/lodash":"4.14.178","@types/uuid":"8.3.3","@types/verror":"^1.10.5","@typescript-eslint/eslint-plugin":"5.8.1","@typescript-eslint/parser":"5.8.1","del-cli":"4.0.1","eslint":"8.5.0","eslint-config-xo":"0.39.0","eslint-config-xo-typescript":"0.47.1","eslint-plugin-codegen":"0.16.1","eslint-plugin-import":"2.25.3","eslint-plugin-jest":"25.3.0","eslint-plugin-mocha":"10.0.3","eslint-plugin-prettier":"4.0.0","eslint-plugin-unicorn":"39.0.0","expect-type":"0.13.0","fs-syncer":"0.4.0","jest":"27.4.5","lodash":"4.17.21","np":"7.6.0","prettier":"2.5.1","sequelize":"6.12.3","sinon":"12.0.1","source-map-support":"0.5.21","sqlite3":"npm:@vscode/sqlite3@5.0.7","strip-ansi":"6.0.1","ts-jest":"27.1.2","ts-node":"10.4.0","typescript":"4.6.2","uuid":"8.3.2","verror":"^1.10.0"},"scripts":{"build":"del-cli lib && tsc -p tsconfig.lib.json","eslint":"eslint --ext .js,.ts,.md . --max-warnings 0","lint":"npm run type-check && npm run eslint","prepare":"npm run build","release":"np --no-yarn --no-2fa","pretest":"del-cli test/generated","test":"jest","type-check":"tsc -p ."},"repository":{"type":"git","url":"git+https://github.com/sequelize/umzug.git"},"author":{"name":"Sascha Depold","email":"sascha@depold.com"},"contributors":[{"name":"Misha Kaletsky","email":"mmkal@kaletsky.com"},{"name":"Jukka Hyytiälä","email":"hyytiala.jukka@gmail.com"},{"name":"Pascal Pflaum","email":"mail@pascalpflaum.de"},{"name":"Pedro Augusto de Paula Barbosa","email":"papb1996@gmail.com"}],"license":"MIT","bugs":{"url":"https://github.com/sequelize/umzug/issues"},"homepage":"https://github.com/sequelize/umzug","engines":{"node":">=12"},"jest":{"preset":"ts-jest","globals":{"ts-jest":{"diagnostics":false}},"testEnvironment":"node","testMatch":["**/*test.ts"],"collectCoverageFrom":["src/**"]},"gitHead":"44f1ae5c4dc0b15c26999f4b7fb7fe860a02f8f0","_id":"umzug@3.1.0","_nodeVersion":"14.17.0","_npmVersion":"6.14.13","dist":{"integrity":"sha512-Ox/D/N4VuWBrLbRPWrF/x0pIETmpNakKP+Jna1ZrfJDiLQyYwbTTayPd5NEtfjSSz9JG2DOOKie251Vu6teKWw==","shasum":"81149cad74f0e10ad0c9908244a164561a969ce9","tarball":"https://registry.npmjs.org/umzug/-/umzug-3.1.0.tgz","fileCount":40,"unpackedSize":131782,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v4.10.10\r\nComment: https://openpgpjs.org\r\n\r\nwsFzBAEBCAAGBQJiP41iACEJED1NWxICdlZqFiEECWMYAoorWMhJKdjhPU1b\r\nEgJ2VmpAvhAAlLO+hDnrQGXz67JaQkJ/5fDOyoHJOTERCzVpV7RYnp0ZEacD\r\nPvjgGqDCunn6LvNVcp9ae6sGOUYZlIuqZ7LWIHmEroaksH1w5S2OY2HOc2iW\r\ndU2yED7oxe5DRuPsuOOFaFcq/QYAH9phuEETQhj4kMDAFTuHtuXQDdIRouhY\r\nFdavHfRVYVCrnXQGNDW6Ja6u3UZy9ZhBzFkuKX+QSu5vexvrpQaiHUVjSRFS\r\nf8fjjj915YVipg72d/L05sryAR5MhrZVLwe/V4EBPKM86BiJUxHD195Zrahy\r\ni/FoR1wouy85uLZkurrblytl0MfgTdLc1W+l+4RxdyKYe/u1QbTT3OiDyaqo\r\nvC95a+SBKMrDIpJzN536AAuv9iGlQJZ+sYl1o2WnCXuk2a++5ZxSqK7iIxRg\r\n8sncYbkS1HBxxIXQYqh5bJgyjCuv/RZ356OCgxz95TsUxNdcSJAtQHWbHL8A\r\nVJ2QLqDzbFHhRLmDgamaDmAEDlEJRMmCtO2eqa1mSgrDTQXjiiAFZ+95rHs6\r\nV/I+snv5bpIl/qNDiMu6FLjg9Asa3ODKrxL8SEbBRchTDBmqS1KPzi9SBABa\r\nvDX4UXZANsDue+SqCxRSkN7DcQRNtEBW+wU9H9Wcz1Szp1cbgFYrqsfyaSwa\r\nIncH/KUdvPM5R4M4ijReMlFzCd1DhlJ/Z38=\r\n=oD9Y\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCICmP47qY+osVrbOLx2vvfAxzkljpDVtkr8odCFjd/Bh2AiEA8Mm2xlx+PWjKouE1y1HE3Ev47i4sRyCQksBCGQvUwnE="}]},"_npmUser":{"name":"mmkale","email":"mmkal1@outlook.com"},"directories":{},"maintainers":[{"name":"pascal.pflaum","email":"mail@pascalpflaum.de"},{"name":"sdepold","email":"sascha@depold.com"},{"name":"sushantdhiman","email":"sushantdhiman@outlook.com"},{"name":"papb","email":"papb1996@gmail.com"},{"name":"mmkale","email":"mmkal1@outlook.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/umzug_3.1.0_1648332130555_0.14410437491762607"},"_hasShrinkwrap":false},"3.1.1":{"name":"umzug","version":"3.1.1","description":"Framework-agnostic migration tool for Node","keywords":["migrate","migration","migrations","sequelize","database"],"main":"lib/index.js","dependencies":{"@rushstack/ts-command-line":"^4.7.7","emittery":"^0.10.2","fs-jetpack":"^4.1.0","glob":"^7.1.6","pony-cause":"^1.1.1","type-fest":"^2.0.0"},"devDependencies":{"@types/glob":"7.2.0","@types/jest":"27.0.3","@types/lodash":"4.14.178","@types/uuid":"8.3.3","@types/verror":"^1.10.5","@typescript-eslint/eslint-plugin":"5.8.1","@typescript-eslint/parser":"5.8.1","del-cli":"4.0.1","eslint":"8.5.0","eslint-config-xo":"0.39.0","eslint-config-xo-typescript":"0.47.1","eslint-plugin-codegen":"0.16.1","eslint-plugin-import":"2.25.3","eslint-plugin-jest":"25.3.0","eslint-plugin-mocha":"10.0.3","eslint-plugin-prettier":"4.0.0","eslint-plugin-unicorn":"39.0.0","expect-type":"0.13.0","fs-syncer":"0.4.0","jest":"27.4.5","lodash":"4.17.21","np":"7.6.0","prettier":"2.5.1","sequelize":"6.12.3","sinon":"12.0.1","source-map-support":"0.5.21","sqlite3":"npm:@vscode/sqlite3@5.0.7","strip-ansi":"6.0.1","ts-jest":"27.1.2","ts-node":"10.4.0","typescript":"4.6.2","uuid":"8.3.2","verror":"^1.10.0"},"scripts":{"build":"del-cli lib && tsc -p tsconfig.lib.json","eslint":"eslint --ext .js,.ts,.md . --max-warnings 0","lint":"npm run type-check && npm run eslint","prepare":"npm run build","release":"np --no-yarn --no-2fa","pretest":"del-cli test/generated","test":"jest","type-check":"tsc -p ."},"repository":{"type":"git","url":"git+https://github.com/sequelize/umzug.git"},"author":{"name":"Sascha Depold","email":"sascha@depold.com"},"contributors":[{"name":"Misha Kaletsky","email":"mmkal@kaletsky.com"},{"name":"Jukka Hyytiälä","email":"hyytiala.jukka@gmail.com"},{"name":"Pascal Pflaum","email":"mail@pascalpflaum.de"},{"name":"Pedro Augusto de Paula Barbosa","email":"papb1996@gmail.com"}],"license":"MIT","bugs":{"url":"https://github.com/sequelize/umzug/issues"},"homepage":"https://github.com/sequelize/umzug","engines":{"node":">=12"},"jest":{"preset":"ts-jest","globals":{"ts-jest":{"diagnostics":false}},"testEnvironment":"node","testMatch":["**/*test.ts"],"collectCoverageFrom":["src/**"]},"gitHead":"5f0a2b8ef23bdfb85c60927692ca51085f61a26b","_id":"umzug@3.1.1","_nodeVersion":"14.17.0","_npmVersion":"6.14.13","dist":{"integrity":"sha512-sgMDzUK6ZKS3pjzRJpAHqSkvAQ+64Dourq6JfQv11i0nMu0/QqE3V3AUpj2pWYxFBaSvnUxKrzZQmPr6NZhvdQ==","shasum":"dfbe52308bf2908984380bdffd0c75c07831fd1f","tarball":"https://registry.npmjs.org/umzug/-/umzug-3.1.1.tgz","fileCount":40,"unpackedSize":131782,"signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIDG1qQYoC2pqyvmXs02rte7e4cBhiKkIXH8Hb/sOLt8NAiEAyp3H7aV+/+4o527GPkhS537TBbNn40UErLE7M6JHYPQ="}],"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v4.10.10\r\nComment: https://openpgpjs.org\r\n\r\nwsFzBAEBCAAGBQJiSGTEACEJED1NWxICdlZqFiEECWMYAoorWMhJKdjhPU1b\r\nEgJ2Vmom3A/+OaDVJVGjsMSODUm7NsVxkstTdcRlFAF8PMFQEdG48d0TAd1v\r\nO/0OZACKmGuA51FODIZ2MSMcS8PFMCrv2/1kOJMHDg8rZp3O4FR1z0WCCRf0\r\n4UIVJgOpQjiWdFCT9YWepAXBs0OrXuRyGNf0+SvfBUe1Z0YYyVkvVqqwrU/4\r\n+vHN3EvsznQ8FznTkHlikUdRltL1ajWemW1dTKLycwgIvssldvfB7qEEnYv5\r\nYVuvIse4U8cFYjYRn6JvOMhJUr2ZU7yLsgkQFsygG3IDa1vBZjiCzL1+tylA\r\n16qQtSQt0rZco6dYbv8WDF/OkVbJnaUrZzCT1++9bQzPx4MqNRO7cDSbej98\r\ncmRP2ua1BuXt52e2MTs1R5Amlsv1YebbiAIMfpYs/DVeMOXf3lh+RuyqlSJI\r\nQ1sKdIeCE1sb3//g1sh1OuL+67wkuH6jPkKcAkNEezI/v6PPzjE0Iz4pWKh2\r\na7eCc8jGvGsqGgdyxCmIL3HaH1ogvM2ObKRPNxQ6izvaUsPsvGuzHYj0CP35\r\nmoq0eQd5ZNkXtgX5BszVquGnBmojOBZhMoHxeak349a4yfQDns+fBi7lNbFW\r\nY69hay3s2e1Do926vZhNZX6t4fU4NwN+Arv8+9eEiOF0ycYOMbHGo4KM180q\r\nw7/1yyRV5tGitqkAUGLnQZxsS7yaXFqWu+w=\r\n=OCqS\r\n-----END PGP SIGNATURE-----\r\n"},"_npmUser":{"name":"mmkale","email":"mmkal1@outlook.com"},"directories":{},"maintainers":[{"name":"pascal.pflaum","email":"mail@pascalpflaum.de"},{"name":"sdepold","email":"sascha@depold.com"},{"name":"sushantdhiman","email":"sushantdhiman@outlook.com"},{"name":"papb","email":"papb1996@gmail.com"},{"name":"mmkale","email":"mmkal1@outlook.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/umzug_3.1.1_1648911556393_0.04713323129152425"},"_hasShrinkwrap":false},"3.1.2":{"name":"umzug","version":"3.1.2","description":"Framework-agnostic migration tool for Node","keywords":["migrate","migration","migrations","sequelize","database"],"main":"lib/index.js","dependencies":{"@rushstack/ts-command-line":"^4.12.2","emittery":"^0.12.1","fs-jetpack":"^4.3.1","glob":"^8.0.3","pony-cause":"^2.1.2","type-fest":"^2.18.0"},"devDependencies":{"@types/glob":"7.2.0","@types/jest":"27.0.3","@types/lodash":"4.14.178","@types/uuid":"8.3.3","@types/verror":"^1.10.5","@typescript-eslint/eslint-plugin":"5.8.1","@typescript-eslint/parser":"5.8.1","del-cli":"4.0.1","eslint":"8.5.0","eslint-config-xo":"0.39.0","eslint-config-xo-typescript":"0.47.1","eslint-plugin-codegen":"0.16.1","eslint-plugin-import":"2.25.3","eslint-plugin-jest":"25.3.0","eslint-plugin-mocha":"10.0.3","eslint-plugin-prettier":"4.0.0","eslint-plugin-unicorn":"39.0.0","expect-type":"0.13.0","fs-syncer":"0.4.0","jest":"27.4.5","lodash":"4.17.21","np":"7.6.0","prettier":"2.5.1","sequelize":"6.12.3","sinon":"12.0.1","source-map-support":"0.5.21","sqlite3":"npm:@vscode/sqlite3@5.0.7","strip-ansi":"6.0.1","ts-jest":"27.1.2","ts-node":"10.4.0","typescript":"4.6.2","uuid":"8.3.2","verror":"^1.10.0"},"scripts":{"build":"del-cli lib && tsc -p tsconfig.lib.json","eslint":"eslint --ext .js,.ts,.md . --max-warnings 0","lint":"npm run type-check && npm run eslint","prepare":"npm run build","release":"np --no-yarn --no-2fa","pretest":"del-cli test/generated","test":"jest","type-check":"tsc -p ."},"repository":{"type":"git","url":"git+https://github.com/sequelize/umzug.git"},"author":{"name":"Sascha Depold","email":"sascha@depold.com"},"contributors":[{"name":"Misha Kaletsky","email":"mmkal@kaletsky.com"},{"name":"Jukka Hyytiälä","email":"hyytiala.jukka@gmail.com"},{"name":"Pascal Pflaum","email":"mail@pascalpflaum.de"},{"name":"Pedro Augusto de Paula Barbosa","email":"papb1996@gmail.com"}],"license":"MIT","bugs":{"url":"https://github.com/sequelize/umzug/issues"},"homepage":"https://github.com/sequelize/umzug","engines":{"node":">=12"},"jest":{"preset":"ts-jest","globals":{"ts-jest":{"diagnostics":false}},"testEnvironment":"node","testMatch":["**/*test.ts"],"collectCoverageFrom":["src/**"]},"types":"./lib/index.d.ts","gitHead":"1dc7723abbd499c1f7ea8389bdb31c8b73f03596","_id":"umzug@3.1.2","_nodeVersion":"14.17.0","_npmVersion":"8.6.0","dist":{"integrity":"sha512-iI/0fINek6Gfx7jH3uT3mY+jZTdNJbPkt+YkwGB2UZ0536Ny1ihpn+RZ/paiOXzy4b/WtK29N3DMSljo0op+3g==","shasum":"d42155564819da4c05df2f1441d7ab707f706f15","tarball":"https://registry.npmjs.org/umzug/-/umzug-3.1.2.tgz","fileCount":39,"unpackedSize":127425,"signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEQCIFJz18n5QftL1SnphSwp9b2OQh8u3LfQiTeAPeJw1GJKAiBo4WxpDtWTFr93CzJ6eK2wPya6fZDqQrSqYqmem2quXA=="}],"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v4.10.10\r\nComment: https://openpgpjs.org\r\n\r\nwsFzBAEBCAAGBQJi9pPyACEJED1NWxICdlZqFiEECWMYAoorWMhJKdjhPU1b\r\nEgJ2VmrEcxAAlqKFJlCMsNEN7ZabQiEgLte26+yfw+5q6iu2biaYsf+c+K1R\r\nkTU91hZpO8KrgPMixnE9YG+niloa+1rwEMHUECR8wdJ5iSKbdZgjjnOo9CAK\r\nGJ3UXbTYXRO+Soe4bJK9q03lL6O0xSPg0snaDT9GrwN2m67iJkowP2cZrA8f\r\ny/nWBpF+lOl0YaLEq6mw9RMUZtctbT5XUzOqtHEUaLUTx+Iwu/9doacU+TpJ\r\nqPEO+8OkCuvusDARLM379CEADpWIM7hET1bqaf3HVL3McmGC4ae2dXpmiep9\r\nKfaCbXo9Q+1X1jIDUmODm6CTdmIkvme1Sqg81TNz2ul4NVVw1zI38GxgKP4T\r\ndyAQp96B7vcz0UH90vuY9tKnCqGiB+GRExGjvQQUqXMMC2kJ4ZrVIhUXTcUj\r\nRMQ1r8MkFPd4F6nLxe3ls7XZQD95h8qQGrG0xfGhO7J3ihgmgJElriCSUQKN\r\nZZifqH+GGj7Nit9d4m1Uyy66ZE+KPMrUxgHCLD0kbJ99QxZ8rBz4QaFjxmd7\r\n7kM9/cA1DbBYlHf4mi2XjlN0scoq8r8LnuWzKa0bKRniQYxrI6Ot6DIdwAdo\r\nnToP4te1Zz+i6ujSpOlLMkWWqLs0QYMxNCHRbSPNsgQ1BDCfoa1AKuwqI3kg\r\nTofraUdzq9idQeBSBhNEqi4qiTE9vKqU1jc=\r\n=ZTUo\r\n-----END PGP SIGNATURE-----\r\n"},"_npmUser":{"name":"mmkale","email":"mmkal1@outlook.com"},"directories":{},"maintainers":[{"name":"pascal.pflaum","email":"mail@pascalpflaum.de"},{"name":"sdepold","email":"sascha@depold.com"},{"name":"sushantdhiman","email":"sushantdhiman@outlook.com"},{"name":"papb","email":"papb1996@gmail.com"},{"name":"mmkale","email":"mmkal1@outlook.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/umzug_3.1.2_1660326898566_0.7422953321096395"},"_hasShrinkwrap":false},"3.2.0":{"name":"umzug","version":"3.2.0","description":"Framework-agnostic migration tool for Node","keywords":["migrate","migration","migrations","sequelize","database"],"main":"lib/index.js","dependencies":{"@rushstack/ts-command-line":"^4.12.2","emittery":"^0.12.1","fs-jetpack":"^4.3.1","glob":"^8.0.3","pony-cause":"^2.1.2","type-fest":"^2.18.0"},"devDependencies":{"@types/glob":"7.2.0","@types/jest":"27.0.3","@types/lodash":"4.14.178","@types/uuid":"8.3.3","@types/verror":"^1.10.5","@typescript-eslint/eslint-plugin":"5.8.1","@typescript-eslint/parser":"5.8.1","del-cli":"4.0.1","eslint":"8.5.0","eslint-config-xo":"0.39.0","eslint-config-xo-typescript":"0.47.1","eslint-plugin-codegen":"0.16.1","eslint-plugin-import":"2.25.3","eslint-plugin-jest":"25.3.0","eslint-plugin-mocha":"10.0.3","eslint-plugin-prettier":"4.0.0","eslint-plugin-unicorn":"39.0.0","expect-type":"0.13.0","fs-syncer":"0.4.0","jest":"27.4.5","lodash":"4.17.21","np":"7.6.0","prettier":"2.5.1","sequelize":"6.12.3","sinon":"12.0.1","source-map-support":"0.5.21","sqlite3":"npm:@vscode/sqlite3@5.0.7","strip-ansi":"6.0.1","ts-jest":"27.1.2","ts-node":"10.4.0","typescript":"4.6.2","uuid":"8.3.2","verror":"^1.10.0"},"scripts":{"build":"del-cli lib && tsc -p tsconfig.lib.json","eslint":"eslint --ext .js,.ts,.md . --max-warnings 0","lint":"npm run type-check && npm run eslint","prepare":"npm run build","release":"np --no-yarn --no-2fa","pretest":"del-cli test/generated","test":"jest","type-check":"tsc -p ."},"repository":{"type":"git","url":"git+https://github.com/sequelize/umzug.git"},"author":{"name":"Sascha Depold","email":"sascha@depold.com"},"contributors":[{"name":"Misha Kaletsky","email":"mmkal@kaletsky.com"},{"name":"Jukka Hyytiälä","email":"hyytiala.jukka@gmail.com"},{"name":"Pascal Pflaum","email":"mail@pascalpflaum.de"},{"name":"Pedro Augusto de Paula Barbosa","email":"papb1996@gmail.com"}],"license":"MIT","bugs":{"url":"https://github.com/sequelize/umzug/issues"},"homepage":"https://github.com/sequelize/umzug","engines":{"node":">=12"},"jest":{"preset":"ts-jest","globals":{"ts-jest":{"diagnostics":false}},"testEnvironment":"node","testMatch":["**/*test.ts"],"collectCoverageFrom":["src/**"]},"types":"./lib/index.d.ts","gitHead":"7ed703efb8b968de21947df0a59ed0d946e17bbd","_id":"umzug@3.2.0","_nodeVersion":"14.17.0","_npmVersion":"8.6.0","dist":{"integrity":"sha512-WN/6KhyjOWNz6EUukToNGazfKq0Ps9h6y4cg31/9HUWEDYLCw3z3kvOWjRnTtEwYTRbAAAAuHNuwPRAmkovgQA==","shasum":"196bf234f8bd9bbb182092ec5d126be4c609e9e9","tarball":"https://registry.npmjs.org/umzug/-/umzug-3.2.0.tgz","fileCount":39,"unpackedSize":127574,"signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEYCIQCkaurJhHm7K9StuDIgGk4ESFbYnYs9faSwkHp842Jv6AIhAOpAoH0lBNYLEhkCjelVQrgEcF50XsgA8nXVDGKOb9Gt"}],"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v4.10.10\r\nComment: https://openpgpjs.org\r\n\r\nwsFzBAEBCAAGBQJi9phbACEJED1NWxICdlZqFiEECWMYAoorWMhJKdjhPU1b\r\nEgJ2Vmorsg//UekRvEX/8dFraKJNRAF0TIx+/iJYCkqyNhePZw8aFKJVyuq/\r\nBxjqXn4JIZqvawATPO+6XxmFhtliimwEBFxYMz7LN9z+IikTe2qFG0boxSKg\r\nzLGfQm53tJhq42GLSMejbYjEA2fUWs9FHFXuu69KQBKxfq9kOAHt7MGxmG+3\r\nyyt5TuHKBidz+qG6UnCxLyRtNMqyBWiKDzDQ63f0Y+chzwgda33BKrRCRY1z\r\nYrU6nOhKxO0kPdVG6M5IEDB70JMR/vCuaolxwkbtwusC1MpEK9B9Sa6goRFk\r\npNGeXOsqpObdEy+4GomqXD7lnK1ZVfLCRIFkNp/zTdbiAQ0pda17VaL+fFHL\r\nehFrChKohXoHdSunRk+xb0qigQ36m6BOdkeh3YUYPgavP+8FIRq03K2vMxmD\r\nePW0HpnOTRmn+HPkICuiu8cjd7Ci88AKzmjC7WM6i5Pxm9PxGSEWK8Pu9Zg7\r\ntriIGtaFU5HAauZAXLx7p7HNINhIjsK04Br43jNZw34UjRXsETPIcMOEPQto\r\nIzAj4zZ3kgebnMIG5KJdAp93KRFGxBQyD0pEyDEON+NosQyjZ1ZSgNaz9OPg\r\nGzqkxZOSAzjirYr6C5cRWLij5gNQ5sJVn3xuHlKY2AeN9m5yOUelfWRblbNe\r\nkrwryWup1czjBAyhMKUbG1W7+pAPSHCFTjQ=\r\n=JSxS\r\n-----END PGP SIGNATURE-----\r\n"},"_npmUser":{"name":"mmkale","email":"mmkal1@outlook.com"},"directories":{},"maintainers":[{"name":"pascal.pflaum","email":"mail@pascalpflaum.de"},{"name":"sdepold","email":"sascha@depold.com"},{"name":"sushantdhiman","email":"sushantdhiman@outlook.com"},{"name":"papb","email":"papb1996@gmail.com"},{"name":"mmkale","email":"mmkal1@outlook.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/umzug_3.2.0_1660328027419_0.18543391544249888"},"_hasShrinkwrap":false},"3.2.1":{"name":"umzug","version":"3.2.1","description":"Framework-agnostic migration tool for Node","keywords":["migrate","migration","migrations","sequelize","database"],"main":"lib/index.js","dependencies":{"@rushstack/ts-command-line":"^4.12.2","emittery":"^0.12.1","fs-jetpack":"^4.3.1","glob":"^8.0.3","pony-cause":"^2.1.2","type-fest":"^2.18.0"},"devDependencies":{"@types/glob":"7.2.0","@types/jest":"27.0.3","@types/lodash":"4.14.178","@types/uuid":"8.3.3","@types/verror":"^1.10.5","@typescript-eslint/eslint-plugin":"5.8.1","@typescript-eslint/parser":"5.8.1","del-cli":"4.0.1","eslint":"8.5.0","eslint-config-xo":"0.39.0","eslint-config-xo-typescript":"0.47.1","eslint-plugin-codegen":"0.16.1","eslint-plugin-import":"2.25.3","eslint-plugin-jest":"25.3.0","eslint-plugin-mocha":"10.0.3","eslint-plugin-prettier":"4.0.0","eslint-plugin-unicorn":"39.0.0","expect-type":"0.13.0","fs-syncer":"0.4.0","jest":"27.4.5","lodash":"4.17.21","np":"7.6.0","prettier":"2.5.1","sequelize":"6.12.3","sinon":"12.0.1","source-map-support":"0.5.21","sqlite3":"npm:@vscode/sqlite3@5.0.7","strip-ansi":"6.0.1","ts-jest":"27.1.2","ts-node":"10.4.0","typescript":"4.6.2","uuid":"8.3.2","verror":"^1.10.0"},"scripts":{"build":"del-cli lib && tsc -p tsconfig.lib.json","eslint":"eslint --ext .js,.ts,.md . --max-warnings 0","lint":"npm run type-check && npm run eslint","prepare":"npm run build","release":"np --no-yarn --no-2fa","pretest":"del-cli test/generated","test":"jest","type-check":"tsc -p ."},"repository":{"type":"git","url":"git+https://github.com/sequelize/umzug.git"},"author":{"name":"Sascha Depold","email":"sascha@depold.com"},"contributors":[{"name":"Misha Kaletsky","email":"mmkal@kaletsky.com"},{"name":"Jukka Hyytiälä","email":"hyytiala.jukka@gmail.com"},{"name":"Pascal Pflaum","email":"mail@pascalpflaum.de"},{"name":"Pedro Augusto de Paula Barbosa","email":"papb1996@gmail.com"}],"license":"MIT","bugs":{"url":"https://github.com/sequelize/umzug/issues"},"homepage":"https://github.com/sequelize/umzug","engines":{"node":">=12"},"jest":{"preset":"ts-jest","globals":{"ts-jest":{"diagnostics":false}},"testEnvironment":"node","testMatch":["**/*test.ts"],"collectCoverageFrom":["src/**"]},"types":"./lib/index.d.ts","gitHead":"ce846999542deb393fe91cef58a6948ba5b8dd18","_id":"umzug@3.2.1","_nodeVersion":"14.17.0","_npmVersion":"8.6.0","dist":{"integrity":"sha512-XyWQowvP9CKZycKc/Zg9SYWrAWX/gJCE799AUTFqk8yC3tp44K1xWr3LoFF0MNEjClKOo1suCr5ASnoy+KltdA==","shasum":"01c3a109efb037a10a317d4191be22810c37b195","tarball":"https://registry.npmjs.org/umzug/-/umzug-3.2.1.tgz","fileCount":39,"unpackedSize":128025,"signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEQCIEHO5RcsPM2HFVF8w7aaOLu+nk9Sjakbf2vkrruAcoIdAiAc6Py/gPd6yQy095ED6wIciFwHujzeoBGY2pco2IKFnA=="}],"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v4.10.10\r\nComment: https://openpgpjs.org\r\n\r\nwsFzBAEBCAAGBQJi92qvACEJED1NWxICdlZqFiEECWMYAoorWMhJKdjhPU1b\r\nEgJ2VmofJBAAmGJhcFRX6etcooXA5VPrClMCw9UQsDGfimi8BDtLo8auJ/2u\r\nI5ru6YNA0CpgZuW96O8Xwvrc8fxbE7Dcq3v3DrBzTk/xWQh/KKfjrNDrWfZ2\r\n95IAnxrKaQLCOWP1k4T4kUkFFdCiWJNmIGRpHTmz3yZowYdoTts6fRXdOOE2\r\n630aJNbfs4hDNo+gB+kLu4UMR+EMTxA8Md6u5q386q1C7QBzTNO2Ezu84Vqe\r\nX2reHSxEWrY9CAsV7SD9IZK96OFIyAqOzZvQp5Aiuvl84gUTGaC0lgLkd9cd\r\neMlES5KTDApcPA3UN7CcuvKEFaEwmk+AchE15Ys2MAHydq7+eEAJ/s6M4WJg\r\nGdctOAKsu7nV03pBuVLqlOK/VNpV/V0l8q9gVFa1028S7zj89RWyLim3/Ifk\r\nEEQZwCU99A4I7xyn1Rda0kjhy2qmUHmPoIr0SdUmoGQqGs+amWXQAuo29B7r\r\nmJv1Gc94W1OZ6hWnXebY9ZdSlmcoB7QWrui0ZRrEXPBDMMO9LbBmIKDXw0VN\r\nhhYJ8qSYDzC559EK8JocFAJ7UxdiZz/ZHzGKnrffEnyfxLMfpIN78HC8QmFS\r\n2HfLofMRkl07AtLuMM4vjnRHnv167UkUmsDZCHoIK+aB8ThMfxCR/ZX5x4Yu\r\ncSq2D3NquCo78LOx8zXclEKQhj89BVfhBrE=\r\n=1+gC\r\n-----END PGP SIGNATURE-----\r\n"},"_npmUser":{"name":"mmkale","email":"mmkal1@outlook.com"},"directories":{},"maintainers":[{"name":"pascal.pflaum","email":"mail@pascalpflaum.de"},{"name":"sdepold","email":"sascha@depold.com"},{"name":"sushantdhiman","email":"sushantdhiman@outlook.com"},{"name":"papb","email":"papb1996@gmail.com"},{"name":"mmkale","email":"mmkal1@outlook.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/umzug_3.2.1_1660381871032_0.9527509508536764"},"_hasShrinkwrap":false},"3.3.0":{"name":"umzug","version":"3.3.0","description":"Framework-agnostic migration tool for Node","keywords":["migrate","migration","migrations","sequelize","database"],"main":"lib/index.js","dependencies":{"@rushstack/ts-command-line":"^4.12.2","emittery":"^0.13.0","glob":"^8.0.3","pony-cause":"^2.1.4","type-fest":"^3.0.0"},"devDependencies":{"@types/glob":"8.0.0","@types/jest":"29.1.1","@types/lodash":"4.14.186","@types/uuid":"8.3.4","@types/verror":"1.10.6","@typescript-eslint/eslint-plugin":"5.42.1","@typescript-eslint/parser":"5.42.1","del":"^5.0.0","del-cli":"5.0.0","eslint":"8.27.0","eslint-config-xo":"0.43.1","eslint-config-xo-typescript":"0.54.1","eslint-plugin-codegen":"0.16.1","eslint-plugin-import":"2.26.0","eslint-plugin-jest":"27.1.5","eslint-plugin-mocha":"10.1.0","eslint-plugin-prettier":"4.2.1","eslint-plugin-unicorn":"44.0.2","expect-type":"0.14.2","fs-syncer":"0.4.0","jest":"29.1.2","lodash":"4.17.21","np":"8.0.4","p-event":"^4.0.0","prettier":"2.7.1","sequelize":"6.29.0","sinon":"14.0.0","source-map-support":"0.5.21","sqlite3":"npm:@vscode/sqlite3@5.0.8","strip-ansi":"6.0.1","ts-jest":"29.0.3","ts-node":"10.9.1","typescript":"4.8.4","uuid":"9.0.0","verror":"1.10.1"},"scripts":{"build":"del-cli lib && tsc -p tsconfig.lib.json","eslint":"eslint --ext .js,.ts,.md . --max-warnings 0","lint":"npm run type-check && npm run eslint","prepare":"npm run build","release":"np --no-yarn --no-2fa","pretest":"del-cli test/generated","test":"jest","type-check":"tsc -p ."},"repository":{"type":"git","url":"git+https://github.com/sequelize/umzug.git"},"author":{"name":"Sascha Depold","email":"sascha@depold.com"},"contributors":[{"name":"Misha Kaletsky","email":"mmkal@kaletsky.com"},{"name":"Jukka Hyytiälä","email":"hyytiala.jukka@gmail.com"},{"name":"Pascal Pflaum","email":"mail@pascalpflaum.de"},{"name":"Pedro Augusto de Paula Barbosa","email":"papb1996@gmail.com"}],"license":"MIT","bugs":{"url":"https://github.com/sequelize/umzug/issues"},"homepage":"https://github.com/sequelize/umzug","engines":{"node":">=12"},"jest":{"preset":"ts-jest","transform":{".*":["ts-jest",{"diagnostics":false}]},"testEnvironment":"node","testMatch":["**/*test.ts"],"collectCoverageFrom":["src/**"]},"types":"./lib/index.d.ts","gitHead":"232cc8826972f6cb75ca6e29ed7aeff3aed55987","_id":"umzug@3.3.0","_nodeVersion":"18.15.0","_npmVersion":"9.5.0","dist":{"integrity":"sha512-842Uv/TmPZxClEm5fuRxItQ38TsYQkqODlOjnnyOAHz7+8WmYXUS2Be8iYsMaaRROE0MeuUNzkevM5UwoSBn6g==","shasum":"acaaf8cf797e94013b759586fe40dfe552159ed1","tarball":"https://registry.npmjs.org/umzug/-/umzug-3.3.0.tgz","fileCount":39,"unpackedSize":130216,"signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEQCIEvhU1WrrCYDfjIi3lNbMuMnjFDjIKSWdb470t9FqhJwAiAAhWX9sEF+hJd80KENv3D3i+OdAc7QfY4Ik9ixRPUqLA=="}]},"_npmUser":{"name":"mmkale","email":"mmkal1@outlook.com"},"directories":{},"maintainers":[{"name":"pascal.pflaum","email":"mail@pascalpflaum.de"},{"name":"sdepold","email":"sascha@depold.com"},{"name":"sushantdhiman","email":"sushantdhiman@outlook.com"},{"name":"papb","email":"papb1996@gmail.com"},{"name":"mmkale","email":"mmkal1@outlook.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/umzug_3.3.0_1690987423612_0.6061485769922923"},"_hasShrinkwrap":false,"deprecated":"Accidental breaking change, use 3.3.1 or higher instead. See https://github.com/sequelize/umzug/issues/614"},"3.3.1":{"name":"umzug","version":"3.3.1","description":"Framework-agnostic migration tool for Node","keywords":["migrate","migration","migrations","sequelize","database"],"main":"lib/index.js","dependencies":{"@rushstack/ts-command-line":"^4.12.2","emittery":"^0.13.0","glob":"^8.0.3","pony-cause":"^2.1.4","type-fest":"^3.0.0"},"devDependencies":{"@types/glob":"8.0.0","@types/jest":"29.1.1","@types/lodash":"4.14.186","@types/uuid":"8.3.4","@types/verror":"1.10.6","@typescript-eslint/eslint-plugin":"5.42.1","@typescript-eslint/parser":"5.42.1","del":"^5.0.0","del-cli":"5.0.0","eslint":"8.27.0","eslint-config-xo":"0.43.1","eslint-config-xo-typescript":"0.54.1","eslint-plugin-codegen":"0.16.1","eslint-plugin-import":"2.26.0","eslint-plugin-jest":"27.1.5","eslint-plugin-mocha":"10.1.0","eslint-plugin-prettier":"4.2.1","eslint-plugin-unicorn":"44.0.2","expect-type":"0.14.2","fs-syncer":"0.4.0","jest":"29.1.2","lodash":"4.17.21","np":"8.0.4","p-event":"^4.0.0","prettier":"2.7.1","sequelize":"6.29.0","sinon":"14.0.0","source-map-support":"0.5.21","sqlite3":"npm:@vscode/sqlite3@5.0.8","strip-ansi":"6.0.1","ts-jest":"29.0.3","ts-node":"10.9.1","typescript":"4.8.4","uuid":"9.0.0","verror":"1.10.1"},"scripts":{"build":"del-cli lib && tsc -p tsconfig.lib.json","eslint":"eslint --ext .js,.ts,.md . --max-warnings 0","lint":"npm run type-check && npm run eslint","prepare":"npm run build","release":"np --no-yarn --no-2fa","pretest":"del-cli test/generated","test":"jest","type-check":"tsc -p ."},"repository":{"type":"git","url":"git+https://github.com/sequelize/umzug.git"},"author":{"name":"Sascha Depold","email":"sascha@depold.com"},"contributors":[{"name":"Misha Kaletsky","email":"mmkal@kaletsky.com"},{"name":"Jukka Hyytiälä","email":"hyytiala.jukka@gmail.com"},{"name":"Pascal Pflaum","email":"mail@pascalpflaum.de"},{"name":"Pedro Augusto de Paula Barbosa","email":"papb1996@gmail.com"}],"license":"MIT","bugs":{"url":"https://github.com/sequelize/umzug/issues"},"homepage":"https://github.com/sequelize/umzug","engines":{"node":">=12"},"jest":{"preset":"ts-jest","transform":{".*":["ts-jest",{"diagnostics":false}]},"testEnvironment":"node","testMatch":["**/*test.ts"],"collectCoverageFrom":["src/**"]},"types":"./lib/index.d.ts","gitHead":"2cfa525c20d5418502a4c3dade99bdc4d9750050","_id":"umzug@3.3.1","_nodeVersion":"18.15.0","_npmVersion":"9.5.0","dist":{"integrity":"sha512-jG3C35jti1YnCuH/k3fJEfHbnIG9c3Q9ITZ0B9eWwnXngh/AUd0mRHv8OdpE2Q9VoK7tB6xL990JrMCr0LtfNA==","shasum":"4ed726e7ec216049d826623a9c4faf66d412eb61","tarball":"https://registry.npmjs.org/umzug/-/umzug-3.3.1.tgz","fileCount":39,"unpackedSize":130323,"signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEQCIBzBNaZTrQR9+TS9NXNCRRMkBjLbgnXhYLkKNwA/4undAiBiJc3YM4EyRqiHFOBO2PLlidx9Yfpr+M6J0iBkrBIcxQ=="}]},"_npmUser":{"name":"mmkale","email":"mmkal1@outlook.com"},"directories":{},"maintainers":[{"name":"pascal.pflaum","email":"mail@pascalpflaum.de"},{"name":"sdepold","email":"sascha@depold.com"},{"name":"sushantdhiman","email":"sushantdhiman@outlook.com"},{"name":"papb","email":"papb1996@gmail.com"},{"name":"mmkale","email":"mmkal1@outlook.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/umzug_3.3.1_1691048246914_0.45636616169558253"},"_hasShrinkwrap":false},"3.4.0":{"name":"umzug","version":"3.4.0","description":"Framework-agnostic migration tool for Node","keywords":["migrate","migration","migrations","sequelize","database"],"main":"lib/index.js","dependencies":{"@rushstack/ts-command-line":"^4.12.2","emittery":"^0.13.0","glob":"^8.0.3","pony-cause":"^2.1.4","type-fest":"^3.0.0"},"devDependencies":{"@types/glob":"8.0.0","@types/jest":"29.1.1","@types/lodash":"4.14.186","@types/uuid":"8.3.4","@types/verror":"1.10.6","@typescript-eslint/eslint-plugin":"5.42.1","@typescript-eslint/parser":"5.42.1","del":"^5.0.0","del-cli":"5.0.0","eslint":"8.27.0","eslint-config-xo":"0.43.1","eslint-config-xo-typescript":"0.54.1","eslint-plugin-codegen":"0.16.1","eslint-plugin-import":"2.26.0","eslint-plugin-jest":"27.1.5","eslint-plugin-mocha":"10.1.0","eslint-plugin-prettier":"4.2.1","eslint-plugin-unicorn":"44.0.2","execa":"^5.1.1","expect-type":"0.14.2","fs-syncer":"0.4.0","jest":"29.1.2","lodash":"4.17.21","np":"8.0.4","p-event":"^4.0.0","prettier":"2.7.1","sequelize":"6.29.0","sinon":"14.0.0","source-map-support":"0.5.21","sqlite3":"npm:@vscode/sqlite3@5.0.8","strip-ansi":"6.0.1","ts-jest":"29.0.3","ts-node":"10.9.1","typescript":"4.8.4","uuid":"9.0.0","verror":"1.10.1"},"scripts":{"build":"del-cli lib && tsc -p tsconfig.lib.json","eslint":"eslint --ext .js,.ts,.md . --max-warnings 0","lint":"npm run type-check && npm run eslint","prepare":"npm run build","release":"np --no-yarn --no-2fa","pretest":"del-cli test/generated","test":"jest","type-check":"tsc -p ."},"repository":{"type":"git","url":"git+https://github.com/sequelize/umzug.git"},"author":{"name":"Sascha Depold","email":"sascha@depold.com"},"contributors":[{"name":"Misha Kaletsky","email":"mmkal@kaletsky.com"},{"name":"Jukka Hyytiälä","email":"hyytiala.jukka@gmail.com"},{"name":"Pascal Pflaum","email":"mail@pascalpflaum.de"},{"name":"Pedro Augusto de Paula Barbosa","email":"papb1996@gmail.com"}],"license":"MIT","bugs":{"url":"https://github.com/sequelize/umzug/issues"},"homepage":"https://github.com/sequelize/umzug","engines":{"node":">=12"},"jest":{"preset":"ts-jest","transform":{".*":["ts-jest",{"diagnostics":false}]},"testEnvironment":"node","testMatch":["**/*test.ts"],"collectCoverageFrom":["src/**"]},"_id":"umzug@3.4.0","gitHead":"c7828b28a61da6c650dc4aba26ed968c75521ad3","types":"./lib/index.d.ts","_nodeVersion":"20.8.0","_npmVersion":"10.1.0","dist":{"integrity":"sha512-bTen9ElCBoWU1mhcaXqVZWXxB1PojsBQBs/4vW0YV8f5CfhuhkfRjQZj6SCb6IuHWPkccDzF+T+RGZCYUiXaKg==","shasum":"97819a2d2288c8ce2c156c3be8b18b02f2208423","tarball":"https://registry.npmjs.org/umzug/-/umzug-3.4.0.tgz","fileCount":39,"unpackedSize":131079,"signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEQCIFJbxYwOTb3q8GaJbV7JszPETWFYbZy/9cOa0xbArylGAiAeTn7iakmoNF6vT1fBoXrqwXkHa0rw5krhYARJXBhdkQ=="}]},"_npmUser":{"name":"mmkale","email":"mmkal1@outlook.com"},"directories":{},"maintainers":[{"name":"pascal.pflaum","email":"mail@pascalpflaum.de"},{"name":"sdepold","email":"sascha@depold.com"},{"name":"sushantdhiman","email":"sushantdhiman@outlook.com"},{"name":"papb","email":"papb1996@gmail.com"},{"name":"mmkale","email":"mmkal1@outlook.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/umzug_3.4.0_1699101497428_0.8162431926143225"},"_hasShrinkwrap":false},"3.5.0-0":{"name":"umzug","version":"3.5.0-0","description":"Framework-agnostic migration tool for Node","keywords":["migrate","migration","migrations","sequelize","database"],"main":"lib/index.js","dependencies":{"@rushstack/ts-command-line":"^4.12.2","emittery":"^0.13.0","glob":"^8.0.3","pony-cause":"^2.1.4","type-fest":"^3.0.0"},"devDependencies":{"@types/glob":"8.0.0","@types/lodash":"4.14.186","@types/uuid":"8.3.4","@types/verror":"1.10.6","@typescript-eslint/eslint-plugin":"5.42.1","@typescript-eslint/parser":"5.42.1","@vitest/coverage-v8":"^0.34.6","@vitest/ui":"^0.34.6","del":"^5.0.0","del-cli":"5.0.0","eslint":"8.27.0","eslint-config-xo":"0.43.1","eslint-config-xo-typescript":"0.54.1","eslint-plugin-codegen":"0.16.1","eslint-plugin-import":"2.26.0","eslint-plugin-mocha":"10.1.0","eslint-plugin-prettier":"4.2.1","eslint-plugin-unicorn":"44.0.2","execa":"^5.1.1","expect-type":"0.14.2","fs-syncer":"0.4.0","lodash":"4.17.21","np":"8.0.4","p-event":"^4.0.0","prettier":"2.7.1","sequelize":"6.34.0","sinon":"14.0.0","source-map-support":"0.5.21","sqlite3":"npm:@vscode/sqlite3@5.0.8","strip-ansi":"6.0.1","ts-node":"10.9.1","typescript":"4.8.4","uuid":"9.0.0","verror":"1.10.1","vitest":"^0.34.6"},"scripts":{"clean":"del-cli lib","compile":"tsc -p tsconfig.lib.json","build":"npm run clean && npm run compile","eslint":"eslint --ext .js,.ts,.md . --max-warnings 0","lint":"npm run type-check && npm run eslint","prepare":"npm run build","release":"np --no-yarn --no-2fa","pretest":"del-cli test/generated","test":"vitest","type-check":"tsc -p ."},"repository":{"type":"git","url":"git+https://github.com/sequelize/umzug.git"},"author":{"name":"Sascha Depold","email":"sascha@depold.com"},"contributors":[{"name":"Misha Kaletsky","email":"mmkal@kaletsky.com"},{"name":"Jukka Hyytiälä","email":"hyytiala.jukka@gmail.com"},{"name":"Pascal Pflaum","email":"mail@pascalpflaum.de"},{"name":"Pedro Augusto de Paula Barbosa","email":"papb1996@gmail.com"}],"license":"MIT","bugs":{"url":"https://github.com/sequelize/umzug/issues"},"homepage":"https://github.com/sequelize/umzug","engines":{"node":">=12"},"_id":"umzug@3.5.0-0","readme":"# Umzug\n\n[![Build Status](https://badgen.net/github/checks/sequelize/umzug/main)](https://github.com/sequelize/umzug/actions?query=workflow%3ACI)\n[![npm](https://badgen.net/npm/v/umzug)](https://www.npmjs.com/package/umzug)\n[![npm (downloads)](https://badgen.net/npm/dm/umzug)](https://npmjs.com/package/umzug)\n\nUmzug is a framework-agnostic migration tool for Node. It provides a clean API for running and rolling back tasks.\n\n## Highlights\n\n* Written in TypeScript\n\t* Built-in typings\n\t* Auto-completion right in your IDE\n\t* Documentation right in your IDE\n* Programmatic API for migrations\n* Built-in [CLI](#cli)\n* Database agnostic\n* Supports logging of migration process\n* Supports multiple storages for migration data\n* [Usage examples](./examples)\n\n## Documentation\n\n_Note: these are the docs for the latest version of umzug, which has several breaking changes from v2.x. See [the upgrading section](#upgrading-from-v2x) for a migration guide. For the previous stable version, please refer to the [v2.x branch](https://github.com/sequelize/umzug/tree/v2.x)._\n\n### Minimal Example\n\nThe following example uses a Sqlite database through sequelize and persists the migration data in the database itself through the sequelize storage. There are several more involved examples covering a few different scenarios in the [examples folder](./examples). Note that although this uses Sequelize, Umzug isn't coupled to Sequelize, it's just one of the (most commonly-used) supported storages.\n\n```js\n// index.js\nconst { Sequelize } = require('sequelize');\nconst { Umzug, SequelizeStorage } = require('umzug');\n\nconst sequelize = new Sequelize({ dialect: 'sqlite', storage: './db.sqlite' });\n\nconst umzug = new Umzug({\n  migrations: { glob: 'migrations/*.js' },\n  context: sequelize.getQueryInterface(),\n  storage: new SequelizeStorage({ sequelize }),\n  logger: console,\n});\n\n(async () => {\n  // Checks migrations and run them if they are not already applied. To keep\n  // track of the executed migrations, a table (and sequelize model) called SequelizeMeta\n  // will be automatically created (if it doesn't exist already) and parsed.\n  await umzug.up();\n})();\n```\n\n```js\n// migrations/00_initial.js\n\nconst { Sequelize } = require('sequelize');\n\nasync function up({ context: queryInterface }) {\n\tawait queryInterface.createTable('users', {\n\t\tid: {\n\t\t\ttype: Sequelize.INTEGER,\n\t\t\tallowNull: false,\n\t\t\tprimaryKey: true\n\t\t},\n\t\tname: {\n\t\t\ttype: Sequelize.STRING,\n\t\t\tallowNull: false\n\t\t},\n\t\tcreatedAt: {\n\t\t\ttype: Sequelize.DATE,\n\t\t\tallowNull: false\n\t\t},\n\t\tupdatedAt: {\n\t\t\ttype: Sequelize.DATE,\n\t\t\tallowNull: false\n\t\t}\n\t});\n}\n\nasync function down({ context: queryInterface }) {\n\tawait queryInterface.dropTable('users');\n}\n\nmodule.exports = { up, down };\n```\n\nNote that we renamed the `context` argument to `queryInterface` for clarity. The `context` is whatever we specified when creating the Umzug instance in `index.js`.\n\n<details>\n<summary>You can also write your migrations in typescript by using `ts-node` in the entrypoint:</summary>\n\n```typescript\n// index.ts\nrequire('ts-node/register')\n\nimport { Sequelize } from 'sequelize';\nimport { Umzug, SequelizeStorage } from 'umzug';\n\nconst sequelize = new Sequelize({ dialect: 'sqlite', storage: './db.sqlite' });\n\nconst umzug = new Umzug({\n  migrations: { glob: 'migrations/*.ts' },\n  context: sequelize.getQueryInterface(),\n  storage: new SequelizeStorage({ sequelize }),\n  logger: console,\n});\n\n// export the type helper exposed by umzug, which will have the `context` argument typed correctly\nexport type Migration = typeof umzug._types.migration;\n\n(async () => {\n  await umzug.up();\n})();\n```\n\n```typescript\n// migrations/00_initial.ts\nimport type { Migration } from '..';\n\n// types will now be available for `queryInterface`\nexport const up: Migration = ({ context: queryInterface }) => queryInterface.createTable(...)\nexport const down: Migration = ({ context: queryInterface }) => queryInterface.dropTable(...)\n```\n</details>\n\nSee [these tests](./test/umzug.test.ts) for more examples of Umzug usage, including:\n\n- passing `ignore` and `cwd` parameters to the glob instructions\n- customising migrations ordering\n- finding migrations from multiple different directories\n- using non-js file extensions via a custom resolver, e.g. `.sql`\n\n### Usage\n\n#### Installation\n\nUmzug is available on npm by specifying the correct tag:\n\n```bash\nnpm install umzug\n```\n\n#### Umzug instance\n\nIt is possible to configure an Umzug instance by passing an object to the constructor.\n\n```js\nconst { Umzug } = require('umzug');\nconst umzug = new Umzug({ /* ... options ... */ });\n```\n\nDetailed documentation for these options are in the `UmzugOptions` TypeScript interface, which can be found in [src/types.ts](./src/types.ts).\n\n#### Getting all pending migrations\n\nYou can get a list of pending (i.e. not yet executed) migrations with the `pending()` method:\n\n```js\nconst migrations = await umzug.pending();\n// returns an array of all pending migrations.\n```\n\n#### Getting all executed migrations\n\nYou can get a list of already executed migrations with the `executed()` method:\n\n```js\nconst migrations = await umzug.executed();\n// returns an array of all already executed migrations\n```\n\n#### Executing pending migrations\n\nThe `up` method can be used to execute all pending migrations.\n\n```js\nconst migrations = await umzug.up();\n// returns an array of all executed migrations\n```\n\nIt is also possible to pass the name of a migration in order to just run the migrations from the current state to the passed migration name (inclusive).\n\n```js\nawait umzug.up({ to: '20141101203500-task' });\n```\n\nTo limit the number of migrations that are run, `step` can be used:\n\n```js\n// This will run the next two migrations\nawait umzug.up({ step: 2 })\n```\n\nRunning specific migrations while ignoring the right order, can be done like this:\n\n```js\nawait umzug.up({ migrations: ['20141101203500-task', '20141101203501-task-2'] });\n```\n\n#### Reverting executed migration\n\nThe `down` method can be used to revert the last executed migration.\n\n```js\nconst migration = await umzug.down();\n// reverts the last migration and returns it.\n```\n\nTo revert more than one migration, you can use `step`:\n\n```js\n// This will revert the last two migrations\nawait umzug.down({ step: 2 });\n```\n\nIt is possible to pass the name of a migration until which (inclusive) the migrations should be reverted. This allows the reverting of multiple migrations at once.\n\n```js\nconst migrations = await umzug.down({ to: '20141031080000-task' });\n// returns an array of all reverted migrations.\n```\n\nTo revert all migrations, you can pass 0 as the `to` parameter:\n\n```js\nawait umzug.down({ to: 0 });\n```\n\nReverting specific migrations while ignoring the right order, can be done like this:\n\n```js\nawait umzug.down({ migrations: ['20141101203500-task', '20141101203501-task-2'] });\n```\n\n### Migrations\n\nThere are two ways to specify migrations: via files or directly via an array of migrations.\n\n#### Migration files\n\nA migration file ideally exposes an `up` and a `down` async functions. They will perform the task of upgrading or downgrading the database.\n\n```js\nmodule.exports = {\n  async up() {\n    /* ... */\n  },\n  async down() {\n    /* ... */\n  }\n};\n```\n\nMigration files can be located anywhere - they will typically be loaded according to a glob pattern provided to the `Umzug` constructor.\n\n#### Direct migrations list\n\nYou can also specify directly a list of migrations to the `Umzug` constructor:\n\n```js\nconst { Umzug } = require('umzug');\n\nconst umzug = new Umzug({\n  migrations: [\n    {\n      // the name of the migration is mandatory\n      name: '00-first-migration',\n      async up({ context }) { /* ... */ },\n      async down({ context }) { /* ... */ }\n    },\n    {\n      name: '01-foo-bar-migration',\n      async up({ context }) { /* ... */ },\n      async down({ context }) { /* ... */ }\n    }\n  ],\n  context: sequelize.getQueryInterface(),\n  logger: console,\n});\n```\n\n#### Modifying the parameters passed to your migration methods\n\nSometimes it's necessary to modify the parameters `umzug` will pass to your migration methods when the library calls the `up` and `down` methods for each migration. This is the case when using migrations currently generated using `sequelize-cli`. In this case you can use the `resolve` fuction during migration configuration to determine which parameters will be passed to the relevant method\n\n```js\nimport { Sequelize } from 'sequelize'\nimport { Umzug, SequelizeStorage } from 'umzug'\n\nconst sequelize = new Sequelize(\n    ...\n)\n\nconst umzug = new Umzug({\n    migrations: {\n        glob: 'migrations/*.js',\n        resolve: ({ name, path, context }) => {\n            const migration = require(path)\n            return {\n                // adjust the parameters Umzug will\n                // pass to migration methods when called\n                name,\n                up: async () => migration.up(context, Sequelize),\n                down: async () => migration.down(context, Sequelize),\n            }\n        },\n    },\n    context: sequelize.getQueryInterface(),\n    storage: new SequelizeStorage({ sequelize }),\n    logger: console,\n});\n```\n\n#### Additional migration configuration options\n\nTo load migrations in another format, you can use the `resolve` function:\n\n```js\nconst { Umzug } = require('umzug')\nconst { Sequelize } = require('sequelize')\nconst fs = require('fs')\n\nconst umzug = new Umzug({\n  migrations: {\n    glob: 'migrations/*.up.sql',\n    resolve: ({ name, path, context: sequelize }) => ({\n      name,\n      up: async () => {\n        const sql = fs.readFileSync(path).toString()\n        return sequelize.query(sql)\n      },\n      down: async () => {\n        // Get the corresponding `.down.sql` file to undo this migration\n        const sql = fs.readFileSync(path.replace('.up.sql', '.down.sql')).toString()\n        return sequelize.query(sql)\n      }\n    })\n  },\n  context: new Sequelize(...),\n  logger: console,\n});\n```\n\nYou can support mixed migration file types, and use umzug's default resolver for javascript/typescript:\n\n```js\nconst { Umzug } = require('umzug')\nconst { Sequelize } = require('sequelize')\nconst fs = require('fs')\n\nconst umzug = new Umzug({\n  migrations: {\n    glob: 'migrations/*.{js,ts,up.sql}',\n    resolve: (params) => {\n      if (!params.path.endsWith('.sql')) {\n        return Umzug.defaultResolver(params)\n      }\n      const { context: sequelize } = params\n      return {\n        name: params.name,\n        up: async () => {\n          const sql = fs.readFileSync(params.path).toString()\n          return sequelize.query(sql)\n        },\n        down: async () => {\n          // Get the corresponding `.down.sql` file to undo this migration\n          const sql = fs.readFileSync(params.path.replace('.up.sql', '.down.sql')).toString()\n          return sequelize.query(sql)\n        }\n      }\n    },\n  },\n  logger: console,\n  context: new Sequelize(...),\n});\n```\n\nThe glob syntax allows loading migrations from multiple locations:\n\n```js\nconst { Umzug } = require('umzug')\nconst { Sequelize } = require('sequelize')\n\nconst umzug = new Umzug({\n  migrations: {\n    glob: '{first-folder/*.js,second-folder-with-different-naming-convention/*.js}',\n  },\n  context: new Sequelize(...),\n  logger: console,\n});\n```\n\nNote on migration file sorting:\n\n- file matches, found using [glob](https://npmjs.com/package/glob), will be lexicographically sorted based on their paths\n  - so if your migrations are `one/m1.js`, `two/m2.js`, `three/m3.js`, the resultant order will be `one/m1.js`, `three/m3.js`, `two/m2.js`\n  - similarly, if your migrations are called `m1.js`, `m2.js`, ... `m10.js`, `m11.js`, the resultant ordering will be `m1.js`, `m10.js`, `m11.js`, ... `m2.js`\n- The easiest way to deal with this is to ensure your migrations appear in a single folder, and their paths match lexicographically with the order they should run in\n- If this isn't possible, the ordering can be customised using a new instance (previously, in the beta release for v3, this could be done with `.extend(...)` - see below for example using a new instance)\n\n### Upgrading from v2.x\n\nThe Umzug class should be imported as a named import, i.e. `import { Umzug } from 'umzug'`.\n\nThe `MigrationMeta` type, which is returned by `umzug.executed()` and `umzug.pending()`, no longer has a `file` property - it has a `name` and *optional* `path` - since migrations are not necessarily bound to files on the file system.\n\nThe `migrations.glob` parameter replaces `path`, `pattern` and `traverseDirectories`. It can be used, in combination with `cwd` and `ignore` to do much more flexible file lookups. See https://npmjs.com/package/glob for more information on the syntax.\n\nThe `migrations.resolve` parameter replaces `customResolver`. Explicit support for `wrap` and `nameFormatter` has been removed - these can be easily implemented in a `resolve` function.\n\nThe constructor option `logging` is replaced by `logger` to allow for `warn` and `error` messages in future. NodeJS's global `console` object can be passed to this. To disable logging, replace `logging: false` with `logger: undefined`.\n\nEvents have moved from the default nodejs `EventEmitter` to [emittery](https://www.npmjs.com/package/emittery). It has better design for async code, a less bloated API surface and strong types. But, it doesn't allow passing multiple arguments to callbacks, so listeners have to change slightly, as well as `.addListener(...)` and `.removeListener(...)` no longer being supported (`.on(...)` and `.off(...)` should now be used):\n\nBefore:\n\n```js\numzug.on('migrating', (name, m) => console.log({ name, path: m.path }))\n```\n\nAfter:\n\n```js\numzug.on('migrating', ev => console.log({ name: ev.name, path: ev.path }))\n```\n\nThe `Umzug#execute` method is removed. Use `Umzug#up` or `Umzug#down`.\n\nThe options for `Umguz#up` and `Umzug#down` have changed:\n- `umzug.up({ to: 'some-name' })` and `umzug.down({ to: 'some-name' })` are still valid.\n- `umzug.up({ from: '...' })` and `umzug.down({ from: '...' })` are no longer supported. To run migrations out-of-order (which is not generally recommended), you can explicitly use `umzug.up({ migrations: ['...'] })` and `umzug.down({ migrations: ['...'] })`.\n- name matches must be exact. `umzug.up({ to: 'some-n' })` will no longer match a migration called `some-name`.\n- `umzug.down({ to: 0 })` is still valid but `umzug.up({ to: 0 })` is not.\n- `umzug.up({ migrations: ['m1', 'm2'] })` is still valid but the shorthand `umzug.up(['m1', 'm2'])` has been removed.\n- `umzug.down({ migrations: ['m1', 'm2'] })` is still valid but the shorthand `umzug.down(['m1', 'm2'])` has been removed.\n- `umzug.up({ migrations: ['m1', 'already-run'] })` will throw an error, if `already-run` is not found in the list of pending migrations.\n- `umzug.down({ migrations: ['m1', 'has-not-been-run'] })` will throw an error, if `has-not-been-run` is not found in the list of executed migrations.\n- `umzug.up({ migrations: ['m1', 'm2'], rerun: 'ALLOW' })` will re-apply migrations `m1` and `m2` even if they've already been run.\n- `umzug.up({ migrations: ['m1', 'm2'], rerun: 'SKIP' })` will skip migrations `m1` and `m2` if they've already been run.\n- `umzug.down({ migrations: ['m1', 'm2'], rerun: 'ALLOW' })` will \"revert\" migrations `m1` and `m2` even if they've never been run.\n- `umzug.down({ migrations: ['m1', 'm2'], rerun: 'SKIP' })` will skip reverting migrations `m1` and `m2` if they haven't been run or are already reverted.\n- `umzug.up({ migrations: ['m1', 'does-not-exist', 'm2'] })` will throw an error if the migration name is not found. Note that the error will be thrown and no migrations run unless _all_ migration names are found - whether or not `rerun: 'ALLOW'` is added.\n\nThe `context` parameter replaces `params`, and is passed in as a property to migration functions as an options object, alongs side `name` and `path`. This means the signature for migrations, which in v2 was `(context) => Promise<void>`, has changed slightly in v3, to `({ name, path, context }) => Promise<void>`.\n\n#### Handling existing v2-format migrations\n\nThe `resolve` function can also be used to upgrade your umzug version to v3 when you have existing v2-compatible migrations:\n\n```js\nconst { Umzug } = require('umzug');\n\nconst umzug = new Umzug({\n  migrations: {\n    glob: 'migrations/umzug-v2-format/*.js',\n    resolve: ({name, path, context}) => {\n      // Adjust the migration from the new signature to the v2 signature, making easier to upgrade to v3\n      const migration = require(path)\n      return { name, up: async () => migration.up(context), down: async () => migration.down(context) }\n    }\n  },\n  context: sequelize.getQueryInterface(),\n  logger: console,\n});\n```\n\nSimilarly, you no longer need `migrationSorting`, you can instantiate a new `Umzug` instance to manipulate migration lists directly:\n\n```js\nconst { Umzug } = require('umzug');\n\nconst parent = new Umzug({\n  migrations: { glob: 'migrations/**/*.js' },\n  context: sequelize.getQueryInterface(),\n})\n\nconst umzug = new Umzug({\n  ...parent.options,\n  migrations: ctx => (await parent.migrations()).sort((a, b) => b.path.localeCompare(a.path))\n})\n```\n\n### Storages\n\nStorages define where the migration data is stored.\n\n#### JSON Storage\n\nUsing `JSONStorage` will create a JSON file which will contain an array with all the executed migrations. You can specify the path to the file. The default for that is `umzug.json` in the working directory of the process.\n\nDetailed documentation for the options it can take are in the `JSONStorageConstructorOptions` TypeScript interface, which can be found in [src/storage/json.ts](./src/storage/json.ts).\n\n#### Memory Storage\n\nUsing `memoryStorage` will store migrations with an in-memory array. This can be useful for proof-of-concepts or tests, since it doesn't interact with databases or filesystems.\n\nIt doesn't take any options, just import the `memoryStorage` function and call it to return a storage instance:\n\n```typescript\nimport { Umzug, memoryStorage } from 'umzug'\n\nconst umzug = new Umzug({\n  migrations: ...,\n  storage: memoryStorage(),\n  logger: console,\n})\n```\n\n#### Sequelize Storage\n\nUsing `SequelizeStorage` will create a table in your SQL database called `SequelizeMeta` containing an entry for each executed migration. You will have to pass a configured instance of Sequelize or an existing Sequelize model. Optionally you can specify the model name, table name, or column name. All major Sequelize versions are supported.\n\nDetailed documentation for the options it can take are in the `_SequelizeStorageConstructorOptions` TypeScript interface, which can be found in [src/storage/sequelize.ts](./src/storage/sequelize.ts).\n\nThis library has been tested with sequelize v6. It may or may not work with lower versions - use at your own risk.\n\n#### MongoDB Storage\n\nUsing `MongoDBStorage` will create a collection in your MongoDB database called `migrations` containing an entry for each executed migration. You will have either to pass a MongoDB Driver Collection as `collection` property. Alternatively you can pass a established MongoDB Driver connection and a collection name.\n\nDetailed documentation for the options it can take are in the `MongoDBStorageConstructorOptions` TypeScript interface, which can be found in [src/storage/mongodb.ts](./src/storage/mongodb.ts).\n\n#### Custom\n\nIn order to use a custom storage, you can pass your storage instance to Umzug constructor.\n\n```js\nclass CustomStorage {\n  constructor(...) {...}\n  logMigration(...) {...}\n  unlogMigration(...) {...}\n  executed(...) {...}\n}\n\nconst umzug = new Umzug({ storage: new CustomStorage(...), logger: console })\n```\n\nYour instance must adhere to the [UmzugStorage](./src/storage/contract.ts) interface. If you're using TypeScript you can ensure this at compile time, and get IDE type hints by importing it:\n\n```typescript\nimport { UmzugStorage } from 'umzug'\n\nclass CustomStorage implements UmzugStorage {\n  /* ... */\n}\n```\n\n### Events\n\nUmzug is an [emittery event emitter](https://www.npmjs.com/package/emittery). Each of the following events will be called with migration parameters as its payload (with `context`, `name`, and nullable `path` properties). Events are a convenient place to implement application-specific logic that must run around each migration:\n\n* `migrating` - A migration is about to be executed.\n* `migrated` - A migration has successfully been executed.\n* `reverting` - A migration is about to be reverted.\n* `reverted` - A migration has successfully been reverted.\n\nThese events run at the beginning and end of `up` and `down` calls. They'll receive an object containing a `context` property:\n\n- `beforeCommand` - Before any command (`'up' | 'down' | 'executed' | 'pending'`) is run.\n- `afterCommand` - After any command (`'up' | 'down' | 'executed' | 'pending'`) is run. Note: this will always run, even if the command throws an error.\n\nThe [`FileLocker` class](./src/file-locker.ts) uses `beforeAll` and `afterAll` to implement a simple filesystem-based locking mechanism.\n\nAll events are type-safe, so IDEs will prevent typos and supply strong types for the event payloads.\n\n### Errors\n\nWhen a migration throws an error, it will be wrapped in a `MigrationError` which captures the migration metadata (name, path etc.) as well as the original error message, and _will be rethrown_. In most cases, this is expected behaviour, and doesn't require any special handling beyond standard error logging setups.\n\nIf you expect failures and want to try to recover from them, you will need to try-catch the call to `umzug.up()`. You can access the original error from the `.cause` property if necessary:\n\n```js\ntry {\n  await umzug.up();\n} catch (e) {\n  if (e instanceof MigrationError) {\n    const original = e.cause;\n    // do something with the original error here\n  }\n  throw e;\n}\n```\n\nUnder the hood, [verror](https://npmjs.com/package/verror) is used to wrap errors.\n\n### CLI\n\n🚧🚧🚧 The CLI is new to Umzug v3. Feedback on it is welcome in [discussions](https://github.com/sequelize/umzug/discussions) 🚧🚧🚧\n\nUmzug instances provide a `.runAsCLI()` method. When called, this method will automatically cause your program to become a complete CLI, with help text and such:\n\n```js\n// migrator.js\nconst { Umzug } = require('umzug')\n\nconst umzug = new Umzug({ ... })\n\nexports.umzug = umzug\n\nif (require.main === module) {\n  umzug.runAsCLI()\n}\n```\n\nNote that this uses the [@rushstack/ts-command-line](https://www.npmjs.com/package/@rushstack/ts-command-line) package, which shows only the top-level message of any errors throw by default. See [here](https://github.com/sequelize/umzug/issues/619#issuecomment-1793297576) for how you can see a full stack trace.\n\n#### CLI Usage\n\nA script like the one above is now a runnable CLI program. You can run `node migrator.js --help` to see how to use it. It will print something like:\n\n<!-- codegen:start {preset: custom, source: ./codegen.js, export: cliHelp} -->\n```\nusage: <script> [-h] <command> ...\n\nUmzug migrator\n\nPositional arguments:\n  <command>\n    up        Applies pending migrations\n    down      Revert migrations\n    pending   Lists pending migrations\n    executed  Lists executed migrations\n    create    Create a migration file\n\nOptional arguments:\n  -h, --help  Show this help message and exit.\n\nFor detailed help about a specific command, use: <script> <command> -h\n```\n<!-- codegen:end -->\n\n#### Running migrations\n\n`node migrator up` and `node migrator down` apply and revert migrations respectively. They're the equivalent of the `.up()` and `.down()` methods.\n\nUse `node migrator up --help` and `node migrator down --help` for options (running \"to\" a specific migration, passing migration names to be run explicitly, and specifying the rerun behavior):\n\nUp:\n<!-- codegen:start {preset: custom, source: ./codegen.js, export: cliHelp, action: up} -->\n```\nusage: <script> up [-h] [--to NAME] [--step COUNT] [--name MIGRATION]\n                   [--rerun {THROW,SKIP,ALLOW}]\n                   \n\nPerforms all migrations. See --help for more options\n\nOptional arguments:\n  -h, --help            Show this help message and exit.\n  --to NAME             All migrations up to and including this one should be \n                        applied.\n  --step COUNT          Run this many migrations. If not specified, all will \n                        be applied.\n  --name MIGRATION      Explicity declare migration name(s) to be applied.\n  --rerun {THROW,SKIP,ALLOW}\n                        Specify what action should be taken when a migration \n                        that has already been applied is passed to --name. \n                        The default value is \"THROW\".\n```\n<!-- codegen:end -->\n\nDown:\n<!-- codegen:start {preset: custom, source: ./codegen.js, export: cliHelp, action: down} -->\n```\nusage: <script> down [-h] [--to NAME] [--step COUNT] [--name MIGRATION]\n                     [--rerun {THROW,SKIP,ALLOW}]\n                     \n\nUndoes previously-applied migrations. By default, undoes the most recent \nmigration only. Use --help for more options. Useful in development to start \nfrom a clean slate. Use with care in production!\n\nOptional arguments:\n  -h, --help            Show this help message and exit.\n  --to NAME             All migrations up to and including this one should be \n                        reverted. Pass \"0\" to revert all.\n  --step COUNT          Run this many migrations. If not specified, one will \n                        be reverted.\n  --name MIGRATION      Explicity declare migration name(s) to be reverted.\n  --rerun {THROW,SKIP,ALLOW}\n                        Specify what action should be taken when a migration \n                        that has already been reverted is passed to --name. \n                        The default value is \"THROW\".\n```\n<!-- codegen:end -->\n\n\n#### Listing migrations\n\n```bash\nnode migrator pending # list migrations yet to be run\nnode migrator executed # list migrations that have already run\n\nnode migrator pending --json # list pending migrations including names and paths, in a json array format\nnode migrator executed --json # list executed migrations including names and paths, in a json array format\n\nnode migrator pending --help # show help/options\nnode migrator executed --help # show help/options\n```\n\n<!-- codegen:start {preset: custom, source: ./codegen.js, export: cliHelp, action: pending} -->\n```\nusage: <script> pending [-h] [--json]\n\nPrints migrations returned by `umzug.pending()`. By default, prints migration \nnames one per line.\n\nOptional arguments:\n  -h, --help  Show this help message and exit.\n  --json      Print pending migrations in a json format including names and \n              paths. This allows piping output to tools like jq. Without this \n              flag, the migration names will be printed one per line.\n```\n<!-- codegen:end -->\n\n<!-- codegen:start {preset: custom, source: ./codegen.js, export: cliHelp, action: executed} -->\n```\nusage: <script> executed [-h] [--json]\n\nPrints migrations returned by `umzug.executed()`. By default, prints \nmigration names one per line.\n\nOptional arguments:\n  -h, --help  Show this help message and exit.\n  --json      Print executed migrations in a json format including names and \n              paths. This allows piping output to tools like jq. Without this \n              flag, the migration names will be printed one per line.\n```\n<!-- codegen:end -->\n\n#### Creating migrations - CLI\n\nUsually, migrations correspond to files on the filesystem. The CLI exposes a way to create migration files easily:\n\n```bash\nnode migrator create --name my-migration.js\n```\n\nThis will create a file with a name like `2000.12.25T12.34.56.my-migration.js` in the same directory as the most recent migration file. If it's the very first migration file, you need to specify the folder explicitly:\n\n```bash\nnode migrator create --name my-migration.js --folder path/to/directory\n```\n\nThe timestamp prefix can be customized to be date-only or omitted, but be aware that it's strongly recommended to ensure your migrations are lexicographically sortable so it's easy for humans and tools to determine what order they should run in - so the default prefix is recommended.\n\nThis will generate a migration file called `<<timestamp>>.my-migration.js` with the default migration template for `.js` files that ships with Umzug.\n\nUmzug also ships with default templates for [`.ts`, `.cjs`, `.mjs` and `.sql` files](./src/templates.ts). Umzug will choose the template based on the extension you provide in `name`.\n\nYou can specify a custom template for your project when constructing an umzug instance via the `template` option. It should be a function which receives a filepath string, and returns an array of `[filepath, content]` pairs. Usually, just one pair is needed, but a second could be used to include a \"down\" migration in a separate file:\n\n```js\nconst umzug = new Umzug({\n  migrations: ...,\n\tcreate: {\n\t\ttemplate: filepath => [\n\t\t\t[filepath, fs.readFileSync('path/to/your/template/file').toString()],\n\t\t]\n\t}\n})\n```\n\nThe create command includes some safety checks to make sure migrations aren't created with ambiguous ordering, and that they will be picked up by umzug when applying migrations. The first pair is expected to be the \"up\" migration file, and to be picked up by the `pending` command.\n\nUse `node migrator create --help` for more options:\n\n<!-- codegen:start {preset: custom, source: ./codegen.js, export: cliHelp, action: create} -->\n```\nusage: <script> create [-h] --name NAME [--prefix {TIMESTAMP,DATE,NONE}]\n                       [--folder PATH] [--allow-extension EXTENSION]\n                       [--skip-verify] [--allow-confusing-ordering]\n                       \n\nGenerates a placeholder migration file using a timestamp as a prefix. By \ndefault, mimics the last existing migration, or guesses where to generate the \nfile if no migration exists yet.\n\nOptional arguments:\n  -h, --help            Show this help message and exit.\n  --name NAME           The name of the migration file. e.g. my-migration.js, \n                        my-migration.ts or my-migration.sql. Note - a prefix \n                        will be added to this name, usually based on a \n                        timestamp. See --prefix\n  --prefix {TIMESTAMP,DATE,NONE}\n                        The prefix format for generated files. TIMESTAMP uses \n                        a second-resolution timestamp, DATE uses a \n                        day-resolution timestamp, and NONE removes the prefix \n                        completely. The default value is \"TIMESTAMP\".\n  --folder PATH         Path on the filesystem where the file should be \n                        created. The new migration will be created as a \n                        sibling of the last existing one if this is omitted.\n  --allow-extension EXTENSION\n                        Allowable extension for created files. By default .js,\n                         .ts and .sql files can be created. To create txt \n                        file migrations, for example, you could use '--name \n                        my-migration.txt --allow-extension .txt' This \n                        parameter may alternatively be specified via the \n                        UMZUG_ALLOW_EXTENSION environment variable.\n  --skip-verify         By default, the generated file will be checked after \n                        creation to make sure it is detected as a pending \n                        migration. This catches problems like creation in the \n                        wrong folder, or invalid naming conventions. This \n                        flag bypasses that verification step.\n  --allow-confusing-ordering\n                        By default, an error will be thrown if you try to \n                        create a migration that will run before a migration \n                        that already exists. This catches errors which can \n                        cause problems if you change file naming conventions. \n                        If you use a custom ordering system, you can disable \n                        this behavior, but it's strongly recommended that you \n                        don't! If you're unsure, just ignore this option.\n```\n<!-- codegen:end -->\n\n### Creating migrations - API\n\nUmzug includes an optional helper for generating migration files. It's often most convenient to create files using the [CLI helper](#creating-migrations---cli), but the equivalent API also exists on an umzug instance:\n\n```js\nawait umzug.create({ name: 'my-new-migration.js' })\n```\n\n## License\n\nSee the [LICENSE file](./LICENSE)\n","readmeFilename":"README.md","gitHead":"1dfa1d1b00ace06acd8ba78a77d0a94cde6a2c08","types":"./lib/index.d.ts","_nodeVersion":"20.8.0","_npmVersion":"10.1.0","dist":{"integrity":"sha512-NI4yzmYO6RdKiWWIQe/2ZGXWDXMa835gJ4FfTPoW1fZw0psB5tzwXWknButl+NM1ix+utJuZnzko7pW20nl+xQ==","shasum":"aa06ad413306171c8c353a3e0dec4b3b0c998f8e","tarball":"https://registry.npmjs.org/umzug/-/umzug-3.5.0-0.tgz","fileCount":39,"unpackedSize":135942,"signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEQCIGNtsO8mfha6obWpIDXmYtgrAoi4UcjYEgj8lmfBtglhAiAwd5Eym30z9435pJmCkuywZtX5xDLe6O5mESNLjPjxgA=="}]},"_npmUser":{"name":"mmkale","email":"mmkal1@outlook.com"},"directories":{},"maintainers":[{"name":"pascal.pflaum","email":"mail@pascalpflaum.de"},{"name":"sdepold","email":"sascha@depold.com"},{"name":"sushantdhiman","email":"sushantdhiman@outlook.com"},{"name":"papb","email":"papb1996@gmail.com"},{"name":"mmkale","email":"mmkal1@outlook.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/umzug_3.5.0-0_1699296461442_0.8066562617096908"},"_hasShrinkwrap":false},"3.5.0":{"name":"umzug","version":"3.5.0","description":"Framework-agnostic migration tool for Node","keywords":["migrate","migration","migrations","sequelize","database"],"main":"lib/index.js","dependencies":{"@rushstack/ts-command-line":"^4.12.2","emittery":"^0.13.0","glob":"^8.0.3","pony-cause":"^2.1.4","type-fest":"^3.0.0"},"devDependencies":{"@types/glob":"8.0.0","@types/lodash":"4.14.186","@types/uuid":"8.3.4","@types/verror":"1.10.6","@typescript-eslint/eslint-plugin":"5.42.1","@typescript-eslint/parser":"5.42.1","@vitest/coverage-v8":"^0.34.6","@vitest/ui":"^0.34.6","del":"^5.0.0","del-cli":"5.0.0","eslint":"8.27.0","eslint-config-xo":"0.43.1","eslint-config-xo-typescript":"0.54.1","eslint-plugin-codegen":"0.16.1","eslint-plugin-import":"2.26.0","eslint-plugin-mocha":"10.1.0","eslint-plugin-prettier":"4.2.1","eslint-plugin-unicorn":"44.0.2","execa":"^5.1.1","expect-type":"0.14.2","fs-syncer":"0.4.0","lodash":"4.17.21","np":"8.0.4","p-event":"^4.0.0","prettier":"2.7.1","sequelize":"6.34.0","sinon":"14.0.0","source-map-support":"0.5.21","sqlite3":"npm:@vscode/sqlite3@5.0.8","strip-ansi":"6.0.1","ts-node":"10.9.1","typescript":"4.8.4","uuid":"9.0.0","verror":"1.10.1","vitest":"^0.34.6"},"scripts":{"clean":"del-cli lib","compile":"tsc -p tsconfig.lib.json","build":"npm run clean && npm run compile","eslint":"eslint --ext .js,.ts,.md . --max-warnings 0","lint":"npm run type-check && npm run eslint","prepare":"npm run build","release":"np --no-yarn --no-2fa","pretest":"del-cli test/generated","test":"vitest","type-check":"tsc -p ."},"repository":{"type":"git","url":"git+https://github.com/sequelize/umzug.git"},"author":{"name":"Sascha Depold","email":"sascha@depold.com"},"contributors":[{"name":"Misha Kaletsky","email":"mmkal@kaletsky.com"},{"name":"Jukka Hyytiälä","email":"hyytiala.jukka@gmail.com"},{"name":"Pascal Pflaum","email":"mail@pascalpflaum.de"},{"name":"Pedro Augusto de Paula Barbosa","email":"papb1996@gmail.com"}],"license":"MIT","bugs":{"url":"https://github.com/sequelize/umzug/issues"},"homepage":"https://github.com/sequelize/umzug","engines":{"node":">=12"},"_id":"umzug@3.5.0","gitHead":"14049f3d3984ab2bd30adb3a97db707b1a8a23b6","types":"./lib/index.d.ts","_nodeVersion":"20.8.0","_npmVersion":"10.1.0","dist":{"integrity":"sha512-bL6JjH716l0kg7V2Acrw5UmUgeLxdAZv3drMhKrJCXxEfK/qyM+B5s3ai1BjG1NyEGeXTOkhFIUgkMFo6zqVBg==","shasum":"d93d0775de0c17d1a7cb57e61003774b4b2759ce","tarball":"https://registry.npmjs.org/umzug/-/umzug-3.5.0.tgz","fileCount":39,"unpackedSize":135940,"signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIQDERkJMrj5qeHiO25DjkQyWFs5zGsU0E9lzIYeuRMTZWAIgTiMnSRpkNIAj53ZSeO1tY0bfAUX5yF1UfNlvPlme/0Y="}]},"_npmUser":{"name":"mmkale","email":"mmkal1@outlook.com"},"directories":{},"maintainers":[{"name":"pascal.pflaum","email":"mail@pascalpflaum.de"},{"name":"sdepold","email":"sascha@depold.com"},{"name":"sushantdhiman","email":"sushantdhiman@outlook.com"},{"name":"papb","email":"papb1996@gmail.com"},{"name":"mmkale","email":"mmkal1@outlook.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/umzug_3.5.0_1702609755211_0.7463487647119122"},"_hasShrinkwrap":false},"3.5.1":{"name":"umzug","version":"3.5.1","description":"Framework-agnostic migration tool for Node","keywords":["migrate","migration","migrations","sequelize","database"],"main":"lib/index.js","dependencies":{"@rushstack/ts-command-line":"^4.12.2","emittery":"^0.13.0","glob":"^8.0.3","pony-cause":"^2.1.4","type-fest":"^3.0.0"},"devDependencies":{"@types/glob":"8.0.0","@types/lodash":"4.14.186","@types/uuid":"8.3.4","@types/verror":"1.10.6","@typescript-eslint/eslint-plugin":"5.42.1","@typescript-eslint/parser":"5.42.1","@vitest/coverage-v8":"^0.34.6","@vitest/ui":"^0.34.6","del":"^5.0.0","del-cli":"5.0.0","eslint":"8.27.0","eslint-config-xo":"0.43.1","eslint-config-xo-typescript":"0.54.1","eslint-plugin-codegen":"0.16.1","eslint-plugin-import":"2.26.0","eslint-plugin-mocha":"10.1.0","eslint-plugin-prettier":"4.2.1","eslint-plugin-unicorn":"44.0.2","execa":"^5.1.1","expect-type":"0.14.2","fs-syncer":"0.4.0","lodash":"4.17.21","np":"8.0.4","p-event":"^4.0.0","prettier":"2.7.1","sequelize":"6.34.0","sinon":"14.0.0","source-map-support":"0.5.21","sqlite3":"npm:@vscode/sqlite3@5.0.8","strip-ansi":"6.0.1","ts-node":"10.9.1","typescript":"4.8.4","uuid":"9.0.0","verror":"1.10.1","vitest":"^0.34.6"},"scripts":{"clean":"del-cli lib","compile":"tsc -p tsconfig.lib.json","build":"npm run clean && npm run compile","eslint":"eslint --ext .js,.ts,.md . --max-warnings 0","lint":"npm run type-check && npm run eslint","prepare":"npm run build","release":"np --no-yarn --no-2fa","pretest":"del-cli test/generated","test":"vitest","type-check":"tsc -p ."},"repository":{"type":"git","url":"git+https://github.com/sequelize/umzug.git"},"author":{"name":"Sascha Depold","email":"sascha@depold.com"},"contributors":[{"name":"Misha Kaletsky","email":"mmkal@kaletsky.com"},{"name":"Jukka Hyytiälä","email":"hyytiala.jukka@gmail.com"},{"name":"Pascal Pflaum","email":"mail@pascalpflaum.de"},{"name":"Pedro Augusto de Paula Barbosa","email":"papb1996@gmail.com"}],"license":"MIT","bugs":{"url":"https://github.com/sequelize/umzug/issues"},"homepage":"https://github.com/sequelize/umzug","engines":{"node":">=12"},"types":"./lib/index.d.ts","gitHead":"2e9599b9c598bd461309a5430ad8688f65252728","_id":"umzug@3.5.1","_nodeVersion":"18.13.0","_npmVersion":"8.19.3","dist":{"integrity":"sha512-jvhKP16BSjgQFNna4OhyTq5R8FYL51F1Pxdv9B+BVf/5zoazCWDmIQuyMWKsYPdbeLLJW4/dJzvpH2DvM7wcug==","shasum":"8a0a0f7b14ba362b0cab7260647a584c9c2b7528","tarball":"https://registry.npmjs.org/umzug/-/umzug-3.5.1.tgz","fileCount":39,"unpackedSize":135917,"signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIC6UPYemQmvo0Tx0604cB6Keg1MR1K0kuZShs5kkvW10AiEAzaX8nZcC7S6HMRV2YqTNB2Qb/3je0JBMsvFnEQ2Yrd0="}]},"_npmUser":{"name":"mmkale","email":"mmkal1@outlook.com"},"directories":{},"maintainers":[{"name":"pascal.pflaum","email":"mail@pascalpflaum.de"},{"name":"sdepold","email":"sascha@depold.com"},{"name":"sushantdhiman","email":"sushantdhiman@outlook.com"},{"name":"papb","email":"papb1996@gmail.com"},{"name":"mmkale","email":"mmkal1@outlook.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/umzug_3.5.1_1705511906635_0.23074387117922734"},"_hasShrinkwrap":false},"3.6.0":{"name":"umzug","version":"3.6.0","description":"Framework-agnostic migration tool for Node","keywords":["migrate","migration","migrations","sequelize","database"],"main":"lib/index.js","dependencies":{"@rushstack/ts-command-line":"^4.12.2","emittery":"^0.13.0","glob":"^8.0.3","pony-cause":"^2.1.4","type-fest":"^4.0.0"},"devDependencies":{"@types/glob":"8.0.0","@types/lodash":"4.14.186","@types/uuid":"8.3.4","@types/verror":"1.10.6","@typescript-eslint/eslint-plugin":"5.42.1","@typescript-eslint/parser":"5.42.1","@vitest/coverage-v8":"^0.34.6","@vitest/ui":"^0.34.6","del":"^5.0.0","del-cli":"5.0.0","eslint":"8.27.0","eslint-config-xo":"0.43.1","eslint-config-xo-typescript":"0.54.1","eslint-plugin-codegen":"0.16.1","eslint-plugin-import":"2.26.0","eslint-plugin-mocha":"10.1.0","eslint-plugin-prettier":"4.2.1","eslint-plugin-unicorn":"44.0.2","execa":"^5.1.1","expect-type":"0.14.2","fs-syncer":"0.4.0","lodash":"4.17.21","np":"github:mmkal/np#9a214043e2220bda412c9dcf14774d596da57d0f","p-event":"^4.0.0","prettier":"2.7.1","sequelize":"6.34.0","sinon":"14.0.0","source-map-support":"0.5.21","sqlite3":"npm:@vscode/sqlite3@5.0.8","strip-ansi":"6.0.1","ts-node":"10.9.1","typescript":"4.8.4","uuid":"9.0.0","verror":"1.10.1","vitest":"^0.34.6"},"scripts":{"clean":"del-cli lib","compile":"tsc -p tsconfig.lib.json","build":"npm run clean && npm run compile","eslint":"eslint --ext .js,.ts,.md . --max-warnings 0","lint":"npm run type-check && npm run eslint","prepare":"npm run build","release":"np --no-yarn --no-2fa","pretest":"del-cli test/generated","test":"vitest run","type-check":"tsc -p ."},"repository":{"type":"git","url":"git+https://github.com/sequelize/umzug.git"},"author":{"name":"Sascha Depold","email":"sascha@depold.com"},"contributors":[{"name":"Misha Kaletsky","email":"mmkal@kaletsky.com"},{"name":"Jukka Hyytiälä","email":"hyytiala.jukka@gmail.com"},{"name":"Pascal Pflaum","email":"mail@pascalpflaum.de"},{"name":"Pedro Augusto de Paula Barbosa","email":"papb1996@gmail.com"}],"license":"MIT","bugs":{"url":"https://github.com/sequelize/umzug/issues"},"homepage":"https://github.com/sequelize/umzug","engines":{"node":">=12"},"_id":"umzug@3.6.0","gitHead":"4238da05b9e35a3b771bcbd38ac6827ffa390c0f","types":"./lib/index.d.ts","_nodeVersion":"20.8.0","_npmVersion":"10.1.0","dist":{"integrity":"sha512-stF89hyBrFrREu5nCPqsEQlUyLGoa87szJZtyWhE3jiI7GjeCQ+odWuE+y7fLnsZsBTa0X49UwN7/RyQi6Wisw==","shasum":"7f64894886062c1702b395b0c074162e9aaf5b59","tarball":"https://registry.npmjs.org/umzug/-/umzug-3.6.0.tgz","fileCount":39,"unpackedSize":138539,"signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEQCICbe9lYIv34e/A+QI+TsZoRYsNIOjFaUrZEwVNJtIwx5AiAN+bEzzuiYXdTGHa6hD1LOu4oSllZq+aeL4yqIf8sIew=="}]},"_npmUser":{"name":"mmkale","email":"mmkal1@outlook.com"},"directories":{},"maintainers":[{"name":"pascal.pflaum","email":"mail@pascalpflaum.de"},{"name":"sdepold","email":"sascha@depold.com"},{"name":"sushantdhiman","email":"sushantdhiman@outlook.com"},{"name":"papb","email":"papb1996@gmail.com"},{"name":"mmkale","email":"mmkal1@outlook.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/umzug_3.6.0_1706724837762_0.9968583054921047"},"_hasShrinkwrap":false},"3.6.1":{"name":"umzug","version":"3.6.1","description":"Framework-agnostic migration tool for Node","keywords":["migrate","migration","migrations","sequelize","database"],"main":"lib/index.js","dependencies":{"@rushstack/ts-command-line":"^4.12.2","emittery":"^0.13.0","glob":"^8.0.3","pony-cause":"^2.1.4","type-fest":"^4.0.0"},"devDependencies":{"@types/glob":"8.0.0","@types/lodash":"4.14.186","@types/uuid":"8.3.4","@types/verror":"1.10.6","@typescript-eslint/eslint-plugin":"5.42.1","@typescript-eslint/parser":"5.42.1","@vitest/coverage-v8":"^0.34.6","@vitest/ui":"^0.34.6","del":"^5.0.0","del-cli":"5.0.0","eslint":"8.27.0","eslint-config-xo":"0.43.1","eslint-config-xo-typescript":"0.54.1","eslint-plugin-codegen":"0.16.1","eslint-plugin-import":"2.26.0","eslint-plugin-mocha":"10.1.0","eslint-plugin-prettier":"4.2.1","eslint-plugin-unicorn":"44.0.2","execa":"^5.1.1","expect-type":"0.14.2","fs-syncer":"0.4.0","lodash":"4.17.21","np":"github:mmkal/np#6a58244afa28fd7d3f8c4dc4b6457c22d74e82de","p-event":"^4.0.0","prettier":"2.7.1","sequelize":"6.34.0","sinon":"14.0.0","source-map-support":"0.5.21","sqlite3":"npm:@vscode/sqlite3@5.0.8","strip-ansi":"6.0.1","ts-node":"10.9.1","typescript":"4.8.4","uuid":"9.0.0","verror":"1.10.1","vitest":"^0.34.6"},"scripts":{"clean":"del-cli lib","compile":"tsc -p tsconfig.lib.json","build":"npm run clean && npm run compile","eslint":"eslint --ext .js,.ts,.md . --max-warnings 0","lint":"npm run type-check && npm run eslint","prepare":"npm run build","release":"np --no-yarn --no-2fa","pretest":"del-cli test/generated","test":"vitest run","type-check":"tsc -p ."},"repository":{"type":"git","url":"git+https://github.com/sequelize/umzug.git"},"author":{"name":"Sascha Depold","email":"sascha@depold.com"},"contributors":[{"name":"Misha Kaletsky","email":"mmkal@kaletsky.com"},{"name":"Jukka Hyytiälä","email":"hyytiala.jukka@gmail.com"},{"name":"Pascal Pflaum","email":"mail@pascalpflaum.de"},{"name":"Pedro Augusto de Paula Barbosa","email":"papb1996@gmail.com"}],"license":"MIT","bugs":{"url":"https://github.com/sequelize/umzug/issues"},"homepage":"https://github.com/sequelize/umzug","engines":{"node":">=12"},"_id":"umzug@3.6.1","gitHead":"98d44a47adce401621a3667c7c77954563cb6e0b","types":"./lib/index.d.ts","_nodeVersion":"20.8.0","_npmVersion":"10.1.0","dist":{"integrity":"sha512-+ztJ2muIkP/Qw8w+4GfXEOrBZ/1kf9xlAyk9PSg2ZOpM5zX45vtQFDfuV18CdQLE1HWDL7EYT3Qcw0hFMWcp2Q==","shasum":"e895b160365ed9ef320ff422acba6fab08695c07","tarball":"https://registry.npmjs.org/umzug/-/umzug-3.6.1.tgz","fileCount":39,"unpackedSize":138539,"signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEQCICeEK/aWjxVcUE3nNnvXSUWSW7xZRtANZmtkvt7cwHNaAiBEZT4INdSP+88l/nTDiJi2IyBV/2BtIUyJm2cipXT/Ww=="}]},"_npmUser":{"name":"mmkale","email":"mmkal1@outlook.com"},"directories":{},"maintainers":[{"name":"pascal.pflaum","email":"mail@pascalpflaum.de"},{"name":"sdepold","email":"sascha@depold.com"},{"name":"sushantdhiman","email":"sushantdhiman@outlook.com"},{"name":"papb","email":"papb1996@gmail.com"},{"name":"mmkale","email":"mmkal1@outlook.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/umzug_3.6.1_1706725785869_0.26559659370290567"},"_hasShrinkwrap":false},"3.7.0":{"name":"umzug","version":"3.7.0","description":"Framework-agnostic migration tool for Node","keywords":["migrate","migration","migrations","sequelize","database"],"main":"lib/index.js","dependencies":{"@rushstack/ts-command-line":"^4.12.2","emittery":"^0.13.0","glob":"^8.0.3","pony-cause":"^2.1.4","type-fest":"^4.0.0"},"devDependencies":{"@types/glob":"8.0.0","@types/lodash":"4.14.186","@types/uuid":"8.3.4","@types/verror":"1.10.6","@typescript-eslint/eslint-plugin":"5.42.1","@typescript-eslint/parser":"5.42.1","@vitest/coverage-v8":"^0.34.6","@vitest/ui":"^0.34.6","del":"^5.0.0","del-cli":"5.0.0","eslint":"8.27.0","eslint-config-xo":"0.43.1","eslint-config-xo-typescript":"0.54.1","eslint-plugin-codegen":"0.16.1","eslint-plugin-import":"2.26.0","eslint-plugin-mocha":"10.1.0","eslint-plugin-prettier":"4.2.1","eslint-plugin-unicorn":"44.0.2","execa":"^5.1.1","expect-type":"0.14.2","fs-syncer":"0.4.0","lodash":"4.17.21","np":"github:mmkal/np#pnpm","p-event":"^4.0.0","prettier":"2.7.1","sequelize":"6.34.0","sinon":"14.0.0","source-map-support":"0.5.21","sqlite3":"npm:@vscode/sqlite3@5.0.8","strip-ansi":"6.0.1","ts-node":"10.9.1","typescript":"4.8.4","uuid":"9.0.0","verror":"1.10.1","vitest":"^0.34.6"},"scripts":{"clean":"del-cli lib","compile":"tsc -p tsconfig.lib.json","build":"npm run clean && npm run compile","eslint":"eslint --ext .js,.ts,.md . --max-warnings 0","lint":"npm run type-check && npm run eslint","prepare":"npm run build","release":"np --no-yarn --no-2fa","pretest":"del-cli test/generated","test":"vitest run","type-check":"tsc -p ."},"repository":{"type":"git","url":"git+https://github.com/sequelize/umzug.git"},"author":{"name":"Sascha Depold","email":"sascha@depold.com"},"contributors":[{"name":"Misha Kaletsky","email":"mmkal@kaletsky.com"},{"name":"Jukka Hyytiälä","email":"hyytiala.jukka@gmail.com"},{"name":"Pascal Pflaum","email":"mail@pascalpflaum.de"},{"name":"Pedro Augusto de Paula Barbosa","email":"papb1996@gmail.com"}],"license":"MIT","bugs":{"url":"https://github.com/sequelize/umzug/issues"},"homepage":"https://github.com/sequelize/umzug","engines":{"node":">=12"},"_id":"umzug@3.7.0","gitHead":"cc0d00b204b75623d3963b3faa8cf49634041238","types":"./lib/index.d.ts","_nodeVersion":"20.8.0","_npmVersion":"10.1.0","dist":{"integrity":"sha512-r/L2Zlilgv3SKhmP2nkA9x2Xi1PKtu2K34/i/s7AYJ2mLjEO+IxETJAK7CKf6l3QOvoy5/ChykeX9qt6ykRz6Q==","shasum":"0fadf6d6bd36b763dffd4509e98364fd875f4831","tarball":"https://registry.npmjs.org/umzug/-/umzug-3.7.0.tgz","fileCount":39,"unpackedSize":138886,"signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEYCIQD6XpdjdZVO7miZbXTvliFO+sbETCZgDMWi8MCT9TVyOgIhAOKE5v0triBTvohL2kEMOtmawRGTMwJ1gRNx3swSGL8B"}]},"_npmUser":{"name":"mmkale","email":"mmkal1@outlook.com"},"directories":{},"maintainers":[{"name":"pascal.pflaum","email":"mail@pascalpflaum.de"},{"name":"sdepold","email":"sascha@depold.com"},{"name":"sushantdhiman","email":"sushantdhiman@outlook.com"},{"name":"papb","email":"papb1996@gmail.com"},{"name":"mmkale","email":"mmkal1@outlook.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/umzug_3.7.0_1707849593972_0.08065608819382275"},"_hasShrinkwrap":false}},"readme":"# Umzug\n\n[![Build Status](https://badgen.net/github/checks/sequelize/umzug/main)](https://github.com/sequelize/umzug/actions?query=workflow%3ACI)\n[![npm](https://badgen.net/npm/v/umzug)](https://www.npmjs.com/package/umzug)\n[![npm (downloads)](https://badgen.net/npm/dm/umzug)](https://npmjs.com/package/umzug)\n\nUmzug is a framework-agnostic migration tool for Node. It provides a clean API for running and rolling back tasks.\n\n## Highlights\n\n* Written in TypeScript\n\t* Built-in typings\n\t* Auto-completion right in your IDE\n\t* Documentation right in your IDE\n* Programmatic API for migrations\n* Built-in [CLI](#cli)\n* Database agnostic\n* Supports logging of migration process\n* Supports multiple storages for migration data\n* [Usage examples](./examples)\n\n## Documentation\n\n_Note: these are the docs for the latest version of umzug, which has several breaking changes from v2.x. See [the upgrading section](#upgrading-from-v2x) for a migration guide. For the previous stable version, please refer to the [v2.x branch](https://github.com/sequelize/umzug/tree/v2.x)._\n\n### Minimal Example\n\nThe following example uses a Sqlite database through sequelize and persists the migration data in the database itself through the sequelize storage. There are several more involved examples covering a few different scenarios in the [examples folder](./examples). Note that although this uses Sequelize, Umzug isn't coupled to Sequelize, it's just one of the (most commonly-used) supported storages.\n\n```js\n// index.js\nconst { Sequelize } = require('sequelize');\nconst { Umzug, SequelizeStorage } = require('umzug');\n\nconst sequelize = new Sequelize({ dialect: 'sqlite', storage: './db.sqlite' });\n\nconst umzug = new Umzug({\n  migrations: { glob: 'migrations/*.js' },\n  context: sequelize.getQueryInterface(),\n  storage: new SequelizeStorage({ sequelize }),\n  logger: console,\n});\n\n(async () => {\n  // Checks migrations and run them if they are not already applied. To keep\n  // track of the executed migrations, a table (and sequelize model) called SequelizeMeta\n  // will be automatically created (if it doesn't exist already) and parsed.\n  await umzug.up();\n})();\n```\n\n```js\n// migrations/00_initial.js\n\nconst { Sequelize } = require('sequelize');\n\nasync function up({ context: queryInterface }) {\n\tawait queryInterface.createTable('users', {\n\t\tid: {\n\t\t\ttype: Sequelize.INTEGER,\n\t\t\tallowNull: false,\n\t\t\tprimaryKey: true\n\t\t},\n\t\tname: {\n\t\t\ttype: Sequelize.STRING,\n\t\t\tallowNull: false\n\t\t},\n\t\tcreatedAt: {\n\t\t\ttype: Sequelize.DATE,\n\t\t\tallowNull: false\n\t\t},\n\t\tupdatedAt: {\n\t\t\ttype: Sequelize.DATE,\n\t\t\tallowNull: false\n\t\t}\n\t});\n}\n\nasync function down({ context: queryInterface }) {\n\tawait queryInterface.dropTable('users');\n}\n\nmodule.exports = { up, down };\n```\n\nNote that we renamed the `context` argument to `queryInterface` for clarity. The `context` is whatever we specified when creating the Umzug instance in `index.js`.\n\n<details>\n<summary>You can also write your migrations in typescript by using `ts-node` in the entrypoint:</summary>\n\n```typescript\n// index.ts\nrequire('ts-node/register')\n\nimport { Sequelize } from 'sequelize';\nimport { Umzug, SequelizeStorage } from 'umzug';\n\nconst sequelize = new Sequelize({ dialect: 'sqlite', storage: './db.sqlite' });\n\nconst umzug = new Umzug({\n  migrations: { glob: 'migrations/*.ts' },\n  context: sequelize.getQueryInterface(),\n  storage: new SequelizeStorage({ sequelize }),\n  logger: console,\n});\n\n// export the type helper exposed by umzug, which will have the `context` argument typed correctly\nexport type Migration = typeof umzug._types.migration;\n\n(async () => {\n  await umzug.up();\n})();\n```\n\n```typescript\n// migrations/00_initial.ts\nimport type { Migration } from '..';\n\n// types will now be available for `queryInterface`\nexport const up: Migration = ({ context: queryInterface }) => queryInterface.createTable(...)\nexport const down: Migration = ({ context: queryInterface }) => queryInterface.dropTable(...)\n```\n</details>\n\nSee [these tests](./test/umzug.test.ts) for more examples of Umzug usage, including:\n\n- passing `ignore` and `cwd` parameters to the glob instructions\n- customising migrations ordering\n- finding migrations from multiple different directories\n- using non-js file extensions via a custom resolver, e.g. `.sql`\n\n### Usage\n\n#### Installation\n\nUmzug is available on npm by specifying the correct tag:\n\n```bash\nnpm install umzug\n```\n\n#### Umzug instance\n\nIt is possible to configure an Umzug instance by passing an object to the constructor.\n\n```js\nconst { Umzug } = require('umzug');\nconst umzug = new Umzug({ /* ... options ... */ });\n```\n\nDetailed documentation for these options are in the `UmzugOptions` TypeScript interface, which can be found in [src/types.ts](./src/types.ts).\n\n#### Getting all pending migrations\n\nYou can get a list of pending (i.e. not yet executed) migrations with the `pending()` method:\n\n```js\nconst migrations = await umzug.pending();\n// returns an array of all pending migrations.\n```\n\n#### Getting all executed migrations\n\nYou can get a list of already executed migrations with the `executed()` method:\n\n```js\nconst migrations = await umzug.executed();\n// returns an array of all already executed migrations\n```\n\n#### Executing pending migrations\n\nThe `up` method can be used to execute all pending migrations.\n\n```js\nconst migrations = await umzug.up();\n// returns an array of all executed migrations\n```\n\nIt is also possible to pass the name of a migration in order to just run the migrations from the current state to the passed migration name (inclusive).\n\n```js\nawait umzug.up({ to: '20141101203500-task' });\n```\n\nTo limit the number of migrations that are run, `step` can be used:\n\n```js\n// This will run the next two migrations\nawait umzug.up({ step: 2 })\n```\n\nRunning specific migrations while ignoring the right order, can be done like this:\n\n```js\nawait umzug.up({ migrations: ['20141101203500-task', '20141101203501-task-2'] });\n```\n\n#### Reverting executed migration\n\nThe `down` method can be used to revert the last executed migration.\n\n```js\nconst migration = await umzug.down();\n// reverts the last migration and returns it.\n```\n\nTo revert more than one migration, you can use `step`:\n\n```js\n// This will revert the last two migrations\nawait umzug.down({ step: 2 });\n```\n\nIt is possible to pass the name of a migration until which (inclusive) the migrations should be reverted. This allows the reverting of multiple migrations at once.\n\n```js\nconst migrations = await umzug.down({ to: '20141031080000-task' });\n// returns an array of all reverted migrations.\n```\n\nTo revert all migrations, you can pass 0 as the `to` parameter:\n\n```js\nawait umzug.down({ to: 0 });\n```\n\nReverting specific migrations while ignoring the right order, can be done like this:\n\n```js\nawait umzug.down({ migrations: ['20141101203500-task', '20141101203501-task-2'] });\n```\n\n### Migrations\n\nThere are two ways to specify migrations: via files or directly via an array of migrations.\n\n#### Migration files\n\nA migration file ideally exposes an `up` and a `down` async functions. They will perform the task of upgrading or downgrading the database.\n\n```js\nmodule.exports = {\n  async up() {\n    /* ... */\n  },\n  async down() {\n    /* ... */\n  }\n};\n```\n\nMigration files can be located anywhere - they will typically be loaded according to a glob pattern provided to the `Umzug` constructor.\n\n#### Direct migrations list\n\nYou can also specify directly a list of migrations to the `Umzug` constructor:\n\n```js\nconst { Umzug } = require('umzug');\n\nconst umzug = new Umzug({\n  migrations: [\n    {\n      // the name of the migration is mandatory\n      name: '00-first-migration',\n      async up({ context }) { /* ... */ },\n      async down({ context }) { /* ... */ }\n    },\n    {\n      name: '01-foo-bar-migration',\n      async up({ context }) { /* ... */ },\n      async down({ context }) { /* ... */ }\n    }\n  ],\n  context: sequelize.getQueryInterface(),\n  logger: console,\n});\n```\n\n#### Modifying the parameters passed to your migration methods\n\nSometimes it's necessary to modify the parameters `umzug` will pass to your migration methods when the library calls the `up` and `down` methods for each migration. This is the case when using migrations currently generated using `sequelize-cli`. In this case you can use the `resolve` fuction during migration configuration to determine which parameters will be passed to the relevant method\n\n```js\nimport { Sequelize } from 'sequelize'\nimport { Umzug, SequelizeStorage } from 'umzug'\n\nconst sequelize = new Sequelize(\n    ...\n)\n\nconst umzug = new Umzug({\n    migrations: {\n        glob: 'migrations/*.js',\n        resolve: ({ name, path, context }) => {\n            const migration = require(path)\n            return {\n                // adjust the parameters Umzug will\n                // pass to migration methods when called\n                name,\n                up: async () => migration.up(context, Sequelize),\n                down: async () => migration.down(context, Sequelize),\n            }\n        },\n    },\n    context: sequelize.getQueryInterface(),\n    storage: new SequelizeStorage({ sequelize }),\n    logger: console,\n});\n```\n\n#### Additional migration configuration options\n\nTo load migrations in another format, you can use the `resolve` function:\n\n```js\nconst { Umzug } = require('umzug')\nconst { Sequelize } = require('sequelize')\nconst fs = require('fs')\n\nconst umzug = new Umzug({\n  migrations: {\n    glob: 'migrations/*.up.sql',\n    resolve: ({ name, path, context: sequelize }) => ({\n      name,\n      up: async () => {\n        const sql = fs.readFileSync(path).toString()\n        return sequelize.query(sql)\n      },\n      down: async () => {\n        // Get the corresponding `.down.sql` file to undo this migration\n        const sql = fs.readFileSync(path.replace('.up.sql', '.down.sql')).toString()\n        return sequelize.query(sql)\n      }\n    })\n  },\n  context: new Sequelize(...),\n  logger: console,\n});\n```\n\nYou can support mixed migration file types, and use umzug's default resolver for javascript/typescript:\n\n```js\nconst { Umzug } = require('umzug')\nconst { Sequelize } = require('sequelize')\nconst fs = require('fs')\n\nconst umzug = new Umzug({\n  migrations: {\n    glob: 'migrations/*.{js,ts,up.sql}',\n    resolve: (params) => {\n      if (!params.path.endsWith('.sql')) {\n        return Umzug.defaultResolver(params)\n      }\n      const { context: sequelize } = params\n      return {\n        name: params.name,\n        up: async () => {\n          const sql = fs.readFileSync(params.path).toString()\n          return sequelize.query(sql)\n        },\n        down: async () => {\n          // Get the corresponding `.down.sql` file to undo this migration\n          const sql = fs.readFileSync(params.path.replace('.up.sql', '.down.sql')).toString()\n          return sequelize.query(sql)\n        }\n      }\n    },\n  },\n  logger: console,\n  context: new Sequelize(...),\n});\n```\n\nThe glob syntax allows loading migrations from multiple locations:\n\n```js\nconst { Umzug } = require('umzug')\nconst { Sequelize } = require('sequelize')\n\nconst umzug = new Umzug({\n  migrations: {\n    glob: '{first-folder/*.js,second-folder-with-different-naming-convention/*.js}',\n  },\n  context: new Sequelize(...),\n  logger: console,\n});\n```\n\nNote on migration file sorting:\n\n- file matches, found using [glob](https://npmjs.com/package/glob), will be lexicographically sorted based on their paths\n  - so if your migrations are `one/m1.js`, `two/m2.js`, `three/m3.js`, the resultant order will be `one/m1.js`, `three/m3.js`, `two/m2.js`\n  - similarly, if your migrations are called `m1.js`, `m2.js`, ... `m10.js`, `m11.js`, the resultant ordering will be `m1.js`, `m10.js`, `m11.js`, ... `m2.js`\n- The easiest way to deal with this is to ensure your migrations appear in a single folder, and their paths match lexicographically with the order they should run in\n- If this isn't possible, the ordering can be customised using a new instance (previously, in the beta release for v3, this could be done with `.extend(...)` - see below for example using a new instance)\n\n### Upgrading from v2.x\n\nThe Umzug class should be imported as a named import, i.e. `import { Umzug } from 'umzug'`.\n\nThe `MigrationMeta` type, which is returned by `umzug.executed()` and `umzug.pending()`, no longer has a `file` property - it has a `name` and *optional* `path` - since migrations are not necessarily bound to files on the file system.\n\nThe `migrations.glob` parameter replaces `path`, `pattern` and `traverseDirectories`. It can be used, in combination with `cwd` and `ignore` to do much more flexible file lookups. See https://npmjs.com/package/glob for more information on the syntax.\n\nThe `migrations.resolve` parameter replaces `customResolver`. Explicit support for `wrap` and `nameFormatter` has been removed - these can be easily implemented in a `resolve` function.\n\nThe constructor option `logging` is replaced by `logger` to allow for `warn` and `error` messages in future. NodeJS's global `console` object can be passed to this. To disable logging, replace `logging: false` with `logger: undefined`.\n\nEvents have moved from the default nodejs `EventEmitter` to [emittery](https://www.npmjs.com/package/emittery). It has better design for async code, a less bloated API surface and strong types. But, it doesn't allow passing multiple arguments to callbacks, so listeners have to change slightly, as well as `.addListener(...)` and `.removeListener(...)` no longer being supported (`.on(...)` and `.off(...)` should now be used):\n\nBefore:\n\n```js\numzug.on('migrating', (name, m) => console.log({ name, path: m.path }))\n```\n\nAfter:\n\n```js\numzug.on('migrating', ev => console.log({ name: ev.name, path: ev.path }))\n```\n\nThe `Umzug#execute` method is removed. Use `Umzug#up` or `Umzug#down`.\n\nThe options for `Umguz#up` and `Umzug#down` have changed:\n- `umzug.up({ to: 'some-name' })` and `umzug.down({ to: 'some-name' })` are still valid.\n- `umzug.up({ from: '...' })` and `umzug.down({ from: '...' })` are no longer supported. To run migrations out-of-order (which is not generally recommended), you can explicitly use `umzug.up({ migrations: ['...'] })` and `umzug.down({ migrations: ['...'] })`.\n- name matches must be exact. `umzug.up({ to: 'some-n' })` will no longer match a migration called `some-name`.\n- `umzug.down({ to: 0 })` is still valid but `umzug.up({ to: 0 })` is not.\n- `umzug.up({ migrations: ['m1', 'm2'] })` is still valid but the shorthand `umzug.up(['m1', 'm2'])` has been removed.\n- `umzug.down({ migrations: ['m1', 'm2'] })` is still valid but the shorthand `umzug.down(['m1', 'm2'])` has been removed.\n- `umzug.up({ migrations: ['m1', 'already-run'] })` will throw an error, if `already-run` is not found in the list of pending migrations.\n- `umzug.down({ migrations: ['m1', 'has-not-been-run'] })` will throw an error, if `has-not-been-run` is not found in the list of executed migrations.\n- `umzug.up({ migrations: ['m1', 'm2'], rerun: 'ALLOW' })` will re-apply migrations `m1` and `m2` even if they've already been run.\n- `umzug.up({ migrations: ['m1', 'm2'], rerun: 'SKIP' })` will skip migrations `m1` and `m2` if they've already been run.\n- `umzug.down({ migrations: ['m1', 'm2'], rerun: 'ALLOW' })` will \"revert\" migrations `m1` and `m2` even if they've never been run.\n- `umzug.down({ migrations: ['m1', 'm2'], rerun: 'SKIP' })` will skip reverting migrations `m1` and `m2` if they haven't been run or are already reverted.\n- `umzug.up({ migrations: ['m1', 'does-not-exist', 'm2'] })` will throw an error if the migration name is not found. Note that the error will be thrown and no migrations run unless _all_ migration names are found - whether or not `rerun: 'ALLOW'` is added.\n\nThe `context` parameter replaces `params`, and is passed in as a property to migration functions as an options object, alongs side `name` and `path`. This means the signature for migrations, which in v2 was `(context) => Promise<void>`, has changed slightly in v3, to `({ name, path, context }) => Promise<void>`.\n\n#### Handling existing v2-format migrations\n\nThe `resolve` function can also be used to upgrade your umzug version to v3 when you have existing v2-compatible migrations:\n\n```js\nconst { Umzug } = require('umzug');\n\nconst umzug = new Umzug({\n  migrations: {\n    glob: 'migrations/umzug-v2-format/*.js',\n    resolve: ({name, path, context}) => {\n      // Adjust the migration from the new signature to the v2 signature, making easier to upgrade to v3\n      const migration = require(path)\n      return { name, up: async () => migration.up(context), down: async () => migration.down(context) }\n    }\n  },\n  context: sequelize.getQueryInterface(),\n  logger: console,\n});\n```\n\nSimilarly, you no longer need `migrationSorting`, you can instantiate a new `Umzug` instance to manipulate migration lists directly:\n\n```js\nconst { Umzug } = require('umzug');\n\nconst parent = new Umzug({\n  migrations: { glob: 'migrations/**/*.js' },\n  context: sequelize.getQueryInterface(),\n})\n\nconst umzug = new Umzug({\n  ...parent.options,\n  migrations: ctx => (await parent.migrations()).sort((a, b) => b.path.localeCompare(a.path))\n})\n```\n\n### Storages\n\nStorages define where the migration data is stored.\n\n#### JSON Storage\n\nUsing `JSONStorage` will create a JSON file which will contain an array with all the executed migrations. You can specify the path to the file. The default for that is `umzug.json` in the working directory of the process.\n\nDetailed documentation for the options it can take are in the `JSONStorageConstructorOptions` TypeScript interface, which can be found in [src/storage/json.ts](./src/storage/json.ts).\n\n#### Memory Storage\n\nUsing `memoryStorage` will store migrations with an in-memory array. This can be useful for proof-of-concepts or tests, since it doesn't interact with databases or filesystems.\n\nIt doesn't take any options, just import the `memoryStorage` function and call it to return a storage instance:\n\n```typescript\nimport { Umzug, memoryStorage } from 'umzug'\n\nconst umzug = new Umzug({\n  migrations: ...,\n  storage: memoryStorage(),\n  logger: console,\n})\n```\n\n#### Sequelize Storage\n\nUsing `SequelizeStorage` will create a table in your SQL database called `SequelizeMeta` containing an entry for each executed migration. You will have to pass a configured instance of Sequelize or an existing Sequelize model. Optionally you can specify the model name, table name, or column name. All major Sequelize versions are supported.\n\nDetailed documentation for the options it can take are in the `_SequelizeStorageConstructorOptions` TypeScript interface, which can be found in [src/storage/sequelize.ts](./src/storage/sequelize.ts).\n\nThis library has been tested with sequelize v6. It may or may not work with lower versions - use at your own risk.\n\n#### MongoDB Storage\n\nUsing `MongoDBStorage` will create a collection in your MongoDB database called `migrations` containing an entry for each executed migration. You will have either to pass a MongoDB Driver Collection as `collection` property. Alternatively you can pass a established MongoDB Driver connection and a collection name.\n\nDetailed documentation for the options it can take are in the `MongoDBStorageConstructorOptions` TypeScript interface, which can be found in [src/storage/mongodb.ts](./src/storage/mongodb.ts).\n\n#### Custom\n\nIn order to use a custom storage, you can pass your storage instance to Umzug constructor.\n\n```js\nclass CustomStorage {\n  constructor(...) {...}\n  logMigration(...) {...}\n  unlogMigration(...) {...}\n  executed(...) {...}\n}\n\nconst umzug = new Umzug({ storage: new CustomStorage(...), logger: console })\n```\n\nYour instance must adhere to the [UmzugStorage](./src/storage/contract.ts) interface. If you're using TypeScript you can ensure this at compile time, and get IDE type hints by importing it:\n\n```typescript\nimport { UmzugStorage } from 'umzug'\n\nclass CustomStorage implements UmzugStorage {\n  /* ... */\n}\n```\n\n### Events\n\nUmzug is an [emittery event emitter](https://www.npmjs.com/package/emittery). Each of the following events will be called with migration parameters as its payload (with `context`, `name`, and nullable `path` properties). Events are a convenient place to implement application-specific logic that must run around each migration:\n\n* `migrating` - A migration is about to be executed.\n* `migrated` - A migration has successfully been executed.\n* `reverting` - A migration is about to be reverted.\n* `reverted` - A migration has successfully been reverted.\n\nThese events run at the beginning and end of `up` and `down` calls. They'll receive an object containing a `context` property:\n\n- `beforeCommand` - Before any command (`'up' | 'down' | 'executed' | 'pending'`) is run.\n- `afterCommand` - After any command (`'up' | 'down' | 'executed' | 'pending'`) is run. Note: this will always run, even if the command throws an error.\n\nThe [`FileLocker` class](./src/file-locker.ts) uses `beforeAll` and `afterAll` to implement a simple filesystem-based locking mechanism.\n\nAll events are type-safe, so IDEs will prevent typos and supply strong types for the event payloads.\n\n### Errors\n\nWhen a migration throws an error, it will be wrapped in a `MigrationError` which captures the migration metadata (name, path etc.) as well as the original error message, and _will be rethrown_. In most cases, this is expected behaviour, and doesn't require any special handling beyond standard error logging setups.\n\nIf you expect failures and want to try to recover from them, you will need to try-catch the call to `umzug.up()`. You can access the original error from the `.cause` property if necessary:\n\n```js\ntry {\n  await umzug.up();\n} catch (e) {\n  if (e instanceof MigrationError) {\n    const original = e.cause;\n    // do something with the original error here\n  }\n  throw e;\n}\n```\n\nUnder the hood, [verror](https://npmjs.com/package/verror) is used to wrap errors.\n\n### CLI\n\n🚧🚧🚧 The CLI is new to Umzug v3. Feedback on it is welcome in [discussions](https://github.com/sequelize/umzug/discussions) 🚧🚧🚧\n\nUmzug instances provide a `.runAsCLI()` method. When called, this method will automatically cause your program to become a complete CLI, with help text and such:\n\n```js\n// migrator.js\nconst { Umzug } = require('umzug')\n\nconst umzug = new Umzug({ ... })\n\nexports.umzug = umzug\n\nif (require.main === module) {\n  umzug.runAsCLI()\n}\n```\n\nNote that this uses the [@rushstack/ts-command-line](https://www.npmjs.com/package/@rushstack/ts-command-line) package, which shows only the top-level message of any errors throw by default. See [here](https://github.com/sequelize/umzug/issues/619#issuecomment-1793297576) for how you can see a full stack trace.\n\n#### CLI Usage\n\nA script like the one above is now a runnable CLI program. You can run `node migrator.js --help` to see how to use it. It will print something like:\n\n<!-- codegen:start {preset: custom, source: ./codegen.js, export: cliHelp} -->\n```\nusage: <script> [-h] <command> ...\n\nUmzug migrator\n\nPositional arguments:\n  <command>\n    up        Applies pending migrations\n    down      Revert migrations\n    pending   Lists pending migrations\n    executed  Lists executed migrations\n    create    Create a migration file\n\nOptional arguments:\n  -h, --help  Show this help message and exit.\n\nFor detailed help about a specific command, use: <script> <command> -h\n```\n<!-- codegen:end -->\n\n#### Running migrations\n\n`node migrator up` and `node migrator down` apply and revert migrations respectively. They're the equivalent of the `.up()` and `.down()` methods.\n\nUse `node migrator up --help` and `node migrator down --help` for options (running \"to\" a specific migration, passing migration names to be run explicitly, and specifying the rerun behavior):\n\nUp:\n<!-- codegen:start {preset: custom, source: ./codegen.js, export: cliHelp, action: up} -->\n```\nusage: <script> up [-h] [--to NAME] [--step COUNT] [--name MIGRATION]\n                   [--rerun {THROW,SKIP,ALLOW}]\n                   \n\nPerforms all migrations. See --help for more options\n\nOptional arguments:\n  -h, --help            Show this help message and exit.\n  --to NAME             All migrations up to and including this one should be \n                        applied\n  --step COUNT          Apply this many migrations. If not specified, all \n                        will be applied.\n  --name MIGRATION      Explicity declare migration name(s) to be applied. \n                        Only these migrations will be applied.\n  --rerun {THROW,SKIP,ALLOW}\n                        Specify what action should be taken when a migration \n                        that has already been applied is passed to --name. \n                        The default value is \"THROW\".\n```\n<!-- codegen:end -->\n\nDown:\n<!-- codegen:start {preset: custom, source: ./codegen.js, export: cliHelp, action: down} -->\n```\nusage: <script> down [-h] [--to NAME] [--step COUNT] [--name MIGRATION]\n                     [--rerun {THROW,SKIP,ALLOW}]\n                     \n\nUndoes previously-applied migrations. By default, undoes the most recent \nmigration only. Use --help for more options. Useful in development to start \nfrom a clean slate. Use with care in production!\n\nOptional arguments:\n  -h, --help            Show this help message and exit.\n  --to NAME             All migrations up to and including this one should be \n                        reverted. Pass '0' to revert all.\n  --step COUNT          Revert this many migrations. If not specified, only \n                        the most recent migration will be reverted.\n  --name MIGRATION      Explicity declare migration name(s) to be reverted. \n                        Only these migrations will be reverted.\n  --rerun {THROW,SKIP,ALLOW}\n                        Specify what action should be taken when a migration \n                        that has already been applied is passed to --name. \n                        The default value is \"THROW\".\n```\n<!-- codegen:end -->\n\n\n#### Listing migrations\n\n```bash\nnode migrator pending # list migrations yet to be run\nnode migrator executed # list migrations that have already run\n\nnode migrator pending --json # list pending migrations including names and paths, in a json array format\nnode migrator executed --json # list executed migrations including names and paths, in a json array format\n\nnode migrator pending --help # show help/options\nnode migrator executed --help # show help/options\n```\n\n<!-- codegen:start {preset: custom, source: ./codegen.js, export: cliHelp, action: pending} -->\n```\nusage: <script> pending [-h] [--json]\n\nPrints migrations returned by `umzug.pending()`. By default, prints migration \nnames one per line.\n\nOptional arguments:\n  -h, --help  Show this help message and exit.\n  --json      Print pending migrations in a json format including names and \n              paths. This allows piping output to tools like jq. Without this \n              flag, the migration names will be printed one per line.\n```\n<!-- codegen:end -->\n\n<!-- codegen:start {preset: custom, source: ./codegen.js, export: cliHelp, action: executed} -->\n```\nusage: <script> executed [-h] [--json]\n\nPrints migrations returned by `umzug.executed()`. By default, prints \nmigration names one per line.\n\nOptional arguments:\n  -h, --help  Show this help message and exit.\n  --json      Print executed migrations in a json format including names and \n              paths. This allows piping output to tools like jq. Without this \n              flag, the migration names will be printed one per line.\n```\n<!-- codegen:end -->\n\n#### Creating migrations - CLI\n\nUsually, migrations correspond to files on the filesystem. The CLI exposes a way to create migration files easily:\n\n```bash\nnode migrator create --name my-migration.js\n```\n\nThis will create a file with a name like `2000.12.25T12.34.56.my-migration.js` in the same directory as the most recent migration file. If it's the very first migration file, you need to specify the folder explicitly:\n\n```bash\nnode migrator create --name my-migration.js --folder path/to/directory\n```\n\nThe timestamp prefix can be customized to be date-only or omitted, but be aware that it's strongly recommended to ensure your migrations are lexicographically sortable so it's easy for humans and tools to determine what order they should run in - so the default prefix is recommended.\n\nThis will generate a migration file called `<<timestamp>>.my-migration.js` with the default migration template for `.js` files that ships with Umzug.\n\nUmzug also ships with default templates for [`.ts`, `.cjs`, `.mjs` and `.sql` files](./src/templates.ts). Umzug will choose the template based on the extension you provide in `name`.\n\nYou can specify a custom template for your project when constructing an umzug instance via the `template` option. It should be a function which receives a filepath string, and returns an array of `[filepath, content]` pairs. Usually, just one pair is needed, but a second could be used to include a \"down\" migration in a separate file:\n\n```js\nconst umzug = new Umzug({\n  migrations: ...,\n\tcreate: {\n\t\ttemplate: filepath => [\n\t\t\t[filepath, fs.readFileSync('path/to/your/template/file').toString()],\n\t\t]\n\t}\n})\n```\n\nThe create command includes some safety checks to make sure migrations aren't created with ambiguous ordering, and that they will be picked up by umzug when applying migrations. The first pair is expected to be the \"up\" migration file, and to be picked up by the `pending` command.\n\nUse `node migrator create --help` for more options:\n\n<!-- codegen:start {preset: custom, source: ./codegen.js, export: cliHelp, action: create} -->\n```\nusage: <script> create [-h] --name NAME [--prefix {TIMESTAMP,DATE,NONE}]\n                       [--folder PATH] [--allow-extension EXTENSION]\n                       [--skip-verify] [--allow-confusing-ordering]\n                       \n\nGenerates a placeholder migration file using a timestamp as a prefix. By \ndefault, mimics the last existing migration, or guesses where to generate the \nfile if no migration exists yet.\n\nOptional arguments:\n  -h, --help            Show this help message and exit.\n  --name NAME           The name of the migration file. e.g. my-migration.js, \n                        my-migration.ts or my-migration.sql. Note - a prefix \n                        will be added to this name, usually based on a \n                        timestamp. See --prefix\n  --prefix {TIMESTAMP,DATE,NONE}\n                        The prefix format for generated files. TIMESTAMP uses \n                        a second-resolution timestamp, DATE uses a \n                        day-resolution timestamp, and NONE removes the prefix \n                        completely. The default value is \"TIMESTAMP\".\n  --folder PATH         Path on the filesystem where the file should be \n                        created. The new migration will be created as a \n                        sibling of the last existing one if this is omitted.\n  --allow-extension EXTENSION\n                        Allowable extension for created files. By default .js,\n                         .ts and .sql files can be created. To create txt \n                        file migrations, for example, you could use '--name \n                        my-migration.txt --allow-extension .txt' This \n                        parameter may alternatively be specified via the \n                        UMZUG_ALLOW_EXTENSION environment variable.\n  --skip-verify         By default, the generated file will be checked after \n                        creation to make sure it is detected as a pending \n                        migration. This catches problems like creation in the \n                        wrong folder, or invalid naming conventions. This \n                        flag bypasses that verification step.\n  --allow-confusing-ordering\n                        By default, an error will be thrown if you try to \n                        create a migration that will run before a migration \n                        that already exists. This catches errors which can \n                        cause problems if you change file naming conventions. \n                        If you use a custom ordering system, you can disable \n                        this behavior, but it's strongly recommended that you \n                        don't! If you're unsure, just ignore this option.\n```\n<!-- codegen:end -->\n\n### Creating migrations - API\n\nUmzug includes an optional helper for generating migration files. It's often most convenient to create files using the [CLI helper](#creating-migrations---cli), but the equivalent API also exists on an umzug instance:\n\n```js\nawait umzug.create({ name: 'my-new-migration.js' })\n```\n\n## License\n\nSee the [LICENSE file](./LICENSE)\n","maintainers":[{"name":"pascal.pflaum","email":"mail@pascalpflaum.de"},{"name":"sdepold","email":"sascha@depold.com"},{"name":"sushantdhiman","email":"sushantdhiman@outlook.com"},{"name":"papb","email":"papb1996@gmail.com"},{"name":"mmkale","email":"mmkal1@outlook.com"}],"time":{"modified":"2024-02-13T18:39:54.311Z","created":"2014-12-02T20:48:38.158Z","1.0.0":"2014-12-02T20:48:38.158Z","1.1.0":"2014-12-03T21:39:33.358Z","1.2.0":"2014-12-11T19:34:58.705Z","1.2.1":"2014-12-14T20:04:52.297Z","1.2.2":"2014-12-15T19:44:20.592Z","1.2.3":"2014-12-23T20:52:14.504Z","1.2.4":"2014-12-27T13:01:20.052Z","1.3.0":"2015-01-25T20:32:39.506Z","1.3.1":"2015-02-01T20:13:33.430Z","1.4.0":"2015-02-13T19:14:29.823Z","1.5.0":"2015-02-19T18:54:06.455Z","1.6.0":"2015-02-21T18:57:18.155Z","1.7.0":"2015-11-21T12:08:13.562Z","1.7.1":"2015-12-03T05:24:30.078Z","1.7.2":"2015-12-27T20:45:03.765Z","1.8.0":"2016-01-05T19:36:22.219Z","1.8.1":"2016-02-09T21:04:20.649Z","1.9.0":"2016-02-09T21:06:05.204Z","1.9.1":"2016-03-14T05:58:20.679Z","1.10.0":"2016-04-17T17:58:10.027Z","1.11.0":"2016-04-29T20:36:31.958Z","1.12.0":"2017-04-21T14:47:41.185Z","2.0.0":"2017-05-10T15:05:26.972Z","2.0.1":"2017-05-10T15:35:51.137Z","2.1.0":"2017-10-25T18:20:55.458Z","2.2.0":"2018-11-20T09:30:05.796Z","2.3.0":"2020-03-22T13:04:40.198Z","3.0.0-beta.0":"2020-03-29T17:40:30.449Z","3.0.0-beta.1":"2020-03-29T21:10:29.721Z","3.0.0-beta.2":"2020-04-05T21:39:50.947Z","3.0.0-beta.3":"2020-04-07T02:48:41.183Z","3.0.0-beta.4":"2020-05-01T18:27:38.856Z","3.0.0-beta.5":"2020-05-14T00:38:24.875Z","3.0.0-beta.6":"2020-10-11T23:24:13.540Z","3.0.0-beta.7":"2020-10-31T18:47:06.154Z","3.0.0-beta.8":"2020-10-31T20:11:12.558Z","3.0.0-beta.9":"2020-11-19T16:22:17.603Z","3.0.0-beta-cli.9":"2020-11-19T20:20:09.572Z","3.0.0-beta-cli.10":"2020-11-20T21:16:17.992Z","3.0.0-beta-cli.11":"2020-11-24T14:56:07.098Z","3.0.0-beta-cli.12":"2020-11-24T15:25:22.285Z","3.0.0-beta.10":"2020-12-07T19:24:47.659Z","3.0.0-beta.11":"2020-12-10T20:42:31.021Z","3.0.0-beta.12":"2020-12-10T20:51:19.956Z","3.0.0-beta.13":"2020-12-15T15:53:12.857Z","3.0.0-beta.14":"2020-12-21T19:03:07.241Z","3.0.0-beta.15":"2021-02-07T21:34:54.771Z","3.0.0-beta.16":"2021-05-23T22:53:52.954Z","3.0.0-beta-cli.17":"2021-07-28T20:31:44.414Z","3.0.0-beta-cli.18":"2021-12-16T02:56:33.811Z","3.0.0-beta-cli.19":"2021-12-16T03:00:48.993Z","3.0.0-beta.19":"2021-12-16T03:01:51.886Z","3.0.0":"2021-12-17T12:53:27.791Z","3.1.0":"2022-03-26T22:02:10.715Z","3.1.1":"2022-04-02T14:59:16.607Z","3.1.2":"2022-08-12T17:54:58.786Z","3.2.0":"2022-08-12T18:13:47.578Z","3.2.1":"2022-08-13T09:11:11.252Z","3.3.0":"2023-08-02T14:43:43.826Z","3.3.1":"2023-08-03T07:37:27.082Z","3.4.0":"2023-11-04T12:38:17.697Z","3.5.0-0":"2023-11-06T18:47:41.731Z","3.5.0":"2023-12-15T03:09:15.389Z","3.5.1":"2024-01-17T17:18:26.800Z","3.6.0":"2024-01-31T18:13:57.903Z","3.6.1":"2024-01-31T18:29:46.031Z","3.7.0":"2024-02-13T18:39:54.151Z"},"homepage":"https://github.com/sequelize/umzug","repository":{"type":"git","url":"git+https://github.com/sequelize/umzug.git"},"bugs":{"url":"https://github.com/sequelize/umzug/issues"},"license":"MIT","readmeFilename":"README.md","keywords":["migrate","migration","migrations","sequelize","database"],"contributors":[{"name":"Misha Kaletsky","email":"mmkal@kaletsky.com"},{"name":"Jukka Hyytiälä","email":"hyytiala.jukka@gmail.com"},{"name":"Pascal Pflaum","email":"mail@pascalpflaum.de"},{"name":"Pedro Augusto de Paula Barbosa","email":"papb1996@gmail.com"}],"author":{"name":"Sascha Depold","email":"sascha@depold.com"},"users":{"oldfish":true,"nazy":true,"yonigoldberg":true,"rochejul":true}}